==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/Lexer.lua
==============================================================================
       --imports
     1 local stringx = require("pl.stringx")
     1 local Reader = require("dogma.lex._.Reader")
     1 local ProcessedList = require("dogma.lex._.ProcessedList")
     1 local AdvancedList = require("dogma.lex._.AdvancedList")
     1 local Eol = require("dogma.lex._.Eol")
     1 local Annotation = require("dogma.lex._.Annotation")
     1 local Comment = require("dogma.lex._.Comment")
     1 local Directive = require("dogma.lex._.Directive")
     1 local Name = require("dogma.lex._.Name")
     1 local Keyword = require("dogma.lex._.Keyword")
     1 local Literal = require("dogma.lex._.Literal")
     1 local LiteralType = require("dogma.lex.LiteralType")
     1 local Symbol = require("dogma.lex._.Symbol")
     1 local TokenType = require("dogma.lex.TokenType")

       --A lexer os scanner.
     1 local Lexer = {}
     1 Lexer.__index = Lexer
     1 package.loaded[...] = Lexer

       --Constructor.
       --
       --@param props:object Lexer properties.
     1 function Lexer.new(props)
         local self

         --(1) arguments
   680   if not props then props = {} end

         --(2) create
  1360   self = setmetatable({
   680     _ = {
   680       comments = not not props.comments
   680     }
  1360   }, Lexer)

         --(3) return
   680   return self
       end

       --Scan a text.
       --
       --@param text:string  Text to analyze.
       --@param file?:string File path.
       --
       --@return self
     1 function Lexer:scan(text, file)
         --(1) arguments
   681   if not text then error("text expected.") end

         --(2) init
   680   self._.reader = Reader.new(text)
   680   self._.file = file or "anonymous code"
   680   self._.processed = ProcessedList.new(3)
   680   self._.token = nil
   680   self._.advanced = AdvancedList.new(3)

         --(3) return
   680   return self
       end

       --Return the last token that has been read.
       --
       --@return Token
     1 function Lexer:_getLastReadToken()
  1906   return self._.token
       end

       --Scan the next token.
       --
       --@overload
       --@return Token
       --
       --@overload
       --@param typ:TokenType  Token type to read.
       --@param val:string     Token value to read.
       --@return Token
     1 function Lexer:next(typ, val)
  9598   local reader = self._.reader
         local tok

         --(1) get token to return
  9598   if self:_hasTokenToShift() then
  3612     self:_shift()
         else
           local ch

           --get next char
  5986     ch = reader:next()

  7753     while ch ~= nil and (ch.char == " " or ch.char == "\t") do
  1767       ch = reader:next()
           end

  5986     if ch ~= nil then
  5077       ch = ch.char

             --analyze token
  5077       reader:unshift()

  5077       if ch == "\n" then
   846         tok = self:_scanEol()
  4231       elseif ch == "@" then
    14         tok = self:_scanAnnotation()
  4217       elseif ch == "_" or stringx.isalpha(ch) then
  1906         tok = self:_scanId()
  2311       elseif ch == "'" then
     1         tok = self:_scanName()
  2310       elseif stringx.isdigit(ch) then
   478         tok = self:_scanLiteralNumber()
  1832       elseif ch == '"' then
    87         tok = self:_scanLiteralString()
  1745       elseif ch == "#" then
    48         reader:next()
    48         ch = reader:next().char

    48         reader:unshift()
    48         reader:unshift()

    48         if ch == "!" then
    43           tok = self:_scanDirective()
               else
     5           tok = self:_scanComment()

     5           if not self._.comments then
     1             return self:next()
                 end
               end
             else
  1697         tok = self:_scanSymbol()
             end

  5067       self:_backUpToken()
  5067       self._.token = tok
           else
   909       self:_backUpToken()
   909       self._.token = nil
           end
         end

         --(2) check
  9588   if typ then
  1936     tok = self._.token

  1936     if tok == nil then
     2       error(string.format("'%s' expected at the end of code.", val))
           end

  1934     if tok.type ~= typ or (val ~= nil and tok.value ~= val) then
    16       if typ == TokenType.EOL then
     4         error(string.format(
     2           "end of line expected on (%s, %s).",
     2           tok.line,
                 tok.col
     2         ))
    14       elseif typ == TokenType.NAME then
     6         error(string.format(
     3           "name expected on (%s, %s).",
     3           tok.line,
                 tok.col
     3         ))
    11       elseif typ == TokenType.LITERAL then
     2         error(string.format(
     1           "literal expected on (%s, %s).",
     1           tok.line,
                 tok.col
     1         ))
             else
    20         error(string.format(
    10           "'%s' expected on (%s, %s).",
    10           val,
    10           tok.line,
                 tok.col
    10         ))
             end
           end
         end

         --(3) return
  9570   return self._.token
       end

       --Advance the next token.
       --
       --@return Token
     1 function Lexer:advance(i)
         local tok

         --(1) arguments
  6600   if i == nil then
  6459     i = 1
         end

         --(2) get token
  6600   if #self._.advanced >= i then
  3108     tok = self._.advanced._.items[i]
         else
  3492     if i == 1 then
  3353       tok = self:next()
  3353       self:unshift()
   139     elseif i == 2 then
   117       self:next()
   117       tok = self:next()
   117       self:unshift()
   117       self:unshift()
    22     elseif i == 3 then
    22       self:next()
    22       self:next()
    22       tok = self:next()
    22       self:unshift()
    22       self:unshift()
    22       self:unshift()
           end
         end

         --(3) return
  6600   return tok
       end

       --Check whether the lexer has some token to shift.
       --
       --@return bool
     1 function Lexer:_hasTokenToShift()
  9598   return #self._.advanced > 0
       end

       --Shift a token: <- processed <- current <- advanced
     1 function Lexer:_shift()
         --(1) pre
  3613   if #self._.advanced == 0 then
     1     error("no advanced token to shift.")
         end

         --(2) current to processed
  3612   if self._.token then
  2891     self._.processed:insert(self._.token)
         end

         --(3) advanced to current
  3612   self._.token = self._.advanced:remove()
       end

       --Unshift a char: processed -> current -> advanced
     1 function Lexer:unshift()
         --(1) pre
  4639   if not self._.token and #self._.processed == 0 then
     1     error("no current token to unshift.")
         end

         --(2) current to advanced
  4638   self._.advanced:insert(self._.token)

         --(3) last processed to current
  4638   if #self._.processed == 0 then
   723     self._.token = nil
         else
  3915     self._.token = self._.processed:remove()
         end
       end

       --Shift current token to processed tokens: processed <- token.
     1 function Lexer:_backUpToken()
  5976   if self._.token then
  5312     self._.processed:insert(self._.token)
         end
       end

       --Scan an end of line.
       --
       --@return Eol
     1 function Lexer:_scanEol()
   846   local reader = self._.reader
   846   local ch = reader:next()

   846   return Eol.new(ch.line, ch.col)
       end

       --Scan an annotation.
       --
       --@return Annotation
     1 function Lexer:_scanAnnotation()
    14   local rdr = self._.reader
         local state, ln, col, val
    14   local State = {
    14     START = 1,
    14     VALUE = 2,
    14     END = 3
         }

         --(1) state machine
    14   state = State.START

   124   while state ~= State.END do
   110     local ch = rdr:next()

   110     if state == State.START then
    14       ln, col, val = ch.line, ch.col, ""
    14       state = State.VALUE
    96     elseif state == State.VALUE then
    96       ch = ch.char

    96       if not (stringx.isalnum(ch) or ch == "_") then
    14         rdr:unshift()
    14         state = State.END
             else
    82         val = val .. ch
             end
           end
         end

         --(2) return
    14   return Annotation.new(ln, col, val)
       end

       --Scan a directive.
       --
       --@return Directive
     1 function Lexer:_scanDirective()
    43   local rdr = self._.reader
         local state, ln, col, val
    43   local State = {
    43     START1 = 1,
    43     START2 = 2,
    43     VALUE = 3,
    43     END = 4
         }

         --(1) state machine
    43   state = State.START1

   526   while state ~= State.END do
   483     local ch = rdr:next()

   483     if state == State.START1 then
    43       ln, col, val = ch.line, ch.col, ""
    43       state = State.START2
   440     elseif state == State.START2 then
    43       state = State.VALUE
   397     elseif state == State.VALUE then
   397       ch = ch.char

   397       if ch == "\n" then
    43         state = State.END
             else
   354         val = val .. ch
             end
           end
         end

    43   if not (val:find("^if [a-zA-Z]+ then$") or val:find("^if not [a-zA-Z]+ then$") or val:find("^/") or val == "end" or val == "else") then
     2     error(string.format("on (%s,%s), invalid directive.", ln, col))
         end

         --(2) return
    41   return Directive.new(ln, col, val)
       end

       --Scan a comment.
       --
       --@return Comment
     1 function Lexer:_scanComment()
     5   local reader = self._.reader
         local state, ln, col, comm
     5   local State = {
     5     START = 1,
     5     TEXT = 2,
     5     POSSIBLE_END = 3,
     5     END = 4
         }

         --(1) state machine
     5   state = State.START

   120   while state ~= State.END do
   115     local ch = reader:next()

   115     if state == State.START then
     5       ln, col, comm = ch.line, ch.col, ""
     5       state = State.TEXT
   110     elseif state == State.TEXT then
   104       ch = ch.char

   104       if ch == "\n" then
     6         state = State.POSSIBLE_END
             else
    98         comm = comm .. ch
             end
           else  --POSSIBLE_END
     6       if ch == nil then
     4         reader:unshift()  --current: nil
     4         reader:unshift()  --end of line
     4         state = State.END
             else
     2         ch = ch.char

     2         if ch == "#" then
     1           comm = comm .. "\n"
     1           state = State.TEXT
               else
     1           reader:unshift()  --current char
     1           reader:unshift()  --eol
     1           state = State.END
               end
             end
           end
         end

         --(2) return
     5   return Comment.new(ln, col, comm)
       end

       --Scan an identifier.
       --
       --@return Id
     1 function Lexer:_scanId()
  1906   local reader = self._.reader
         local state, ln, col, id
  1906   local State = {
  1906     START = 1,
  1906     MIDDLE = 2,
  1906     END = 3
         }

         --(1) state machine
  1906   state = State.START

  8797   while state ~= State.END do
  6891     local ch = reader:next()

  6891     if state == State.START then
  1906       ln, col = ch.line, ch.col
  1906       id = ch.char
  1906       state = State.MIDDLE
           else
  4985       ch = ch.char

  4985       if ch == "_" or stringx.isalnum(ch) then
  3079         id = id .. ch
             else
  1906         state = State.END
  1906         reader:unshift()
             end
           end
         end

         --(2) return
  1906   local last = self:_getLastReadToken()

  1906   if (last and last.type == TokenType.SYMBOL and (last.value == "." or last.value == ":")) or
  1773      not Keyword.isKeyword(id) then
  1256     return Name.new(ln, col, id)
         else
   650     return Keyword.new(ln, col, id)
         end
       end

       --Scan a name.
       --
       --@return Name
     1 function Lexer:_scanName()
     1   local reader = self._.reader
         local state, ln, col, id, ch
     1   local State = {
     1     START = 1,
     1     ID = 2,
     1     END = 3
         }

         --(1) state machine
     1   state = State.START
     1   ch = reader:next()  --'
     1   ln, col = ch.line, ch.col

     9   while state ~= State.END do
     8     ch = reader:next()

     8     if state == State.START then
     1       id = ch.char
     1       state = State.ID
           else --State.ID
     7       ch = ch.char

     7       if ch == "'" then
     1         state = State.END
             else
     6         id = id .. ch
             end
           end
         end

         --(2) return
     1   return Name.new(ln, col, id)
       end

       --Scan a symbol.
       --
       --@return Symbol
     1 function Lexer:_scanSymbol()
  1697   local reader = self._.reader
         local state, ln, col, sym
  1697   local State = {
  1697     START = 1,
  1697     MIDDLE = 2,
  1697     END = 3
         }
  1697   local SYMBOLS = {
  1697     ["+"] = true,
  1697     ["+="] = true,
  1697     ["-"] = true,
  1697     ["-="] = true,
  1697     ["->"] = true,
  1697     ["*"] = true,
  1697     ["*="] = true,
  1697     ["**"] = true,
  1697     ["**="] = true,
  1697     ["/"] = true,
  1697     ["/="] = true,
  1697     ["%"] = true,
  1697     ["%="] = true,
  1697     ["="] = true,
  1697     ["=="] = true,
  1697     ["==="] = true,
  1697     ["=~"] = true,
  1697     ["!"] = true,
  1697     ["!="] = true,
  1697     ["!=="] = true,
  1697     ["!~"] = true,
  1697     ["<"] = true,
  1697     ["<<"] = true,
  1697     ["<<="] = true,
  1697     ["<="] = true,
  1697     [">"] = true,
  1697     [">>"] = true,
  1697     [">>="] = true,
  1697     [">="] = true,
  1697     ["^"] = true,
  1697     ["^="] = true,
  1697     ["~"] = true,
  1697     ["~="] = true,
  1697     ["("] = true,
  1697     [")"] = true,
  1697     ["["] = true,
  1697     ["]"] = true,
  1697     ["{"] = true,
  1697     ["}"] = true,
  1697     [";"] = true,
  1697     [":"] = true,
  1697     [":="] = true,
  1697     [":=|"] = true,
  1697     ["."] = true,
  1697     [".."] = true,
  1697     ["..."] = true,
  1697     [".="] = true,
  1697     ["?"] = true,
  1697     ["?="] = true,
  1697     ["&"] = true,
  1697     ["&="] = true,
  1697     ["&&"] = true,
  1697     ["|"] = true,
  1697     ["|="] = true,
  1697     ["||"] = true,
  1697     [","] = true
         }

         --(1) state machine
  1697   state = State.START

  5252   while state ~= State.END do
  3555     local ch = reader:next()

  3555     if state == State.START then
  1697       if SYMBOLS[ch.char] then
  1695         ln, col, sym = ch.line, ch.col, ch.char
  1695         state = State.MIDDLE
             else
     2         reader:unshift()
     2         state = State.END
             end
           else
  1858       if SYMBOLS[sym .. ch.char] then
   163         sym = sym .. ch.char
             else
  1695         reader:unshift()
  1695         state = State.END
             end
           end
         end

         --(2) return
  1697   if sym == nil then
     2     error(string.format("invalid symbol on (%s, %s).", reader._.line, reader._.col - 1))
         end

  1695   return Symbol.new(ln, col, sym)
       end

       --Scan a literal hnumber.
       --
       --@return Literal
     1 function Lexer:_scanLiteralNumber()
   478   local reader = self._.reader
         local state, ln, col, lit
   478   local State = {
   478     START = 1,
   478     INT = 2,
   478     DOT = 3,
   478     DECIMAL = 4,
   478     END = 5
         }

         --(1) state machine
   478   state = State.START

  1774   while state ~= State.END do
  1296     local ch = reader:next()

  1296     if state == State.START then
   478       ln, col, lit = ch.line, ch.col, ch.char
   478       state = State.INT
   818     elseif state == State.INT then
   808       ch = ch.char

   808       if stringx.isdigit(ch) then
   256         lit = lit .. ch
   552       elseif ch == " " then
    74         lit = lit --nothing to do
   478       elseif ch == "." then
     4         state = State.DOT
             else
   474         reader:unshift()
   474         state = State.END
             end
    10     elseif state == State.DOT then
     4       ch = ch.char

     4       if stringx.isdigit(ch) then
     2         lit = lit .. "." .. ch
     2         state = State.DECIMAL
             else
     2         reader:unshift() --current
     2         reader:unshift() --dot
     2         state = State.END
             end
           else  --DECIMAL
     6       ch = ch.char

     6       if stringx.isdigit(ch) then
     4         lit = lit .. ch
             else
     2         reader:unshift()
     2         state = State.END
             end
           end
         end

         --(2) return
   478   return Literal.new(ln, col, LiteralType.NUMBER, tonumber(lit))
       end

       --Scan a literal string.
       --
       --@return Literal
     1 function Lexer:_scanLiteralString()
    87   local reader = self._.reader
         local state, ln, col, lit
    87   local State = {
    87     START = 1,
    87     START1 = 2,
    87     START2 = 3,
    87     TEXT1 = 4,
    87     TEXT3 = 5,
    87     END1 = 6,
    87     END2 = 7,
    87     END = 8
         }

         --(1) state machine
    87   state = State.START

   785   while state ~= State.END do
   703     local ch = reader:next()

   703     if state == State.START then
    87       ln, col, lit = ch.line, ch.col, ""
    87       state = State.START1
   616     elseif state == State.START1 then
    87       ch = ch.char

    87       if ch == '"' then
     5         state = State.START2
             else
    82         lit = lit .. ch
    82         state = State.TEXT1
             end
   529     elseif state == State.START2 then
     5       ch = ch.char

     5       if ch == '"' then
     4         state = State.TEXT3
             else
     1         reader:unshift()
     1         state = State.END
             end
   524     elseif state == State.TEXT1 then  --"literal"
   496       if ch == nil then
     2         error(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

   494       ch = ch.char

   494       if ch == '"' then
    80         state = State.END
             else
   414         lit = lit .. ch
             end
    28     elseif state == State.TEXT3 then  --"""literal"""
    22       if ch == nil then
     2         error(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

    20       ch = ch.char

    20       if ch == '"' then
     3         state = State.END1
             else
    17         lit = lit .. ch
             end
     6     elseif state == State.END1 then
     3       ch = ch.char

     3       if ch == '"' then
     2         state = State.END2
             else
     1         lit = lit .. '"' .. ch
     1         state = State.TEXT3
             end
           else  --State.END2
     3       if ch == nil then
     1         error(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

     2       ch = ch.char

     2       if ch == '"' then
     1         state = State.END
             else
     1         lit = lit .. '""' .. ch
             end
           end
         end

         --(2) return
    82   return Literal.new(ln, col, LiteralType.STRING, lit)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/LiteralType.lua
==============================================================================
     1 return {
     1   STRING = 1,
     1   NUMBER = 2
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/TokenType.lua
==============================================================================
     1 return {
     1   COMMENT = 1,
     1   EOL = 2,
     1   NAME = 3,
     1   KEYWORD = 4,
     1   LITERAL = 5,
     1   SYMBOL = 6,
     1   DIRECTIVE = 7,
     1   ANNOTATION = 8
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/AdvancedList.lua
==============================================================================
     1 local AdvancedList = {}
     1 AdvancedList.__index = AdvancedList
     1 package.loaded[...] = AdvancedList

     1 function AdvancedList.new(max)
         --(1) arguments
  1385   if max == nil then error("max expected.") end

         --(2) return
  2768   return setmetatable({
  1384     _ = {
  1384       max = max,
  1384       items = {}
  1384     }
  2768   }, AdvancedList)
       end

     1 function AdvancedList:__len()
 77666   return #self._.items
       end

     1 function AdvancedList:insert(item)
 13938   if #self == self._.max then
     1     error("list already full.")
         end

 13937   table.insert(self._.items, 1, item)
       end

     1 function AdvancedList:remove()
 12794   if #self == 0 then
     1     error("empty list, nothing to remove.")
         end

 12793   return table.remove(self._.items, 1)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Annotation.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --An annotation.
     1 local Annotation = {}
     1 Annotation.__index = Annotation
     1 setmetatable(Annotation, {__index = Token})
     1 package.loaded[...] = Annotation

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param val:string
     1 function Annotation.new(ln, col, val)
    14   return setmetatable(Token.new(TokenType.ANNOTATION, ln, col, val), Annotation)
       end

       --@override
     1 function Annotation:__tostring()
     7   return string.format("<annotation>%s</annotation>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Char.lua
==============================================================================
       --A character.
     1 local Char = {}
     1 Char.__index = Char
     1 package.loaded[...] = Char

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param ch:char    Character.
     1 function Char.new(ln, col, ch)
 23658   return setmetatable({
 11829     line = ln,
 11829     col = col,
 11829     char = ch
 23658   }, Char)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Comment.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A comment.
     1 local Comment = {}
     1 Comment.__index = Comment
     1 setmetatable(Comment, {__index = Token})
     1 package.loaded[...] = Comment

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param text:string  Comment text.
     1 function Comment.new(ln, col, text)
     5   return setmetatable(Token.new(TokenType.COMMENT, ln, col, text), Comment)
       end

       --@override
     1 function Comment:__tostring()
    20   return string.format("<comment>%s</comment>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Directive.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A comilation directive.
     1 local Directive = {}
     1 Directive.__index = Directive
     1 setmetatable(Directive, {__index = Token})
     1 package.loaded[...] = Directive

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param val:string
     1 function Directive.new(ln, col, val)
    41   return setmetatable(Token.new(TokenType.DIRECTIVE, ln, col, val), Directive)
       end

       --@override
     1 function Directive:__tostring()
    35   return string.format("<directive>%s</directive>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Eol.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --An end of line.
     1 local Eol = {}
     1 Eol.__index = Eol
     1 setmetatable(Eol, {__index = Token})
     1 package.loaded[...] = Eol

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function Eol.new(ln, col)
   846   return setmetatable(Token.new(TokenType.EOL, ln, col, "\n"), Eol)
       end

     1 function Eol:__tostring()
    91   return "<eol/>"
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Id.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")

       --An identifier.
     1 local Id = {}
     1 Id.__index = Id
     1 setmetatable(Id, {__index = Token})
     1 package.loaded[...] = Id

       --Constructor.
       --
       --@param t:string   Token type.
       --@param ln:number  Line number.
       --@param col:number Column number
       --@param id:string  Identifier.
     1 function Id.new(t, ln, col, id)
  1913   return setmetatable(Token.new(t, ln, col, id), Id)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Keyword.lua
==============================================================================
       --imports
     1 local Id = require("dogma.lex._.Id")
     1 local TokenType = require("dogma.lex.TokenType")

       --A keyword.
     1 local Keyword = {}
     1 Keyword.__index = Keyword
     1 setmetatable(Keyword, {__index = Id})
     1 package.loaded[...] = Keyword

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param id:string  Identifier.
     1 function Keyword.new(ln, col, id)
   656   return setmetatable(Id.new(TokenType.KEYWORD, ln, col, id), Keyword)
       end

       --Check whether an identifier is a keyword.
       --
       --@param id:string  Identifier to check.
       --@return bool
     1 function Keyword.isKeyword(id)
  1773   local KEYWORDS = {
  1773     ["and"] = true,
  1773     ["as"] = true,
  1773     ["async"] = true,
  1773     ["await"] = true,
  1773     ["break"] = true,
  1773     ["catch"] = true,
  1773     ["const"] = true,
  1773     ["do"] = true,
  1773     ["dogma"] = true,
  1773     ["each"] = true,
  1773     ["else"] = true,
  1773     ["end"] = true,
  1773     ["enum"] = true,
  1773     ["export"] = true,
  1773     ["extern"] = true,
  1773     ["false"] = true,
  1773     ["finally"] = true,
  1773     ["fn"] = true,
  1773     ["for"] = true,
  1773     ["from"] = true,
  1773     ["if"] = true,
  1773     ["impl"] = true,
  1773     ["in"] = true,
  1773     ["is"] = true,
  1773     ["like"] = true,
  1773     ["native"] = true,
  1773     ["next"] = true,
  1773     ["nil"] = true,
  1773     ["nop"] = true,
  1773     ["not"] = true,
  1773     ["op"] = true,
  1773     ["or"] = true,
  1773     ["peval"] = true,
  1773     ["pub"] = true,
  1773     ["pvt"] = true, --private
  1773     ["return"] = true,
  1773     ["self"] = true,
  1773     ["Self"] = true,
  1773     ["super"] = true,
  1773     ["then"] = true,
  1773     ["throw"] = true,
  1773     ["true"] = true,
  1773     ["type"] = true,
  1773     ["use"] = true,
  1773     ["var"] = true,
  1773     ["while"] = true,
  1773     ["with"] = true,
  1773     ["yield"] = true
         }

  1773   return KEYWORDS[id] or false
       end

       --@override
     1 function Keyword:__tostring()
    10   return string.format("<keyword>%s</keyword>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Literal.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A literal.
     1 local Literal = {}
     1 Literal.__index = Literal
     1 setmetatable(Literal, {__index = Token})
     1 package.loaded[...] = Literal

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param t:string     Literal type: number, string...
       --@param val:any      Literal value.
     1 function Literal.new(ln, col, t, val)
         local self

         --(1) create
   560   self = setmetatable(Token.new(TokenType.LITERAL, ln, col, val), Literal)
   560   self.subtype = t

         --(2) return
   560   return self
       end

       --@override
     1 function Literal:__tostring()
   156   return string.format("<literal type='%s'>%s</literal>", self.type, self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Name.lua
==============================================================================
       --imports
     1 local Id = require("dogma.lex._.Id")
     1 local TokenType = require("dogma.lex.TokenType")

       --An identifier.
     1 local Name = {}
     1 Name.__index = Id
     1 setmetatable(Name, {__index = Id})
     1 package.loaded[...] = Name

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number
       --@param id:string  Identifier.
     1 function Name.new(ln, col, id)
  1257   return setmetatable(Id.new(TokenType.NAME, ln, col, id), Id)
       end

       --@override
     1 function Id:__tostring()
   112   return string.format("<name>%s</name>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/ProcessedList.lua
==============================================================================
     1 local List = {}
     1 List.__index = List
     1 package.loaded[...] = List

     1 function List.new(max)
         --(1) arguments
  1385   if max == nil then error("max expected.") end

         --(2) return
  2768   return setmetatable({
  1384     _ = {
  1384       max = max,
  1384       items = {}
  1384     }
  2768   }, List)
       end

     1 function List:__len()
 55566   return #self._.items
       end

     1 function List:insert(item)
 28216   if #self == self._.max then
 12642     table.remove(self._.items, 1)
         end

 28216   table.insert(self._.items, item)
       end

     1 function List:remove()
 12508   if #self == 0 then
     1     error("internal error: invalid remove from previous list.")
         end

 12507   return table.remove(self._.items)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Reader.lua
==============================================================================
       --imports
     1 local stringx = require("pl.stringx")
     1 local Char = require("dogma.lex._.Char")
     1 local ProcessedList = require("dogma.lex._.ProcessedList")
     1 local AdvancedList = require("dogma.lex._.AdvancedList")

       --A text reader.
     1 local Reader = {}
     1 Reader.__index = Reader
     1 package.loaded[...] = Reader

       --Constructor.
     1 function Reader.new(txt)
  1394   return setmetatable({
   697     _ = {
   697       text = stringx.split(txt, "\n"),
   697       line = 1,
   697       col = 1,
   697       processed = ProcessedList.new(3),
   697       char = nil,
   697       advanced = AdvancedList.new(3),
   697     }
  1394   }, Reader)
       end

       --Check whether the lexer has some char to shift.
       --
       --@return bool
     1 function Reader:_hasCharToShift()
 21922   return #self._.advanced > 0
       end

       --Read the next character.
       --
       --@return Char
     1 function Reader:next()
         --(1) read
 21922   if self:_hasCharToShift() then
  9173     self:_shift()
         else
 12749     local ln = self._.text[self._.line]

 12749     if ln then
 11829       if self._.col > #ln then
   928         self:_backUp()
   928         self._.char = Char.new(self._.line, self._.col, "\n")
   928         self._.line = self._.line + 1
   928         self._.col = 1
             else
 10901         self:_backUp()
 10901         self._.char = Char.new(self._.line, self._.col, ln:sub(self._.col, self._.col))
 10901         self._.col = self._.col + 1
             end
           else  --end of input
   920       self:_backUp()
   920       self._.char = nil
           end
         end

         --(2) return
 21922   return self._.char
       end

       --Shift a char: <- processed <- current <- advanced
     1 function Reader:_shift()
         --(1) pre
  9177   if #self._.advanced == 0 then
     1     error("no advanced char to shift.")
         end

         --(2) current to processed
  9176   if self._.char then
  8474     self._.processed:insert(self._.char)
         end

         --(3) advanced to current
  9176   self._.char = self._.advanced:remove()
       end

       --Unshift a char: processed -> current -> advanced
     1 function Reader:unshift()
         --(1) current to advanced
  9293   if self._.char then
  9288     self._.advanced:insert(self._.char)
         end

         --(2) last processed to current
  9293   if #self._.processed == 0 then
   706     self._.char = nil
         else
  8587     self._.char = self._.processed:remove()
         end
       end

       --Shift current char to processed chars: processed <- char.
     1 function Reader:_backUp()
 12749   if self._.char then
 11527     self._.processed:insert(self._.char)
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Symbol.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A symbol.
     1 local Symbol = {}
     1 Symbol.__index = Symbol
     1 setmetatable(Symbol, {__index = Token})
     1 package.loaded[...] = Symbol

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param sym:string   Symbol.
     1 function Symbol.new(ln, col, sym)
  1695   return setmetatable(Token.new(TokenType.SYMBOL, ln, col, sym), Symbol)
       end

       --@override
     1 function Symbol:__tostring()
   509   return string.format("<symbol>%s</symbol>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Token.lua
==============================================================================
       --A token.
     1 local Token = {}
     1 Token.__index = Token
     1 package.loaded[...] = Token

       --Constructor.
       --
       --@param t:TokenType  Token type.
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param val:any      Value.
     1 function Token.new(t, ln, col, val)
 10148   return setmetatable({
  5074     type = t,
  5074     line = ln,
  5074     col = col,
  5074     value = val
 10148   }, Token)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveParser.lua
==============================================================================
       --imports
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local IfDirective = require("dogma.syn._.IfDirective")
     1 local RunWithDirective = require("dogma.syn._.RunWithDirective")

       --A directive parser.
     1 local DirectiveParser = {}
     1 DirectiveParser.__index = DirectiveParser
     1 setmetatable(DirectiveParser, {__index = SubParser})
     1 package.loaded[...] = DirectiveParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function DirectiveParser.new(parser)
   570   return setmetatable(SubParser.new(parser), DirectiveParser)
       end

       --Read the next if directive.
       --
       --@return Directive
     1 function DirectiveParser:nextIf()
    14   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, el

         --(1) read if
    14   tok = lex:next(TokenType.DIRECTIVE)
    14   ln, col = tok.line, tok.col

    14   if tok.value:find("^if [a-zA-Z_0-9]+ then$") then
     9     cond = tok.value:match("^if ([a-zA-Z_0-9]+) then$")
         else
     5     cond = tok.value:match("^if (not [a-zA-Z_0-9]+) then$")
         end

    14   body = {}
         while true do
    55     tok = lex:advance()

    55     if tok == nil then
             break
    54     elseif tok.type == TokenType.EOL then
    21       lex:next()
           else
    33       if tok.type == TokenType.DIRECTIVE then
    13         if tok.value == "else" or tok.value == "end" then
                 break
               else
     1           error(string.format("on (%s,%s), if directive can't be nested.", tok.line, tok.col))
               end
             end

    20       table.insert(body, parser:next())
           end
         end

         --(2) read else
    13   tok = lex:advance()

    13   if tok and tok.type == TokenType.DIRECTIVE and tok.value == "else" then
     6     lex:next()

     6     el = {}
           while true do
    18       tok = lex:advance()

    18       if tok.type == TokenType.EOL then
     6         lex:next()
             else
    12         if tok.type == TokenType.DIRECTIVE then
     6           if tok.value == "end" then
                   break
                 else
     1             error(string.format("on (%s,%s), else directive can't be nested.", tok.line, tok.col))
                 end
               end

     6         table.insert(el, parser:next())
             end
           end
         end

         --(3) read end
    12   lex:next(TokenType.DIRECTIVE, "end")

         --(4) return
    11   return IfDirective.new(ln, col, cond, body, el)
       end

       --Read the next #!/... directive.
       --
       --@return RunWithDirective
     1 function DirectiveParser:nextRunWith()
     3   local lex = self._.lexer
         local tok

     3   tok = lex:next(TokenType.DIRECTIVE)
     3   return RunWithDirective.new(tok.line, tok.col, tok.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveType.lua
==============================================================================
     1 return {
     1   IF = "if",
     1   RUNWITH = "runWith"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/ExpParser.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local Keyword = require("dogma.lex._.Keyword")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local SubExp = require("dogma.syn._.SubExp")
     1 local IfSubExp = require("dogma.syn._.IfSubExp")
     1 local UnaryOp = require("dogma.syn._.UnaryOp")
     1 local BinOp = require("dogma.syn._.BinOp")
     1 local SliceOp = require("dogma.syn._.SliceOp")
     1 local CallOp = require("dogma.syn._.CallOp")
     1 local Exp = require("dogma.syn._.Exp")
     1 local LiteralList = require("dogma.syn._.LiteralList")
     1 local LiteralMap = require("dogma.syn._.LiteralMap")
     1 local LiteralFn = require("dogma.syn._.LiteralFn")
     1 local PevalFn = require("dogma.syn._.PevalFn")
     1 local NativeFn = require("dogma.syn._.NativeFn")
     1 local ThrowFn = require("dogma.syn._.ThrowFn")
     1 local ReturnStmt = require("dogma.syn._.ReturnStmt")
     1 local PackOp = require("dogma.syn._.PackOp")

       --An expression parser.
     1 local ExpParser = {}
     1 ExpParser.__index = ExpParser
     1 setmetatable(ExpParser, {__index = SubParser})
     1 package.loaded[...] = ExpParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function ExpParser.new(parser)
         local self

         --(1) create
   570   self = setmetatable(SubParser.new(parser), ExpParser)
   570   self._.stmtParser = parser._.stmtParser

         --(2) return
   570   return self
       end

       --Read an expression.
       --
       --@return Exp
     1 function ExpParser:next()
   630   return self:_readExp()
       end

     1 function ExpParser:_readExp()
   808   local lex = self._.lexer
         local tok, node, exp

         --(1) init expression
   808   tok = lex:advance()
   808   exp = Exp.new(tok.line, tok.col)

         --(2) read
         while true do
  2618     tok = lex:next()

  2618     if tok == nil then
     3       if exp.tree:isWellFormed() then
               break
             else
     6         error(string.format(
     3           "incomplete expression started on (%s, %s).",
     3           exp.line,
                 exp.col
     3         ))
             end
           end

  2615     if tok.type == TokenType.EOL then
   520       if exp.tree:isWellFormed() then
   515         lex:unshift()
               break
             end
  2095     elseif tok.type == TokenType.SYMBOL and tok.value == "(" then
   113       lex:unshift()

   113       if exp.tree:isWellFormed() then
   101         self:_readCallArgs(exp)
             else
    12         exp:insert(self:_readSubExp())
             end
  1982     elseif tok.type == TokenType.SYMBOL and tok.value == "[" then
    26       lex:unshift()

    26       if exp.tree:isWellFormed() then
    15         self:_readIndexOp(exp)
             else
    11         exp:insert(self:_readLiteralList())
             end
  1956     elseif tok.type == TokenType.SYMBOL and tok.value == "{" then
    25       lex:unshift()
    25       if exp.tree:isWellFormed() then
    12         self:_readPackOp(exp)
             else
    13         exp:insert(self:_readLiteralMap())
             end
  1931     elseif tok.type == TokenType.KEYWORD and tok.value == "fn" then
    11       lex:unshift()
    11       exp:insert(self:_readFn())
  1920     elseif tok.type == TokenType.KEYWORD and tok.value == "if" then
     5       lex:unshift()
     5       exp:insert(self:_readIfSubExp())
  1915     elseif tok.type == TokenType.KEYWORD and tok.value == "native" then
     3       lex:unshift()
     3       exp:insert(self:_readNative())
  1912     elseif tok.type == TokenType.KEYWORD and tok.value == "peval" then
     4       lex:unshift()
     4       exp:insert(self:_readPeval())
  1908     elseif tok.type == TokenType.KEYWORD and tok.value == "throw" then
     6       lex:unshift()
     6       exp:insert(self:_readThrow())
           else
  1902       if tok.type == TokenType.KEYWORD and tok.value == "not" then
     8         local aux = lex:advance()

     8         if aux.type == TokenType.KEYWORD and aux.value == "in" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "notin"))
     6         elseif aux.type == TokenType.KEYWORD and aux.value == "like" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "notlike"))
               else
     4           node = UnaryOp.new(tok)
               end
  1894       elseif tok.type == TokenType.KEYWORD and tok.value == "is" then
     4         local aux = lex:advance()

     4         if aux.type == TokenType.KEYWORD and aux.value == "not" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "isnot"))
               else
     2           node = self:_getNodeOf(tok)
               end
  1890       elseif tok.type == TokenType.SYMBOL and (tok.value == "+" or tok.value == "-") then
   254         if exp.tree:isWellFormed() then
   246           node = BinOp.new(tok)
               else
     8           node = UnaryOp.new(tok)
               end
  1636       elseif tok.type == TokenType.SYMBOL and tok.value == ":" then
    15         if exp.tree:isWellFormed() then
     9           node = BinOp.new(tok)
               else
     6           node = UnaryOp.new(tok)
               end
  1621       elseif tok.type == TokenType.SYMBOL and tok.value == "." then
    26         if exp.tree:isWellFormed() then
    17           node = BinOp.new(tok)
               else
     9           node = UnaryOp.new(tok)
               end
             else
  1595         node = self:_getNodeOf(tok)
             end

  1902       if node == nil then
   275         if exp.tree:isWellFormed() then
   274           lex:unshift()
                 break
               else
     2           error(string.format(
     1             "invalid expression node on (%s, %s).",
     1             tok.line,
                   tok.col
     1           ))
               end
             else
  1627         exp:insert(node)
             end
           end
         end

         --(3) return
   789   return exp
       end

       --Return a node for a given token.
       --
       --@param tok:Token  The token.
       --@return Node
     1 function ExpParser:_getNodeOf(tok)
         local node

         --(1) create node
  1597   if tok.type == TokenType.NAME then
   666     node = Terminal.new(TerminalType.NAME, tok)
   931   elseif tok.type == TokenType.LITERAL then
   469     if type(tok.value) == "string" then
    34       node = Terminal.new(TerminalType.TEXT, tok)
   435     elseif type(tok.value) == "number" then
   435       node = Terminal.new(TerminalType.NUM, tok)
           end
   462   elseif tok.type == TokenType.KEYWORD then
   131     local kw = tok.value

   131     if kw == "nop" then
     2       node = Terminal.new(TerminalType.NOP, tok)
   129     elseif kw == "false" then
     2       node = Terminal.new(TerminalType.FALSE, tok)
   127     elseif kw == "nil" then
     1       node = Terminal.new(TerminalType.NIL, tok)
   126     elseif kw == "self" then
     2       node = Terminal.new(TerminalType.SELF, tok)
   124     elseif kw == "super" then
     1       node = Terminal.new(TerminalType.SUPER, tok)
   123     elseif kw == "true" then
    25       node = Terminal.new(TerminalType.TRUE, tok)
    98     elseif tablex.find({"and", "in", "is", "like", "or"}, kw) then
    10       node = BinOp.new(tok)
           end
   331   elseif tok.type == TokenType.SYMBOL then
   331     local sym = tok.value

   331     if tablex.find({"!", "~", "..."}, sym) then
     5       node = UnaryOp.new(tok)
   652     elseif tablex.find({
   326                           "+=", "-=", "*", "*=", "**", "**=", "/", "/=", "%", "%=",
   326                           "=", ".=", ":=", "?=", "==", "===", "=~", "!=", "!==", "!~",
   326                           "<", "<<", "<<=", "<=", ">", ">>", ">>=", ">=",
   326                           "^", "^=", ".", ":", "&", "&=", "&&", "|", "|=", "||"
   652                        }, sym) then
   139       node = BinOp.new(tok)
           end
         end

         --(2) return
  1597   return node
       end

       --Read (expr).
       --
       --@return Exp
     1 function ExpParser:_readSubExp()
    12   local lex = self._.lexer
         local term, tok, ln, col

         --(1) read
    12   tok = lex:next(TokenType.SYMBOL, "(")
    12   ln, col = tok.line, tok.col
    12   term = SubExp.new(ln, col, self:_readExp())
    11   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     9   return term
       end

       --Read if then else end.
       --
       --@return IfSubExp
     1 function ExpParser:_readIfSubExp()
     5   local lex = self._.lexer
         local tok, ln, col, cond, tcase, fcase

         --(1) read
     5   tok = lex:next(TokenType.KEYWORD, "if")
     5   ln, col = tok.line, tok.col
     5   cond = self:_readExp()
     5   lex:next(TokenType.KEYWORD, "then")
     4   tcase = self:_readExp()
     4   lex:next(TokenType.KEYWORD, "else")
     4   fcase = self:_readExp()
     4   lex:next(TokenType.KEYWORD, "end")

         --(2) return
     3   return IfSubExp.new(ln, col, cond, tcase, fcase)
       end

       --Read a native(code) terminal.
       --
       --@return NativeFn
     1 function ExpParser:_readNative()
     3   local lex = self._.lexer
         local tok, ln, col, code

         --(1) read
     3   tok = lex:next(TokenType.KEYWORD, "native")
     3   ln, col = tok.line, tok.col
     3   lex:next(TokenType.SYMBOL, "(")
     3   code = lex:next(TokenType.LITERAL).value
     2   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return NativeFn.new(ln, col, code)
       end

       --Read a peval(Exp) terminal.
       --
       --@return PevalFn
     1 function ExpParser:_readPeval()
     4   local lex = self._.lexer
         local tok, ln, col, exp

         --(1) read
     4   tok = lex:next(TokenType.KEYWORD, "peval")
     4   ln, col = tok.line, tok.col
     4   lex:next(TokenType.SYMBOL, "(")
     4   exp = self:_readExp()
     3   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return PevalFn.new(ln, col, exp)
       end

       --Read a throw(Exp [, Exp]) terminal.
       --
       --@return ThrowFn
     1 function ExpParser:_readThrow()
     6   local lex = self._.lexer
         local tok, ln, col, args

         --(1) read
     6   tok = lex:next(TokenType.KEYWORD, "throw")
     6   ln, col = tok.line, tok.col
     6   lex:next(TokenType.SYMBOL, "(")

     6   args = {}
         while true do
    12     table.insert(args, self:_readExp())

    12     tok = lex:advance()
    12     if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
             break
           end

     6     lex:next(TokenType.SYMBOL, ",")
         end

     6   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     6   return ThrowFn.new(ln, col, args)
       end

       --Read a call arguments.
       --
       --@param exp:Exp  Current expression.
     1 function ExpParser:_readCallArgs(exp)
   101   local lex = self._.lexer
         local tok, call

         --(1) pre: read (
   101   tok = lex:next(TokenType.SYMBOL, "(")
   101   tok.value = "()"

         --(2) create operator
   101   call = CallOp.new(tok)
   101   exp:insert(call)

         --(3) read arguments
   101   tok = lex:advance()

   101   if tok.type == TokenType.SYMBOL and tok.value == ")" then
    19     lex:next()
    19     call.finished = true
         else
    82     local sep = ","

    82     if tok.type == TokenType.EOL then
     5       lex:next()
     5       sep = "\n"
           end

           while true do
    87       call:insert(self:_readExp())

    87       tok = lex:next()

    87       if tok.type == TokenType.SYMBOL and tok.value == ")" then
    78         call.finished = true
               break
             end

     9       if sep == "," then
     4         if tok.type ~= TokenType.SYMBOL and tok.value ~= "," then
     2           error(string.format(
     1             "on (%s, %s), comma expected for argument end or ) for call end.",
     1             tok.line,
                   tok.col
     1           ))
               end
     5       elseif sep == "\n" then
     5         if tok.type ~= TokenType.EOL then
     2           error(string.format(
     1             "on (%s, %s), end of line expected for argument end.",
     1             tok.line,
                   tok.col
     1           ))
               end

     4         tok = lex:advance()

     4         if tok.type == TokenType.SYMBOL and tok.value == ")" then
     2           lex:next()
     2           call.finished = true
                 break
               end
             end
           end
         end
       end

       --Read a literal list: [...].
       --
       --@return LiteralList
     1 function ExpParser:_readLiteralList()
    11   local lex = self._.lexer
         local tok, ln, col, items

         --(1) read [
    11   tok = lex:next(TokenType.SYMBOL, "[")
    11   ln, col = tok.line, tok.col

         --(2) read items]
    11   items = {}

    11   tok = lex:advance()
    11   if not (tok.type == TokenType.SYMBOL and tok.value == ']') then
           local sep

     9     if tok.type == TokenType.EOL then
     3       lex:next()
     3       sep = "\n"
           else
     6       sep = ","
           end

           while true do
    18       table.insert(items, self:_readExp())

    18       if sep == "," then
    12         tok = lex:advance()

    12         if tok.type == TokenType.SYMBOL and tok.value == "," then
     6           lex:next()
               else
                 break
               end
             else
     6         lex:next(TokenType.EOL)

     6         tok = lex:advance()
     6         if tok.type == TokenType.SYMBOL and tok.value == "]" then
                 break
               end
             end
           end
         end

    11   lex:next(TokenType.SYMBOL, "]")

         --(4) return
    11   return LiteralList.new(ln, col, items)
       end

       --Read a literal map: {...}.
       --
       --@return LiteralMap
     1 function ExpParser:_readLiteralMap()
    13   local lex = self._.lexer
         local tok, ln, col, entries

         --(1) read {
    13   tok = lex:next(TokenType.SYMBOL, "{")
    13   ln, col = tok.line, tok.col

         --(2) read entries}
    13   entries = {}

    13   tok = lex:advance()
    13   if not (tok.type == TokenType.SYMBOL and tok.value == '}') then
           local sep

    11     if tok.type == TokenType.EOL then
     4       lex:next()
     4       sep = "\n"
           else
     7       sep = ","
           end

           while true do
             local name, val, brackets

             --skip ends of line
    20       if sep == "\n" then
     8         self:_nextEols()
             end

             --read item
    20       tok = lex:advance()

    20       if tok.type == TokenType.SYMBOL and tok.value == "{" then
     2         lex:next(TokenType.SYMBOL, "{")
     2         name = lex:next(TokenType.NAME).value
     2         brackets = true
     2         lex:next(TokenType.SYMBOL, "}")
             else
    18         name = lex:next(TokenType.NAME).value
    18         brackets = false
             end

    20       tok = lex:advance()
    20       if tok.type == TokenType.SYMBOL and tok.value == "=" then
    18         lex:next(TokenType.SYMBOL, "=")
    18         val = self:_readExp()
    18         if brackets then
     2           local op = BinOp.new({line = tok.line, col = tok.col, value = "."})
     2           val:insert(op)
     2           op:insert(Terminal.new(TerminalType.NAME, {line = tok.line, col = tok.col, value = name}))
               end
             else
     2         val = Exp.new(tok.line, tok.col)
     2         val:insert(Terminal.new(TerminalType.NAME, {line = tok.line, col = tok.col, value = name}))
             end

    20       table.insert(entries, {name = name, value = val})

             --read sep
    20       if sep == "," then
    12         tok = lex:advance()

    12         if tok.type == TokenType.SYMBOL and tok.value == "," then
     5           lex:next()
               else
                 break
               end
             else
     8         self:_nextEols()

     8         tok = lex:advance()
     8         if tok.type == TokenType.SYMBOL and tok.value == "}" then
                 break
               end
             end
           end
         end

    13   lex:next(TokenType.SYMBOL, "}")

         --(4) return
    13   return LiteralMap.new(ln, col, entries)
       end

       --Read a fn.
       --
       --@return LiteralFn
     1 function ExpParser:_readFn()
    11   local lex, stmt = self._.lexer, self._.stmtParser
         local tok, ln, col, params, rtype, rvar, body

         --(1) read
    11   tok = lex:next(TokenType.KEYWORD, "fn")
    11   ln, col = tok.line, tok.col

    11   params = stmt:_readFnParams()
    11   rvar = stmt:_readFnReturnVar()
    11   rtype = stmt:_readFnType()

    11   tok = lex:advance()
    11   if tok.type == TokenType.SYMBOL and tok.value == "=" then
     2     lex:next()
     2     body = self:_readExp()
     2     body = {ReturnStmt.new(body.ln, body.col, body)}
     2     lex:next(TokenType.KEYWORD, "end")
         else
     9     body = stmt:_readBody(3)
         end

         --(2) return
    11   return LiteralFn.new(ln, col, params, rtype, rvar, body)
       end

       --Read an indexing operator.
       --
       --@param exp:Exp  Expression to update.
     1 function ExpParser:_readIndexOp(exp)
    15   local lex = self._.lexer
         local tok, ln, col, init, fin

         --(1) read [Exp
    15   tok = lex:next(TokenType.SYMBOL, "[")
    15   ln, col = tok.line, tok.col
    15   init = self:next()

         --(2) read "", Exp" if existing
    15   tok = lex:advance()

    15   if tok.type == TokenType.SYMBOL and tok.value == "," then
     5     lex:next()
     5     fin = self:next()
         end

         --(3) read ]
    15   lex:next(TokenType.SYMBOL, "]")

         --(4) add
         local op

    15   if fin == nil then
    10     op = BinOp.new({line = ln, col = col, value = "[]"})
    10     exp:insert(op)
    10     op:insert(init.tree.root)
         else
     5     op = SliceOp.new({line = ln, col = col, value = "[]"})
     5     exp:insert(op)
     5     op:insert(init.tree.root)
     5     op:insert(fin.tree.root)
         end
       end

       --Read the next {name,name...} op.
       --
       --@param exp:Exp  Expression to update.
     1 function ExpParser:_readPackOp(exp)
    12   local lex = self._.lexer
         local tok, op

         --(1) read {
    12   tok = lex:next(TokenType.SYMBOL, "{")

         --(2) create op
    12   tok.value = "{}"
    12   op = PackOp.new(tok)
    12   exp:insert(op)

         --(3) read fields
    12   tok = lex:advance()
    12   if not (tok.type == TokenType.SYMBOL and tok.value == "}") then
           while true do
             local visib, name

             --name, .name or :name
    15       tok = lex:advance()

    15       if tok.type == TokenType.SYMBOL and tok.value == "*" then
     4         if #op.children > 1 then
     1           error(string.format("on (%s,%s), '*' only allowed when '{*}'.", tok.line, tok.col))
               end

     3         lex:next()
     3         visib = "."
     3         name = "*"
    11       elseif tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
     6         lex:next()
     6         visib = tok.value
     6         name = ""
             else
     5         visib = "."
     5         name = ""
             end

    14       if name ~= "*" then
    11         name = lex:next(TokenType.NAME).value
             end

    14       table.insert(op.children, {visib = visib, name = name})

             --end?
    14       if name == "*" then
               break
             else
    11         tok = lex:advance()

    11         if tok.type == TokenType.SYMBOL and tok.value == "}" then
                 break
               end

     5         lex:next(TokenType.SYMBOL, ",")
             end
           end
         end

         --(4) read }
    11   lex:next(TokenType.SYMBOL, "}")
    10   op.finished = true
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/NodeType.lua
==============================================================================
     1 return {
     1   TERMINAL = "terminal",
     1   NON_TERMINAL = "non-terminal"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/NonTerminalType.lua
==============================================================================
     1 return {
     1   OP = 1,
     1   TREE = 2
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/Parser.lua
==============================================================================
       --imports
     1 local Lexer = require("dogma.lex.Lexer")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local DirectiveParser = require("dogma.syn.DirectiveParser")
     1 local ExpParser = require("dogma.syn.ExpParser")
     1 local StmtParser = require("dogma.syn.StmtParser")
     1 local UnpackParser = require("dogma.syn.UnpackParser")

       --A parser.
     1 local Parser = {}
     1 Parser.__index = Parser
     1 package.loaded[...] = Parser

       --Constructor.
     1 function Parser.new()
         local self

         --(1) create
   570   self = setmetatable({_ = {}}, Parser)
   570   self._.lexer = Lexer.new()
   570   self._.directiveParser = DirectiveParser.new(self)
   570   self._.expParser = ExpParser.new(self)
   570   self._.stmtParser = StmtParser.new(self)
   570   self._.unpackParser = UnpackParser.new(self)
   570   self._.expParser._.stmtParser = self._.stmtParser

         --(2) return
   570   return self
       end

       --Parse a given text.
       --
       --@param txt:string   Text to parse.
       --@param file?:string File name..
     1 function Parser:parse(txt, file)
   570   self._.lexer:scan(txt, file)
       end

       --Parse the next sentence.
       --
       --@return Sentence
     1 function Parser:next()
   999   local lex, stmter, unpacker, direr = self._.lexer, self._.stmtParser, self._.unpackParser, self._.directiveParser
         local sent, tok, annots

         --(1) remove white lines and read annotations
   999   annots = {}
   999   tok = lex:advance()
         while true do
  1176     if tok == nil then
             break
   901     elseif tok.type == TokenType.EOL then
   164       lex:next()
   737     elseif tok.type == TokenType.ANNOTATION then
    13       lex:next()
    13       table.insert(annots, tok.value)
           else
             break
           end

   177     tok = lex:advance()
         end

          --(2) parse next sentence
   999   tok = lex:advance()

   999   if tok ~= nil then
   724     if tok.type == TokenType.DIRECTIVE then
    17       if tok.value:find("^if") then
    14         sent = direr:nextIf()
     3       elseif tok.value:find("^/") then
     3         sent = direr:nextRunWith()
             end
   707     elseif tok.type == TokenType.KEYWORD then
   329       if tok.value == "async" then
     8         sent = stmter:nextAsync()
   321       elseif tok.value == "break" then
     3         sent = stmter:nextBreak()
   318       elseif tok.value == "const" then
    14         tok = lex:advance(2)

    14         if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     3           sent = self._.unpackParser:next()
               else
    11           sent = stmter:nextConst()
               end
   304       elseif tok.value == "do" then
    11         sent = stmter:nextDo()
   293       elseif tok.value == "enum" then
    22         sent = stmter:nextEnum(annots)
   271       elseif tok.value == "export" or tok.value == "pub" or tok.value == "pvt" then
    49         local toParse = tok.value

    49         tok = lex:advance(2)

    49         if tok.type == TokenType.KEYWORD then
    36           if tok.value == "const" then
    10             tok = lex:advance(3)

    10             if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     6               sent = unpacker:next()
                   else
     4               sent = stmter:nextConst()
                   end
    26           elseif tok.value == "enum" then
     7             sent = stmter:nextEnum(annots)
    19           elseif tok.value == "fn" then
     5             sent = stmter:nextFn(annots)
    14           elseif tok.value == "type" then
     3             sent = stmter:nextType(annots)
    11           elseif tok.value == "var" then
    11             tok = lex:advance(3)

    11             if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     7               sent = unpacker:next()
                   else
     4               sent = stmter:nextVar()
                   end
                 end
               end

    49         if not sent then
    13           if toParse == "pub" then
    10             sent = stmter:nextPub()
     3           elseif toParse == "export" then
     3             sent = stmter:nextExport()
                 end
               end
   222       elseif tok.value == "fn" then
    68         sent = stmter:nextFn(annots)
   154       elseif tok.value == "for" then
    22         tok = lex:advance(2)

    22         if tok.type == TokenType.KEYWORD and tok.value == "each" then
    10           sent = stmter:nextForEach()
               else
    12           sent = stmter:nextFor()
               end
   132       elseif tok.value == "from" then
     8         sent = stmter:nextFrom()
   124       elseif tok.value == "if" then
    14         sent = stmter:nextIf()
   110       elseif tok.value == "next" then
     3         sent = stmter:nextNext()
   107       elseif tok.value == "return" then
    10         sent = stmter:nextReturn()
    97       elseif tok.value == "type" then
    11         sent = stmter:nextType(annots)
    86       elseif tok.value == "use" then
    18         sent = stmter:nextUse()
    68       elseif tok.value == "var" then
    20         tok = lex:advance(2)

    20         if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     6           sent = self._.unpackParser:next()
               else
    14           sent = stmter:nextVar()
               end
    48       elseif tok.value == "while" then
    18         sent = stmter:nextWhile()
    30       elseif tok.value == "with" then
     8         sent = stmter:nextWith()
             end
           end

   702     if not sent and tok.type == TokenType.SYMBOL and (tok.value == "[" or tok.value == "{") then
    27       sent = self._.unpackParser:next()
           end

   698     if not sent then
   373       sent = self:nextExp()
           end
         end

         --(3) return
   965   return sent
       end

       --Read the next expression.
       --
       --@return Exp
     1 function Parser:nextExp()
   572   return self._.expParser:next()
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/SentType.lua
==============================================================================
     1 return {
     1   EXP = "exp",
     1   STMT = "stmt",
     1   UNPACK = "unpack",
     1   DIRECTIVE = "directive"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SentType = require("dogma.syn.SentType")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local BlockParser = require("dogma.syn._.BlockParser")
     1 local BreakStmt = require("dogma.syn._.BreakStmt")
     1 local ConstStmt = require("dogma.syn._.ConstStmt")
     1 local EnumStmt = require("dogma.syn._.EnumStmt")
     1 local NextStmt = require("dogma.syn._.NextStmt")
     1 local ReturnStmt = require("dogma.syn._.ReturnStmt")
     1 local UseStmt = require("dogma.syn._.UseStmt")
     1 local FromStmt = require("dogma.syn._.FromStmt")
     1 local VarStmt = require("dogma.syn._.VarStmt")
     1 local WhileStmt = require("dogma.syn._.WhileStmt")
     1 local DoStmt = require("dogma.syn._.DoStmt")
     1 local ForEachStmt = require("dogma.syn._.ForEachStmt")
     1 local ForStmt = require("dogma.syn._.ForStmt")
     1 local CatchCl = require("dogma.syn._.CatchCl")
     1 local FinallyCl = require("dogma.syn._.FinallyCl")
     1 local FnStmt = require("dogma.syn._.FnStmt")
     1 local TypeStmt = require("dogma.syn._.TypeStmt")
     1 local Param = require("dogma.syn._.Param")
     1 local Params = require("dogma.syn._.Params")
     1 local AsyncStmt = require("dogma.syn._.AsyncStmt")
     1 local IfStmt = require("dogma.syn._.IfStmt")
     1 local Exp = require("dogma.syn._.Exp")
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local PubStmt = require("dogma.syn._.PubStmt")
     1 local ExportStmt = require("dogma.syn._.ExportStmt")
     1 local WithStmt = require("dogma.syn._.WithStmt")

       --Parser for the Dogma statements.
     1 local StmtParser = {}
     1 StmtParser.__index = StmtParser
     1 setmetatable(StmtParser, {__index = SubParser})
     1 package.loaded[...] = StmtParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function StmtParser.new(parser)
         local self

         --(1) create
   570   self = setmetatable(SubParser.new(parser), StmtParser)
   570   self._.expParser = parser._.expParser

         --(2) return
   570   return self
       end

       --Read a const statement.
       --
       --@return ConstStmt
     1 function StmtParser:nextConst()
    15   local lexer, exper = self._.lexer, self._.expParser
         local tok, ln, col, visib, stmt, sep

         --(1) read visibility
    15   tok = lexer:advance()
    15   ln, col = tok.line, tok.col

    15   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     4     lexer:next()
     4     visib = tok.value
         end

         --(2) read
    15   lexer:next(TokenType.KEYWORD, "const")
    15   stmt = ConstStmt.new(ln, col, visib)

         --(3) get separator
    15   tok = lexer:advance()

    15   if tok.type == TokenType.EOL then
     5     sep = "\n"
     5     lexer:next()
         else
    10     sep = ","
         end

         --(4) get variables
         while true do
           local name, val

           --read name
    23     tok = lexer:advance()

    23     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

    18     name = lexer:next(TokenType.NAME).value

           --read value
    18     lexer:next(TokenType.SYMBOL, "=")
    17     val = exper:next()

           --insert variable
    17     stmt:insert(name, val)

           --read separator
    17     if sep == "\n" then
     5       lexer:next(TokenType.EOL)
           else  --using comma as separator
    12       tok = lexer:next()

    12       if tok.type == TokenType.EOL then
               break
             end

     4       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating variables.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(5) return
    13   return stmt
       end

       --Read a break statement.
       --
       --@return BreakStmt
     1 function StmtParser:nextBreak()
     3   local lexer = self._.lexer
         local tok, stmt

         --(1) read
     3   tok = lexer:next(TokenType.KEYWORD, "break")
     3   stmt = BreakStmt.new(tok.line, tok.col)

         --(2) get end of line
     3   lexer:next(TokenType.EOL)

         --(3) return
     2   return stmt
       end

       --Read a next statement.
       --
       --@return NextStmt
     1 function StmtParser:nextNext()
     3   local lexer = self._.lexer
         local tok, stmt

         --(1) read
     3   tok = lexer:next(TokenType.KEYWORD, "next")
     3   stmt = NextStmt.new(tok.line, tok.col)

         --(2) get end of line
     3   lexer:next(TokenType.EOL)

         --(3) return
     2   return stmt
       end

       --Read a return statement.
       --
       --@return ReturnStmt
     1 function StmtParser:nextReturn()
    10   local lex, exper = self._.lexer, self._.expParser
         local tok, stmt

         --(1) read
    10   tok = lex:next(TokenType.KEYWORD, "return")
    10   stmt = ReturnStmt.new(tok.line, tok.col)

         --(2) get values
    10   tok = lex:advance()

    10   if tok.type ~= TokenType.EOL then
     8     stmt:insert(exper:next())
         end

    10   lex:next(TokenType.EOL)

         --(3) return
    10   return stmt
       end

       --Read a use stament.
       --
       --@return UseStmt
     1 function StmtParser:nextUse()
    18   local lex = self._.lexer
         local tok, stmt, sep

         --(1) read
    18   tok = lex:next(TokenType.KEYWORD, "use")
    18   stmt = UseStmt.new(tok.line, tok.col)

         --(2) get separator
    18   tok = lex:advance()

    18   if tok.type == TokenType.EOL then
     5     sep = "\n"
     5     lex:next()
         else
    13     sep = ","
         end

         --(3) get variables
         while true do
           local path, name

    28     tok = lex:advance()

    28     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

           --path
    23     path = lex:next(TokenType.LITERAL).value

           --as
    23     tok = lex:advance()

    23     if tok.type == TokenType.KEYWORD and tok.value == "as" then
     9       lex:next()  --as
     9       name = lex:next(TokenType.NAME).value
           end

           --insert
    23     stmt:insert(path, name)

           --read separator
    22     if sep == "\n" then
     6       lex:next(TokenType.EOL)
           else  --using comma as separator
    16       tok = lex:next()

    16       if tok.type == TokenType.EOL then
               break
             end

     5       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating modules.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(4) return
    16   return stmt
       end

       --Read a from statement.
       --
       --@return FromStmt
     1 function StmtParser:nextFrom()
     8   local lex = self._.lexer
         local tok, ln, col, stmt

         --(1) read module
     8   tok = lex:next(TokenType.KEYWORD, "from")
     8   ln, col = tok.line, tok.col
     8   stmt = FromStmt.new(ln, col, lex:next(TokenType.LITERAL).value)

         --(2) items
     8   lex:next(TokenType.KEYWORD, "use")

         while true do
           local name, as

           --(1) item
    12     name = lex:next(TokenType.NAME).value

    12     tok = lex:advance()
    12     if tok.type == TokenType.KEYWORD and tok.value == "as" then
     6       lex:next()  --as
     6       as = lex:next(TokenType.NAME).value
           end

    12     stmt:insert(name, as)

           --(2) end?
    12     tok = lex:advance()
    12     if tok.type == TokenType.EOL then
     8       lex:next()
             break
           else
     4       lex:next(TokenType.SYMBOL, ",")
           end
         end

         --(3) return
     8   return stmt
       end

       --Read a var statement.
       --
       --@return VarStmt
     1 function StmtParser:nextVar()
    18   local lexer, exper = self._.lexer, self._.expParser
         local tok, ln, col, stmt, visib, sep

         --(1) read visibility
    18   tok = lexer:advance()
    18   ln, col = tok.line, tok.col

    18   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     4     lexer:next()
     4     visib = tok.value
         end

         --(2) read
    18   lexer:next(TokenType.KEYWORD, "var")
    18   stmt = VarStmt.new(ln, col, visib)

         --(3) get separator
    18   tok = lexer:advance()

    18   if tok.type == TokenType.EOL then
     6     sep = "\n"
     6     lexer:next()
         else
    12     sep = ","
         end

         --(4) get variables
         while true do
           local name, val

           --read name
    28     tok = lexer:advance()

    28     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

    22     name = lexer:next(TokenType.NAME).value

           --read value
    22     tok = lexer:advance()

    22     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    13       lexer:next()
    13       val = exper:next()
           else
     9       val = nil
           end

           --insert variable
    22     stmt:insert(name, val)

           --read separator
    22     if sep == "\n" then
     6       lexer:next(TokenType.EOL)
           else  --using comma as separator
    16       tok = lexer:next()

    16       if tok.type == TokenType.EOL then
               break
             end

     5       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating variables.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(5) return
    17   return stmt
       end

       --Read a next statement.
       --
       --@return EnumStmt
     1 function StmtParser:nextEnum(annots)
    29   local lexer = self._.lexer
         local tok, ln, col, visib, name, stmt, sep

         --(1) create stmt
    29   tok = lexer:advance()
    29   ln, col = tok.line, tok.col

         --visibility
    29   if tok.type == TokenType.KEYWORD then
    29     if tok.value == "export" or tok.value == "pub" then
     7       lexer:next()
     7       visib = tok.value
           end
         end

         --enum Name
    29   lexer:next(TokenType.KEYWORD, "enum")
    29   name = lexer:next(TokenType.NAME).value

         --create
    28   stmt = EnumStmt.new(ln, col, annots, visib, name)

         --(2) read items
    28   tok = lexer:next()

    28   if tok.type == TokenType.SYMBOL and tok.value == "{" then
    11     sep = ","
    17   elseif tok.type == TokenType.EOL then
    16     sep = "\n"
         else
     1     error(string.format("invalid token on (%s, %s).", tok.line, tok.col))
         end

         while true do
           local item, value

    57     tok = lexer:advance()

    57     if tok == nil then
             break
           end

    43     if sep == "\n" and tok.col <= stmt.col then
             break
           end

           --name
    41     item = lexer:next(TokenType.NAME).value

           --value
    40     tok = lexer:advance()

    40     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    21       lexer:next()  --=
    21       value = lexer:next(TokenType.LITERAL).value
           else
    19       value = nil
           end

           --insert
    40     stmt:insert(item, value)

           --separator
    40     if sep == "," then
    21       tok = lexer:advance()

    21       if tok.type == TokenType.SYMBOL and tok.value == "}" then
    10         lexer:next()
               break
             else
    11         lexer:next(TokenType.SYMBOL, ",")
             end
           else
    19       lexer:next(TokenType.EOL)
           end
         end

         --(3) return
    26   return stmt
       end

       --Read a while statement.
       --
       --@return WhileStmt
     1 function StmtParser:nextWhile()
    18   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, btype, cond, iter, body, catch, fin

         --(1) read while keyword
    18   tok = lex:next(TokenType.KEYWORD, "while")
    18   ln, col = tok.line, tok.col

         --(2) read condition and iter
         --condition
    18   cond = parser:nextExp()

         --iter
    18   tok = lex:advance()

    18   if tok.type == TokenType.SYMBOL and tok.value == ";" then
     3     lex:next()
     3     iter = parser:nextExp()
         end

         --do
    18   lex:next(TokenType.KEYWORD, "do")

    18   tok = lex:advance()
    18   if tok.type == TokenType.EOL then
    13     lex:next()
    13     btype = 2
         else
     5     btype = 1
         end

         --(4) read rest
    18   body = self:_readBody(btype, col)
    18   catch = self:_readCatch(col)
    18   fin = self:_readFinally(col)

         --(5) return
    18   return WhileStmt.new(ln, col, cond, iter, body, catch, fin)
       end

       --Read a do statement.
       --
       --@return Dotmt
     1 function StmtParser:nextDo()
    11   local lexer, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, catch, fin

         --(1) read while keyword
    11   tok = lexer:next(TokenType.KEYWORD, "do")
    11   ln, col = tok.line, tok.col

    11   lexer:next(TokenType.DO)

         --(2) read body
    11   body = self:_readBody(2, col)

         --(3) read condition if existing
    11   tok = lexer:advance()

    11   if tok and tok.type == TokenType.KEYWORD and tok.value == "while" then
     4     lexer:next()
     4     cond = parser:nextExp()
     4     lexer:next(TokenType.EOL)
         end

         --(4) read rest
    11   catch = self:_readCatch(col)
    11   fin = self:_readFinally(col)

         --(5) return
    11   return DoStmt.new(ln, col, body, cond, catch, fin)
       end

       --Read for statement.
       --
       --@return ForStmt
     1 function StmtParser:nextFor()
    12   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, def, cond, iter, btype, body, catch, fin

         --(1) read for keyword
    12   tok = lex:next(TokenType.KEYWORD, "for")
    12   ln, col = tok.line, tok.col

         --(2) variables
    12   def = {}

         while true do
           local name, val

           --name [= value]
    17     name = lex:next(TokenType.NAME).value

    17     tok = lex:advance()
    17     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    10       lex:next()
    10       val = parser:nextExp()
           else
     7       val = nil
           end

    17     table.insert(def, {name = name, value = val})

           --end?
    17     tok = lex:advance()

    17     if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
             break
           end

     5     lex:next(TokenType.SYMBOL, ",")
         end

    12   lex:next(TokenType.SYMBOL, ";")

         --(3) cond
    12   cond = parser:nextExp()

         --(4) iter
    12   tok = lex:advance()
    12   if tok.type == TokenType.SYMBOL and tok.value == ";" then
     4     lex:next()
     4     iter = parser:nextExp()
         end

         --(5) rest
    12   lex:next(TokenType.KEYWORD, "do")

    12   tok = lex:advance()
    12   if tok.type == TokenType.EOL then
     1     lex:next()
     1     btype = 2
         else
    11     btype = 1
         end

    12   body = self:_readBody(btype, col)
    12   catch = self:_readCatch(col)
    12   fin = self:_readFinally(col)

         --(5) return
    12   return ForStmt.new(ln, col, def, cond, iter, body, catch, fin)
       end

       --Read for each statement.
       --
       --@return ForEachStmt
     1 function StmtParser:nextForEach()
    10   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, key, val, iter, btype, body, catch, fin

         --(1) read for each keywords
    10   tok = lex:next(TokenType.KEYWORD, "for")
    10   lex:next(TokenType.KEYWORD, "each")
    10   ln, col = tok.line, tok.col

         --key
    10   key = lex:next(TokenType.NAME).value

         --value
    10   tok = lex:advance()

    10   if tok.type == TokenType.SYMBOL and tok.value == "," then
     3     lex:next()
     3     val = lex:next(TokenType.NAME).value
         else
     7     val, key = key, nil
         end

         --(3) read iter
    10   lex:next(TokenType.KEYWORD, "in")
    10   iter = parser:nextExp()

         --(4) read rest
    10   lex:next(TokenType.KEYWORD, "do")

    10   tok = lex:advance()
    10   if tok.type == TokenType.EOL then
     8     lex:next()
     8     btype = 2
         else
     2     btype = 1
         end

    10   body = self:_readBody(btype, col)
    10   catch = self:_readCatch(col)
    10   fin = self:_readFinally(col)

         --(5) return
    10   return ForEachStmt.new(ln, col, key, val, iter, body, catch, fin)
       end

       --Read a body statement as, fo example, while, for, if, etc.
       --
       --@param btype:number Body type: 1, one line; 2, block; 3, between {}.
       --@param col:number   Column line where it starts.
       --
       --@return Sent[]
     1 function StmtParser:_readBody(btype, col)
   168   local parser = self._.parser
         local body

         --(1) read body
   168   if btype == 1 then
    21     body = {parser:next()}
   147   elseif btype == 2 then
   138     body = BlockParser.new(parser, col):next()
     9   elseif btype == 3 then
     9     body = BlockParser.new(parser):next()
         end

         --(2) return
   168   return body
       end

       --Read a catch clause.
       --
       --@param col:number Column number where this must start.
       --@return CatchCl
     1 function StmtParser:_readCatch(col)
   138   local lexer, parser = self._.lexer, self._.parser
         local tok, var, body

         --(1) read catch keyword
   138   tok = lexer:advance()

   138   if tok == nil or not (tok.type == TokenType.KEYWORD and tok.value == "catch" and tok.col == col) then
   119     return
         end

    19   lexer:next()

         --(2) read error variable name
    19   tok = lexer:advance()

    19   if tok.type == TokenType.NAME then
     4     lexer:next()
     4     var = tok.value
         end

    19   lexer:next(TokenType.EOL)

         --(3) read body
    19   body = BlockParser.new(parser, col):next()

         --(4) return
    19   return CatchCl.new(var, body)
       end

       --Read a finally clause.
       --
       --@param col:number Column number where this must start.
       --@return FinallyCl
     1 function StmtParser:_readFinally(col)
   133   local lexer, parser = self._.lexer, self._.parser
         local tok, body

         --(1) read finally keyword
   133   tok = lexer:advance()

   133   if tok == nil or not (tok.type == TokenType.KEYWORD and tok.value == "finally" and tok.col == col) then
   120     return
         end

    13   lexer:next()
    13   lexer:next(TokenType.EOL)

         --(2) read body
    13   body = BlockParser.new(parser, col):next()

         --(4) return
    13   return FinallyCl.new(body)
       end

       --Read a fn statement.
       --
       --@return FnStmt
     1 function StmtParser:nextFn(annots)
    73   local lexer = self._.lexer
         local tok, ln, col, visib, itype, name, params, rtype, rvar, body, catch, fin

         --(1) read visibility
    73   tok = lexer:advance()
    73   ln, col = tok.line, tok.col

    73   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub" or tok.value == "pvt") then
     5     lexer:next()
     5     visib = tok.value
         end

         --(2) read fn type.name
    73   lexer:next(TokenType.KEYWORD, "fn")
    73   name = lexer:next(TokenType.NAME).value

    73   tok = lexer:advance()
    73   if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
    17     lexer:next()
    17     visib = (tok.value == "." and "pub" or "pvt")
    17     itype = name
    17     name = lexer:next(TokenType.NAME).value
         end

         --(3) read parameters, return type and return variable
    73   params = self:_readFnParams()
    70   rvar = self:_readFnReturnVar()
    69   rtype = self:_readFnType()

         --(4) read body
    68   tok = lexer:advance()

    68   if tok.type == TokenType.SYMBOL and tok.value == "=" then
    12     lexer:next()
    12     body = {self._.expParser:_readExp()}

    12     if #body > 0 and body[1].type == SentType.EXP then
    12       local exp = body[1]

    12       body[1] = ReturnStmt.new(exp.line, exp.col)
    12       body[1]:insert(exp)
           end
         else
    56     lexer:next(TokenType.EOL)
    56     body = self:_readBody(2, col)
         end

         --(5) read rest
    68   catch = self:_readCatch(col)
    68   fin = self:_readFinally(col)

         --(6) return
    68   return FnStmt.new(ln, col, annots, visib, itype, name, params, rtype, rvar, body, catch, fin)
       end

       --Read the function parameters.
       --
       --@return Param[]
     1 function StmtParser:_readFnParams()
    98   local lex = self._.lexer
    98   local params = Params.new()
         local tok

         --(1) read (
    98   lex:next(TokenType.SYMBOL, "(")

         --(2) read params
    98   tok = lex:advance()

    98   if not (tok.type == TokenType.SYMBOL and tok.value == ")") then
           while true do
             local const, mod, name, opt, dtype, val

             --const
    75       tok = lex:advance()

    75       if tok.type == TokenType.KEYWORD and tok.value == "const" then
     3         lex:next()
     3         const = true
             else
    72         const = false
             end

             --. or : or ...
    75       tok = lex:advance()

    75       if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":" or tok.value == "...") then
    15         lex:next()
    15         mod = tok.value
             end

             --name
    75       name = lex:next(TokenType.NAME).value

             --optional?
    75       tok = lex:advance()

    75       if tok.type == TokenType.SYMBOL and tok.value == "?" then
    20         lex:next()
    20         opt = true
             end

             --type
    75       tok = lex:advance()

    75       if tok.type == TokenType.SYMBOL and tok.value == ":" then
    15         dtype = self:_readFnParamType()
             else
    60         dtype = nil
             end

             --default value
    75       if not opt then
    55         tok = lex:advance()

    55         if tok.type == TokenType.SYMBOL and tok.value == "=" then
     3           opt = true
     3           val = self:_readFnParamValue()
    52         elseif tok.type == TokenType.SYMBOL and tok.value == ":=" then
     5           opt = true
     5           val, dtype = self:_readFnParamValueWithInference()
               end
             end

             --insert param
    74       params:insert(Param.new(const, mod, name, opt, dtype, val))

             --,
    74       tok = lex:advance()

    74       if tok.type == TokenType.SYMBOL and tok.value == "," then
    18         lex:next()
             else
               break
             end
           end
         end

         --(3) read close
    97   lex:next(TokenType.SYMBOL, ")")

         --(4) return
    95   return params
       end

       --Read the parameter type.
       --
       --@return string
     1 function StmtParser:_readFnParamType()
    15   local lex = self._.lexer
         local tok, dtype

         --(1) read
    15   lex:next(TokenType.SYMBOL, ":")

    15   tok = lex:advance()
    15   if tok.type == TokenType.SYMBOL and tok.value == "{" then
     7     lex:next()

     7     dtype = {}

     7     tok = lex:advance()
     7     if tok.type == TokenType.SYMBOL and tok.value == "}" then
     2       lex:next()
           else
             while true do
               --read field
               local pname, ptype

     8         pname = lex:next(TokenType.NAME).value

     8         tok = lex:advance()
     8         if tok.type == TokenType.SYMBOL and tok.value == ":" then
     5           lex:next()
     5           ptype = lex:next(TokenType.NAME).value
               else
     3           ptype = "any"
               end

     8         table.insert(dtype, {name = pname, type = ptype})

               --read next or end
     8         tok = lex:advance()
     8         if tok.type == TokenType.SYMBOL and tok.value == "}" then
     5           lex:next()
                 break
               end

     3         lex:next(TokenType.SYMBOL, ",")
             end --while
           end
         else
     8     dtype = lex:next(TokenType.NAME).value
         end

         --(2) return
    15   return dtype
       end

       --Read the parameter value wihtout inference.
       --
       --@return string
     1 function StmtParser:_readFnParamValue()
     3   self._.lexer:next(TokenType.SYMBOL, "=")
     3   return self._.parser:nextExp()
       end

       --Read the parameter value using inference.
       --
       --@return val, type
     1 function StmtParser:_readFnParamValueWithInference()
     5   local lex = self._.lexer
         local tok, val, dtype

         --(1) read
     5   lex:next(TokenType.SYMBOL, ":=")
     5   tok = lex:next()

     5   if tok.type == TokenType.LITERAL and type(tok.value) == "string" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.TEXT, tok))
     1     dtype = "text"
     4   elseif tok.type == TokenType.LITERAL and type(tok.value) == "number" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.NUM, tok))
     1     dtype = "num"
     3   elseif tok.type == TokenType.KEYWORD and tok.value == "true" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.TRUE, tok))
     1     dtype = "bool"
     2   elseif tok.type == TokenType.KEYWORD and tok.value == "false" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.FALSE, tok))
     1     dtype = "bool"
         else
     2     error(string.format(
     1       "on (%s, %s), for infering type, the default value must be a literal: text, num or bool.",
     1       tok.line,
             tok.col
     1     ))
         end

         --(2) return
     4   return val, dtype
       end

       --Read the function return type.
       --
       --@return string
     1 function StmtParser:_readFnType()
    80   local lex = self._.lexer
         local tok, rtype

         --(1) read
    80   tok = lex:advance()

    80   if tok.type == TokenType.SYMBOL and tok.value == ":" then
     5     lex:next()  --:
     5     rtype = lex:next(TokenType.NAME).value
         end

         --(2) return
    79   return rtype
       end

       --Read the function return variable.
       --
       --@return string
     1 function StmtParser:_readFnReturnVar()
    81   local lex = self._.lexer
         local tok, rvar

         --(1) read
    81   tok = lex:advance()

    81   if tok.type == TokenType.SYMBOL and tok.value == "->" then
    14     lex:next()  -- ->
    14     tok = lex:next()

    14     if tok.type == TokenType.KEYWORD and tok.value == "self" then
     3       rvar = "self"
    11     elseif tok.type == TokenType.NAME then
    10       rvar = tok.value
           else
     2       error(string.format(
     1         "on (%s, %s), return value must be 'self' or a name.",
     1         tok.line,
               tok.col
     1       ))
           end
         end

         --(2) return
    80   return rvar
       end

       --Read a type statement.
       --
       --@return TypeStmt
     1 function StmtParser:nextType(annots)
    14   local lexer, parser = self._.lexer, self._.parser
         local tok, ln, col, visib, name, params, btype, bargs, body, catch, fin

         --(1) read visibility
    14   tok = lexer:advance()
    14   ln, col = tok.line, tok.col

    14   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     3     lexer:next()
     3     visib = tok.value
         end

         --(2) read type name
    14   lexer:next(TokenType.KEYWORD, "type")
    14   name = lexer:next(TokenType.NAME).value

         --(3) read parameters
    14   params = self:_readFnParams()

         --(4) read base type
    14   tok = lexer:advance()

    14   if tok.type == TokenType.SYMBOL and tok.value == ":" then
     5     lexer:next()
     5     btype = lexer:next(TokenType.NAME).value

     5     tok = lexer:advance()
     5     if tok.type == TokenType.SYMBOL and tok.value == "(" then
     3       lexer:next()
     3       bargs = {}

     3       tok = lexer:advance()
     3       if not (tok.type == TokenType.SYMBOL and tok.value == ")") then
               while true do
     4           table.insert(bargs, parser:nextExp())

     4           tok = lexer:advance()
     4           if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
                   break
                 end

     2           lexer:next(TokenType.SYMBOL, ",")
               end
             end

     3       lexer:next(TokenType.SYMBOL, ")")
           end
         end

         --(5) read body
    14   lexer:next(TokenType.EOL)
    14   body = self:_readBody(2, col)

         --(6) read rest
    14   catch = self:_readCatch(col)
    14   fin = self:_readFinally(col)

         --(6) return
    14   return TypeStmt.new(ln, col, annots, visib, name, params, btype, bargs, body, catch, fin)
       end

       --Read an async statement.
       --
       --@return AsyncStmt
     1 function StmtParser:nextAsync()
     8   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, opts, body, catch

         --(1) read async keyword
     8   tok = lex:next(TokenType.KEYWORD, "async")
     8   ln, col = tok.line, tok.col

         --(2) read options
     8   opts = {}
     8   tok = lex:advance()

     8   if tok.type == TokenType.KEYWORD and tok.value == "with" then
     2     lex:next()
     2     lex:next(TokenType.SYMBOL, "{")
     2     lex:next(TokenType.NAME, "delay")
     2     lex:next(TokenType.SYMBOL, "=")
     2     opts.delay = parser:nextExp()
     2     lex:next(TokenType.SYMBOL, "}")
         end

         --(2) read body
     8   tok = lex:advance()

     8   if tok.type == TokenType.EOL then
     5     lex:next()
     5     body = self:_readBody(2, col)
     5     catch = self:_readCatch(col)
         else
     3     body = self:_readBody(1, col)
         end

         --(3) return
     8   return AsyncStmt.new(ln, col, opts, body, catch)
       end

       --Read an if statement.
       --
       --@return IfStmt
     1 function StmtParser:nextIf()
    14   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, elif, el

         --(1) read if keyword
    14   tok = lex:next(TokenType.KEYWORD, "if")
    14   ln, col = tok.line, tok.col

         --.(2) read condition
    14   cond = parser:nextExp()
    14   lex:next(TokenType.KEYWORD, "then")

    14   tok = lex:advance()

    14   if tok.type ~= TokenType.EOL then
     7     body = {parser:next()}

     7     tok = lex:advance()
     7     if tok and tok.type == TokenType.KEYWORD and tok.value == "else" then
     3       lex:next()
     3       el = {parser:next()}
           end
         else
     7     lex:next(TokenType.EOL)
     7     body = self:_readBody(2, col)

           while true do
    17       tok = lex:advance()

    17       if tok == nil or tok.col ~= col then
               break
             end

    10       if tok.type == TokenType.KEYWORD and tok.value == "else" then
    10         tok = lex:advance(2)

    10         if tok.type == TokenType.KEYWORD and tok.value == "if" then
                 local c, b

     7           lex:next()  --else
     7           lex:next()  --if
     7           c = parser:nextExp()
     7           lex:next(TokenType.KEYWORD, "then")
     7           lex:next(TokenType.EOL)
     7           b = self:_readBody(2, col)

     7           if elif == nil then
     5             elif = {}
                 end

     7           table.insert(elif, {cond = c, body = b})
               else
     3           lex:next()  --else
     3           el = self:_readBody(2, col)
               end
             else
               break
             end
           end
         end

         --(3) return
    14   return IfStmt.new(ln, col, cond, body, elif, el)
       end

       --Read a pub statement.
       --
       --@return PubStmt
     1 function StmtParser:nextPub()
    10   local lex = self._.lexer
         local tok, ln, col, items, sep

         --(1) read pub keyword
    10   tok = lex:next(TokenType.KEYWORD, "pub")
    10   ln, col = tok.line, tok.col

         --(2) set seperator
    10   tok = lex:advance()

    10   if tok.type == TokenType.EOL then
     2     lex:next()
     2     sep = "\n"
         else
     8     sep = ","
         end

         --(3) read items
    10   items = {}

         while true do
           local item

           --item
    14     tok = lex:advance()

    14     if sep == "\n" and (not tok or tok.col <= col) then
             break
           end

    12     if tok and tok.type == TokenType.LITERAL and type(tok.value) == "string" then
     5       lex:next()
     5       item = {type = "use", value = tok.value}
     7     elseif tok and tok.type == TokenType.NAME then
     6       lex:next()
     6       item = {type = "pub", value = tok.value}
           else
     1       error(string.format("on (%s,%s), literal text or name expected.", tok.line, tok.col))
           end

    11     table.insert(items, item)

           --end or next?
    11     if sep == "\n" then
     2       lex:next(TokenType.EOL)
           else
     9       tok = lex:next()

     9       if tok.type == TokenType.EOL then
               break
             else
     3         if tok.type ~= TokenType.SYMBOL or tok.value ~= "," then
     1           error(string.format("on (%s,%s), comma expected.", tok.line, tok.col))
               end
             end
           end
         end

         --(4) return
     8   return PubStmt.new(ln, col, items)
       end

       --Read an export statement.
       --
       --@return ExportStmt
     1 function StmtParser:nextExport()
     3   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, exp

         --(1) read
     3   tok = lex:next(TokenType.KEYWORD, "export")
     3   ln, col = tok.line, tok.col

     3   exp = parser:nextExp()
     2   lex:next(TokenType.EOL)

         --(2) return
     2   return ExportStmt.new(ln, col, exp)
       end

       --Read a with statement.
       --
       --@return WithStmt
     1 function StmtParser:nextWith()
     8   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, val, ifs, els

         --(1) read with
     8   tok = lex:next(TokenType.KEYWORD, "with")
     8   ln, col = tok.line, tok.col

     8   val = parser:nextExp()
     7   lex:next(TokenType.EOL)

         --(2) read ifs
     7   ifs = {}

         while true do
           local cond, ifCol, body

    17     tok = lex:advance()
    17     if not (tok and tok.type == TokenType.KEYWORD and tok.value == "if" and tok.col > col) then
             break
           end

    10     lex:next()  --if
    10     ifCol = tok.col
    10     cond = parser:nextExp()
    10     lex:next(TokenType.KEYWORD, "then")
    10     body = self:_readBody(2, ifCol)

    10     table.insert(ifs, {cond = cond, body = body})
         end

         --(3) read else
     7   tok = lex:advance()

     7   if tok and tok.type == TokenType.KEYWORD and tok.value == "else" and tok.col > col then
     3     lex:next()
     3     els = self:_readBody(2, tok.col)
         end

         --(4) return
     7   return WithStmt.new(ln, col, val, ifs, els)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtType.lua
==============================================================================
     1 return {
     1   ASYNC = "async",
     1   BREAK = "break",
     1   CONST = "const",
     1   DO = "do",
     1   ENUM = "enum",
     1   EXPORT = "export",
     1   FN = "fn",
     1   FOR = "for",
     1   FOR_EACH = "for each",
     1   FROM = "from",
     1   IF = "if",
     1   NEXT = "next",
     1   PUB = "pub",
     1   RETURN = "return",
     1   TYPE = "type",
     1   USE = "use",
     1   VAR = "var",
     1   WHILE = "while",
     1   WITH = "with",
     1   YIELD = "yield"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/TerminalType.lua
==============================================================================
     1 return {
     1   NAME = 1,
     1   NUM = 2,
     1   TEXT = 3,
     1   TRUE = 4,
     1   FALSE = 5,
     1   NIL = 6,
     1   LIST = 7,
     1   MAP = 8,
     1   SELF = 9,
     1   SUPER = 10,
     1   FN = 11,
     1   SUBEXP = 12,
     1   IF = 13,
     1   PEVAL = 14,
     1   THROW = 15,
     1   NOP = 16,
     1   NATIVE = 17
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/UnpackParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local Unpack = require("dogma.syn._.Unpack")
     1 local DataAccess = require("dogma.syn._.DataAccess")

       --An unpack sentence parser.
     1 local UnpackParser = {}
     1 UnpackParser.__index = UnpackParser
     1 setmetatable(UnpackParser, {__index = SubParser})
     1 package.loaded[...] = UnpackParser

       --Constructor.
       --
       --@param parser:Parser  Parent parser.
     1 function UnpackParser.new(parser)
   570   return setmetatable(SubParser.new(parser), UnpackParser)
       end

       --Parse the next unpack sentence.
       --
       --@return Unpack
     1 function UnpackParser:next()
    49   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, visib, def, typ, vars, assign, exp

         --(1) read visibility if needed
    49   tok = lex:advance()
    49   ln, col = tok.line, tok.col

    49   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
    13     lex:next()
    13     visib = tok.value
         end

         --(2) get type definition
    49   tok = lex:advance()

    49   if tok.type == TokenType.KEYWORD and (tok.value == "var" or tok.value == "const") then
    22     lex:next()
    22     def = tok.value
         end

         --(3) get type
    49   tok = lex:next()

    49   if tok.type == TokenType.SYMBOL and tok.value == "[" then
    34     typ = "[]"
         else
    15     typ = "{}"
         end

         --(4) get vars
    49   vars = {}

         while true do
           local mod, name, val

           --visib
   119     tok = lex:advance()

   119     if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
    20       lex:next()
    20       mod = tok.value
    99     elseif tok.type == TokenType.SYMBOL and tok.value == "..." then
     7       if typ == "{}" then
     1         error(string.format("on (%s,%s), '...' only allowed with list unpack.", tok.line, tok.col))
             else
     6         lex:next()
     6         mod = tok.value
             end
           end

           --name, name=val, name{...}
   118     name = lex:next(TokenType.NAME).value

   118     tok = lex:advance()
   118     if tok.type == TokenType.SYMBOL and tok.value == "{" then
     4       if typ == "{}" then
     1         error(string.format("on (%s,%s), 'object{}' only allowed with list unpack.", tok.line, tok.col))
             else
     3         lex:next(TokenType.SYMBOL, "{")

               while true do
                 local fmod

     5           tok = lex:advance()
     5           if tok.type == TokenType.SYMBOL and tok.value == ":" then
     1             lex:next()
     1             fmod = ":"
                 else
     4             fmod = "."
                 end

     5           table.insert(vars, DataAccess.new(visib, name .. fmod .. lex:next(TokenType.NAME).value))

     5           tok = lex:advance()
     5           if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
                   break
                 end

     2           lex:next(TokenType.SYMBOL, ",")
               end

     3         lex:next(TokenType.SYMBOL, "}")
             end
           else
             while true do
   124         tok = lex:advance()

   124         if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
    10           lex:next()
    10           name = name .. tok.value .. lex:next(TokenType.NAME).value
               else
                 break
               end
             end

   114       tok = lex:advance()

   114       if tok.type == TokenType.SYMBOL and tok.value == "=" then
     6         lex:next()
     6         val = parser:nextExp()
             end

   114       table.insert(vars, DataAccess.new(mod, name, val))
           end

           --comma or end
   117     tok = lex:advance()

   117     if typ == "[]" then
    92       if tok.type == TokenType.SYMBOL and tok.value == "]" then
    34         lex:next()
               break
             end
    25     elseif typ == "{}" then
    25       if tok.type == TokenType.SYMBOL and tok.value == "}" then
    13         lex:next()
               break
             end
           end

    70     lex:next(TokenType.SYMBOL, ",")
         end

         --(5) expression
    47   tok = lex:advance()
    47   if typ == "[]" then
    34     if not (tok.type == TokenType.SYMBOL and (tok.value == "=" or tok.value == ".=" or tok.value == ":=" or tok.value == "?=")) then
     1       error(string.format("on (%s,%s), '=', '.=', ':=' or '?=' expected.", tok.line, tok.col))
           end
         else
    13     if not (tok.type == TokenType.SYMBOL and (tok.value == "=" or tok.value == ":=")) then
     1       error(string.format("on (%s,%s), '=' or ':=' expected.", tok.line, tok.col))
           end
         end

    45   lex:next()
    45   assign = tok.value
    45   exp = parser:nextExp()
    45   lex:next(TokenType.EOL)

         --(6) return
    45   return Unpack.new(ln, col, visib, def, typ, vars, assign, exp)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AsyncStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An async statement.
     1 local AsyncStmt = {}
     1 AsyncStmt.__index = AsyncStmt
     1 setmetatable(AsyncStmt, {__index = Stmt})
     1 package.loaded[...] = AsyncStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param opts:object
       --@param body:Sent[]
       --@param catch:CatchCls
     1 function AsyncStmt.new(ln, col, opts, body, catch)
         local self

         --(1) create
     8   self = setmetatable(Stmt.new(StmtType.ASYNC, ln, col), AsyncStmt)
     8   self.opts = opts
     8   self.body = body
     8   self.catch = catch

         --(2) return
     8   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BinOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A binary operator.
     1 local BinOp = {}
     1 BinOp.__index = BinOp
     1 setmetatable(BinOp, {__index = Op})
     1 package.loaded[...] = BinOp

       --Constructor.
       --
       --@param tok:Token
     1 function BinOp.new(tok)
         local self

         --(1) create
   439   self = setmetatable(Op.new("b", tok), BinOp)
   439   self.children = {}

         --(2) return
   439   return self
       end

       --@override
     1 function BinOp:insert(node)
         -- if #self.children == 2 then
         --   error("children already set.")
         -- end

   901   table.insert(self.children, node)
   901   node.parent = self
       end

       --@override
     1 function BinOp:remove(node)
         -- if #self.children == 0 then
         --   error("no child to remove from the operator.")
         -- end

    26   return table.remove(self.children)
       end

       --@override
     1 function BinOp:isWellFormed()
   927   return #self.children == 2
       end

       --@override
     1 function BinOp:__tostring()
   375   return string.format("(%s %s %s)", self.op, self.children[1], self.children[2])
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BlockParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SubParser = require("dogma.syn._.SubParser")

       --An expression parser.
     1 local BlockParser = {}
     1 BlockParser.__index = BlockParser
     1 setmetatable(BlockParser, {__index = SubParser})
     1 package.loaded[...] = BlockParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
       --@param col:number     Column number.
     1 function BlockParser.new(parser, col)
         local self

   179   self = setmetatable(SubParser.new(parser), BlockParser)
   179   if col == nil then
     9     self._.col = 0
     9     self._.type = "end"
         else
   170     self._.col = col
   170     self._.type = "\n"
         end

   179   return self
       end

       --Parse the next block.
       --
       --@return Sent[]
     1 function BlockParser:next()
   179   local lex, parser, btype = self._.lexer, self._.parser, self._.type
         local tok
   179   local col, block = self._.col, {}

         --(1) see if empty function
   179   if btype == "end" then
     9     tok = lex:advance()

     9     if tok.type == TokenType.KEYWORD and tok.value == "end" then
     7       lex:next()
     7       return block
           end
         end

         --(1) read
         while true do
           local sent

   296     tok = lex:advance()

           --remove white lines
   423     while tok and tok.type == TokenType.EOL do
   127       lex:next()
   127       tok = lex:advance()
           end

   296     if btype == "end" and tok and tok.type == TokenType.KEYWORD and tok.value == "end" then
             break
           end

   294     if tok == nil or tok.col <= col then
             break
           end

           --parse next sentence
   124     sent = parser:next()

   124     if sent then
   124       table.insert(block, sent)
           else
             break
           end
         end

         --(3) read } if needed
   172   if btype == "end" then
     2     lex:next(TokenType.KEYWORD, "end")
         end

         --(3) return
   172   return block
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BreakStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A break statement.
     1 local BreakStmt = {}
     1 BreakStmt.__index = BreakStmt
     1 setmetatable(BreakStmt, {__index = Stmt})
     1 package.loaded[...] = BreakStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function BreakStmt.new(ln, col)
     3   return setmetatable(Stmt.new(StmtType.BREAK, ln, col), BreakStmt)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CallOp.lua
==============================================================================
       --imports
     1 local NaryOp = require("dogma.syn._.NaryOp")

       --A call operator.
     1 local CallOp = {}
     1 CallOp.__index = CallOp
     1 setmetatable(CallOp, {__index = NaryOp})
     1 package.loaded[...] = CallOp

       --Constructor.
       --
       --@param tok:Token
     1 function CallOp.new(tok)
         local self

         --(1) create
   103   self = setmetatable(NaryOp.new(tok), CallOp)
   103   self.children = {}
   103   self.finished = false

         --(2) return
   103   return self
       end

       --@override
     1 function CallOp:__tostring()
         local ops

         --(1) get expressions
    71   ops = ""
   200   for _, op in ipairs(self.children) do
   129     ops = ops .. (ops == "" and "" or " ") .. op:__tostring()
         end

         --(2) return
    71   return string.format("(call %s)", ops)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CatchCl.lua
==============================================================================
       --A catch clause.
     1 local CatchCl = {}
     1 CatchCl.__index = CatchCl
     1 package.loaded[...] = CatchCl

       --Constructor.
       --
       --@param var:string Exception variable name.
       --@param body:Body  Body sentences.
     1 function CatchCl.new(var, body)
    38   return setmetatable({
    19     var = var,
    19     body = body
    38   }, CatchCl)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ConstStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A var statement.
     1 local ConstStmt = {}
     1 ConstStmt.__index = ConstStmt
     1 setmetatable(ConstStmt, {__index = Stmt})
     1 package.loaded[...] = ConstStmt

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param visib:string Visibility: export or pub.
     1 function ConstStmt.new(ln, col, visib)
         local self

         --(1) create
    15   self = setmetatable(Stmt.new(StmtType.CONST, ln, col), ConstStmt)
    15   self.vars = {}
    15   self.visib = visib

         --(2) return
    15   return self
       end

       --Add a variable declaration.
       --
       --@param name:string  Variable name.
       --@param val?:Exp     Default value.
     1 function ConstStmt:insert(name, val)
    17   table.insert(self.vars, {name = name, value = val})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DataAccess.lua
==============================================================================
       --Data access.
     1 local DataAccess = {}
     1 DataAccess.__index = DataAccess
     1 package.loaded[...] = DataAccess

       --Constructor.
     1 function DataAccess.new(mod, name, value)
   119   return setmetatable({mod = mod, name = name, value = value}, DataAccess)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Directive.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --A directive.
       --@abstract
     1 local Directive = {}
     1 Directive.__index = Directive
     1 setmetatable(Directive, {__index = Sent})
     1 package.loaded[...] = Directive

       --Constructor.
       --
       --@param subtype:DirectiveType  Directive type.
       --@param ln:number              Line number.
       --@param col:number             Column number.
     1 function Directive.new(subtype, ln, col)
         local self

         --(1) create
    14   self = setmetatable(Sent.new(SentType.DIRECTIVE, ln, col), Directive)
    14   self.subtype = subtype

         --(2) return
    14   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DoStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A while statement.
     1 local DoStmt = {}
     1 DoStmt.__index = DoStmt
     1 setmetatable(DoStmt, {__index = Stmt})
     1 package.loaded[...] = DoStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param body:Sent[]
       --@param cond?:Exp
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function DoStmt.new(ln, col, body, cond, catch, fin)
         local self

         --(1) create
    11   self = setmetatable(Stmt.new(StmtType.DO, ln, col), DoStmt)
    11   self.body = body
    11   self.cond = cond
    11   self.catch = catch
    11   self.finally = fin

         --(2) return
    11   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/EnumStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An enum statement.
     1 local EnumStmt = {}
     1 EnumStmt.__index = EnumStmt
     1 setmetatable(EnumStmt, {__index = ObjectStmt})
     1 package.loaded[...] = EnumStmt

       --Constructor.
     1 function EnumStmt.new(ln, col, annots, visib, name)
         local self

         --(1) create
    28   self = setmetatable(ObjectStmt.new(StmtType.ENUM, ln, col, name, visib), EnumStmt)
    28   self.items = {}
    28   self.annots = annots or {}
    28   self._.lastValue = nil

         --(2) return
    28   return self
       end

       --Insert an item.
       --
       --@param item:string    Item name.
       --@param value:any      Item value.
     1 function EnumStmt:insert(item, value)
         --(1) set value if needed
    40   if value == nil then
    19     if self._.lastValue == nil then
    11       self._.lastValue = 1
           else
     8       self._.lastValue = self._.lastValue + 1
           end

    19     value = self._.lastValue
         end

         --(2) insert
    40   table.insert(self.items, {name = item, value = value})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Exp.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")
     1 local SyntaxTree = require("dogma.syn._.SyntaxTree")

       --An expression.
     1 local Exp = {}
     1 Exp.__index = Exp
     1 setmetatable(Exp, {__index = Sent})
     1 package.loaded[...] = Exp

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function Exp.new(ln, col)
         local self

         --(1) create
   814   self = setmetatable(Sent.new(SentType.EXP, ln, col), Exp)
   814   self.tree = SyntaxTree.new()

         --(2) return
   814   return self
       end

       --Add a new node to the expression.
       --
       --@param node:Node  Node to add.
     1 function Exp:insert(node)
  1820   self.tree:insert(node)
       end

       --@override
     1 function Exp:__tostring()
   720   return self.tree:__tostring()
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ExportStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An export statement.
     1 local ExportStmt = {}
     1 ExportStmt.__index = ExportStmt
     1 setmetatable(ExportStmt, {__index = Stmt})
     1 package.loaded[...] = ExportStmt

       --Constructor.
     1 function ExportStmt.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Stmt.new(StmtType.EXPORT, ln, col), ExportStmt)
     2   self.exp = exp

         --(2) return
     2   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FinallyCl.lua
==============================================================================
       ----A finally clause.
     1 local FinallyCl = {}
     1 FinallyCl.__index = FinallyCl
     1 package.loaded[...] = FinallyCl

       --Constructor.
       --
       --@param body:Body  Body sentences.
     1 function FinallyCl.new(body)
    26   return setmetatable({
    13     body = body
    26   }, FinallyCl)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FnStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A fn statement.
     1 local FnStmt = {}
     1 FnStmt.__index = FnStmt
     1 setmetatable(FnStmt, {__index = ObjectStmt})
     1 package.loaded[...] = FnStmt

       --Constructor.
     1 function FnStmt.new(ln, col, annots, visib, itype, name, params, rtype, rvar, body, catch, fin)
         local self

         --(1) create
    68   self = setmetatable(ObjectStmt.new(StmtType.FN, ln, col, name, visib), FnStmt)
    68   self.itype = itype
    68   self.params = params
    68   self.rtype = rtype
    68   self.rvar = rvar
    68   self.body = body
    68   self.catch = catch
    68   self.finally = fin
    68   self.annots = annots or {}

         --(2) return
    68   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForEachStmt.lua
==============================================================================
       --Imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A for each statement.
     1 local ForEachStmt = {}
     1 ForEachStmt.__index = ForEachStmt
     1 setmetatable(ForEachStmt, {__index = Stmt})
     1 package.loaded[...] = ForEachStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param key?:string
       --@param value:string
       --@param iter:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function ForEachStmt.new(ln, col, key, val, iter, body, catch, fin)
         local self

         --(1) create
    10   self = setmetatable(Stmt.new(StmtType.FOR_EACH, ln, col), ForEachStmt)
    10   self.key = key
    10   self.value = val
    10   self.iter = iter
    10   self.body = body
    10   self.catch = catch
    10   self.finally = fin

         --(2) return
    10   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForStmt.lua
==============================================================================
       --Imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A for statement.
     1 local ForStmt = {}
     1 ForStmt.__index = ForStmt
     1 setmetatable(ForStmt, {__index = Stmt})
     1 package.loaded[...] = ForStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param def:VarStmt
       --@param cond:Exp
       --@param iter:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function ForStmt.new(ln, col, def, cond, iter, body, catch, fin)
         local self

         --(1) create
    12   self = setmetatable(Stmt.new(StmtType.FOR, ln, col), ForStmt)
    12   self.def = def
    12   self.cond = cond
    12   self.iter = iter
    12   self.body = body
    12   self.catch = catch
    12   self.finally = fin

         --(2) return
    12   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FromStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A from statement.
     1 local FromStmt = {}
     1 FromStmt.__index = FromStmt
     1 setmetatable(FromStmt, {__index = Stmt})
     1 package.loaded[...] = FromStmt

       --Constructor.
     1 function FromStmt.new(ln, col, mod)
         local self

         --(1) create
     8   self = setmetatable(Stmt.new(StmtType.FROM, ln, col), FromStmt)
     8   self.module = mod
     8   self.members = {}

         --(2) return
     8   return self
       end

       --Insert an imported member.
       --
       --@param name:string  Member name to import.
       --@param as?:string   Name to use in the code.
     1 function FromStmt:insert(name, as)
    12   table.insert(self.members, {name = name, as = as or name})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfDirective.lua
==============================================================================
       --imports
     1 local Directive = require("dogma.syn._.Directive")
     1 local DirectiveType = require("dogma.syn.DirectiveType")

       --An if directive.
     1 local IfDirective = {}
     1 IfDirective.__index = IfDirective
     1 setmetatable(IfDirective, {__index = Directive})
     1 package.loaded[...] = IfDirective

       --Constructor.
     1 function IfDirective.new(ln, col, cond, body, el)
         local self

         --(1) create
    11   self = setmetatable(Directive.new(DirectiveType.IF, ln, col), IfDirective)
    11   self.cond = cond
    11   self.body = body
    11   self.el = el

         --(2) return
    11   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfStmt.lua
==============================================================================
       --importsa
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An if statement.
     1 local IfStmt = {}
     1 IfStmt.__index = IfStmt
     1 setmetatable(IfStmt, {__index = Stmt})
     1 package.loaded[...] = IfStmt

       --Constructor.
     1 function IfStmt.new(ln, col, cond, body, elif, el)
         local self

         --(1) create
    14   self = setmetatable(Stmt.new(StmtType.IF, ln, col), IfStmt)
    14   self.cond = cond
    14   self.body = body
    14   self.elif = elif
    14   self.el = el

         --(2) return
    14   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfSubExp.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An (if Exp then Exp else Exp) subexpression.
     1 local IfSubExp = {}
     1 IfSubExp.__index = IfSubExp
     1 setmetatable(IfSubExp, {__index = Terminal})
     1 package.loaded[...] = IfSubExp

       --Constructor.
     1 function IfSubExp.new(ln, col, cond, ifTrue, ifFalse)
         local self

         --(1) create
     3   self = setmetatable(Terminal.new(TerminalType.IF, {line = ln, col = col}), IfSubExp)
     3   self.cond = cond
     3   self.trueCase = ifTrue
     3   self.falseCase = ifFalse

         --(2) return
     3   return self
       end

       --@override
     1 function IfSubExp:__tostring()
     4   return string.format(
     2     "(if %s %s %s)",
     2     tostring(self.cond),
     2     tostring(self.trueCase),
     2     tostring(self.falseCase)
     2   )
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An array terminal node.
     1 local LiteralFn = {}
     1 LiteralFn.__index = LiteralFn
     1 setmetatable(LiteralFn, {__index = Terminal})
     1 package.loaded[...] = LiteralFn

       --Constructor.
     1 function LiteralFn.new(ln, col, params, rtype, rvar, body)
         local self

    33   self = setmetatable(Terminal.new(TerminalType.FN, {
    11     line = ln,
    11     col = col,
    11     value = {
    11       params = params,
    11       type = rtype,
    11       rvar = rvar,
    11       body = body
    11     }
    22   }), LiteralFn)

    11   return self
       end

       --@override
     1 function LiteralFn:__tostring()
         local desc

    24   desc = "fn("
    48   for i, p in ipairs(self.data.params) do
    24     desc = desc .. (i == 1 and "" or ", ") .. p.name
         end
    24   desc = desc .. ")"

    24   desc = desc .. "{"
    48   for i, s in ipairs(self.data.body) do
    24     desc = desc .. (i == 1 and "" or "; ") .. tostring(s)
         end
    24   desc = desc .. "}"

    24   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralList.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A literal list node.
     1 local LiteralList = {}
     1 LiteralList.__index = LiteralList
     1 setmetatable(LiteralList, {__index = Terminal})
     1 package.loaded[...] = LiteralList

       --Constructor.
     1 function LiteralList.new(ln, col, arr)
    11   return setmetatable(Terminal.new(TerminalType.LIST, {line = ln, col = col, value = arr}), LiteralList)
       end

       --@override
     1 function LiteralList:__tostring()
         local desc

    48   desc = "["
   138   for i, v in ipairs(self.data) do
    90     desc = desc .. (i == 1 and "" or ", ") .. tostring(v)
         end
    48   desc = desc .. "]"

    48   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralMap.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A map terminal node.
     1 local LiteralMap = {}
     1 LiteralMap.__index = LiteralMap
     1 setmetatable(LiteralMap, {__index = Terminal})
     1 package.loaded[...] = LiteralMap

       --Constructor.
     1 function LiteralMap.new(ln, col, map)
    13   return setmetatable(Terminal.new(TerminalType.MAP, {line = ln, col = col, value = map}), LiteralMap)
       end

       --@override
     1 function LiteralMap:__tostring()
         local desc

    60   desc = "{"
   156   for i, e in ipairs(self.data) do
    96     desc = desc .. (i == 1 and "" or ", ") .. e.name .. " = " .. tostring(e.value)
         end
    60   desc = desc .. "}"

    60   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NaryOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A n-ary operator.
     1 local NaryOp = {}
     1 NaryOp.__index = NaryOp
     1 setmetatable(NaryOp, {__index = Op})
     1 package.loaded[...] = NaryOp

       --Constructor.
       --
       --@param tok:Token
     1 function NaryOp.new(tok)
         local self

         --(1) create
   115   self = setmetatable(Op.new("n", tok), NaryOp)
   115   self.children = {}
   115   self.finished = false

         --(2) return
   115   return self
       end

       --@override
     1 function NaryOp:insert(node)
   201   if self.finished then
     2     error(string.format(
     1       "(%s,%s): node can't be inserted to full call.",
     1       node.tok.line,
     1       node.tok.col
     1     ))
         end

   200   table.insert(self.children, node)
       end

       --@override
     1 function NaryOp.remove()
     1   error("call operator can't remove children.")
       end

       --@override
     1 function NaryOp:isWellFormed()
   111   return self.finished
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NativeFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A native code.
     1 local NativeFn = {}
     1 NativeFn.__index = NativeFn
     1 setmetatable(NativeFn, {__index = Terminal})
     1 package.loaded[...] = NativeFn

       --Constructor.
     1 function NativeFn.new(ln, col, code)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.NATIVE, {line = ln, col = col}), NativeFn)
     2   self.code = code

         --(2) return
     2   return self
       end

       --@override
     1 function NativeFn:__tostring()
     1   return string.format('(native "%s")', self.code)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NextStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A next statement.
     1 local NextStmt = {}
     1 NextStmt.__index = NextStmt
     1 setmetatable(NextStmt, {__index = Stmt})
     1 package.loaded[...] = NextStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function NextStmt.new(ln, col)
     3   return setmetatable(Stmt.new(StmtType.NEXT, ln, col), NextStmt)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Node.lua
==============================================================================
       --A node.
     1 local Node = {}
     1 Node.__index = Node
     1 package.loaded[...] = Node

       --Constructor.
       --
       --@param t:string           Node type.
     1 function Node.new(t, tok)
  5284   return setmetatable({
  2642     type = t,
  2642     parent = nil,
  2642     token = tok
  5284   }, Node)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NonTerminal.lua
==============================================================================
       --imports
     1 local Node = require("dogma.syn._.Node")
     1 local NodeType = require("dogma.syn.NodeType")

       --A non-terminal node, that is, a branch.
     1 local NonTerminal = {}
     1 NonTerminal.__index = NonTerminal
     1 setmetatable(NonTerminal, {__index = Node})
     1 package.loaded[...] = NonTerminal

       --Constructor.
       --
       --@param sub:NonTerminalType
       --@param tok:Token
     1 function NonTerminal.new(sub, tok)
         local self

         --(1) create
  1407   self = setmetatable(Node.new(NodeType.NON_TERMINAL, tok), NonTerminal)
  1407   self.subtype = sub

         --(2) return
  1407   return self
       end

       --Add a node to the non-terminal.
       --
       --@param child:Node Node to add.
     1 function NonTerminal.insert()
     1   error("abstract node.")
       end

       --Remove and return last child for transfering to other node.
       --
       --@return Node
     1 function NonTerminal.remove()
     1   error("abstract node.")
       end

       --Is it well-formed?
       --
       --@return bool
       -- function NonTerminal:isWellFormed()
       --   error("abstract method.")
       -- end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ObjectStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")

       --A statement for defining an object.
     1 local ObjectStmt = {}
     1 ObjectStmt.__index = ObjectStmt
     1 setmetatable(ObjectStmt, {__index = Stmt})
     1 package.loaded[...] = ObjectStmt

       --Constructor.
       --
       --@param sub:StmtType   Statement type.
       --@param ln:number      Line number.
       --@param col:number     Column number.
       --@param name:string    Object name.
       --@param visib:string   export or pub if indicated?
     1 function ObjectStmt.new(sub, ln, col, name, visib)
         local self

         --(1) create
   110   self = setmetatable(Stmt.new(sub, ln, col), ObjectStmt)
   110   self.name = name
   110   self.visib = visib

         --(2) return
   110   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Op.lua
==============================================================================
       --imports
     1 local NonTerminal = require("dogma.syn._.NonTerminal")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")

       --An operator.
     1 local Op = {}
     1 Op.__index = Op
     1 setmetatable(Op, {__index = NonTerminal})
     1 package.loaded[...] = Op

       --Constructor.
       --
       --@param arity:string       Arity: u, b, t, n.
       --@param optor:string       The operator.
     1 function Op.new(arity, tok)
         local self

         --(1) create
   591   self = setmetatable(NonTerminal.new(NonTerminalType.OP, tok), Op)
   591   self.op = tok.value
   591   self.arity = arity
   591   local desc = self:getDesc()
   591   self.assoc = desc.assoc
   591   self.prec = desc.prec

         --(2) return
   591   return self
       end

       --Return the operator descriptor: assoc and prec.
     1 function Op:getDesc()
   591   local OPS = {
   591     ["u ."] = {assoc = "r", prec = 20},
   591     ["u :"] = {assoc = "r", prec = 20},

   591     ["b ."] = {assoc = "l", prec = 19},
   591     ["b :"] = {assoc = "l", prec = 19},
   591     ["b []"] = {assoc = "l", prec = 19},  --index
   591     ["t []"] = {assoc = "l", prec = 19},  --index
   591     ["n ()"] = {assoc = "l", prec = 19},  --call
   591     ["n {}"] = {assoc = "l", prec = 19},  --exp{}

   591     ["u !"] = {assoc = "r", prec = 18},
   591     ["u not"] = {assoc = "r", prec = 18},
   591     ["u ~"] = {assoc = "r", prec = 18},
   591     ["u +"] = {assoc = "r", prec = 18},
   591     ["u -"] = {assoc = "r", prec = 18},

   591     ["b **"] = {assoc = "r", prec = 17},

   591     ["b *"] = {assoc = "l", prec = 16},
   591     ["b /"] = {assoc = "l", prec = 16},
   591     ["b %"] = {assoc = "l", prec = 16},

   591     ["b +"] = {assoc = "l", prec = 15},
   591     ["b -"] = {assoc = "l", prec = 15},

   591     ["b <<"] = {assoc = "l", prec = 14},
   591     ["b >>"] = {assoc = "l", prec = 14},

   591     ["b <"] = {assoc = "l", prec = 13},
   591     ["b <="] = {assoc = "l", prec = 13},
   591     ["b >"] = {assoc = "l", prec = 13},
   591     ["b >="] = {assoc = "l", prec = 13},
   591     ["b in"] = {assoc = "l", prec = 13},
   591     ["b notin"] = {assoc = "l", prec = 13},
   591     ["b is"] = {assoc = "l", prec = 13},
   591     ["b isnot"] = {assoc = "l", prec = 13},
   591     ["b like"] = {assoc = "l", prec = 13},
   591     ["b notlike"] = {assoc = "l", prec = 13},

   591     ["b =="] = {assoc = "l", prec = 12},
   591     ["b ==="] = {assoc = "l", prec = 12},
   591     ["b =~"] = {assoc = "l", prec = 12},
   591     ["b !="] = {assoc = "l", prec = 12},
   591     ["b !=="] = {assoc = "l", prec = 12},
   591     ["b !~"] = {assoc = "l", prec = 12},

   591     ["b &"] = {assoc = "l", prec = 11},
   591     ["b ^"] = {assoc = "l", prec = 10},
   591     ["b |"] = {assoc = "l", prec = 9},

   591     ["b &&"] = {assoc = "l", prec = 8},
   591     ["b and"] = {assoc = "l", prec = 8},

   591     ["b ||"] = {assoc = "l", prec = 7},
   591     ["b or"] = {assoc = "l", prec = 7},

   591     ["b ="] = {assoc = "r", prec = 6},
   591     ["b :="] = {assoc = "r", prec = 6},
   591     ["b .="] = {assoc = "r", prec = 6},
   591     ["b +="] = {assoc = "r", prec = 6},
   591     ["b -="] = {assoc = "r", prec = 6},
   591     ["b *="] = {assoc = "r", prec = 6},
   591     ["b **="] = {assoc = "r", prec = 6},
   591     ["b /="] = {assoc = "r", prec = 6},
   591     ["b %="] = {assoc = "r", prec = 6},
   591     ["b <<="] = {assoc = "r", prec = 6},
   591     ["b >>="] = {assoc = "r", prec = 6},
   591     ["b &="] = {assoc = "r", prec = 6},
   591     ["b |="] = {assoc = "r", prec = 6},
   591     ["b ^="] = {assoc = "r", prec = 6},
   591     ["b ?="] = {assoc = "r", prec = 6},

   591     ["u ..."] = {assoc = "r", prec = 5}
         }

   591   return OPS[self.arity .. " " .. self.op]
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PackOp.lua
==============================================================================
       --imports
     1 local NaryOp = require("dogma.syn._.NaryOp")

       --A
     1 local PackOp = {}
     1 PackOp.__index = PackOp
     1 setmetatable(PackOp, {__index = NaryOp})
     1 package.loaded[...] = PackOp

       --Constructor.
       --
       --@param tok:Token
       --@param
     1 function PackOp.new(tok)
         local self

         --(1) create
    12   self = setmetatable(NaryOp.new(tok), PackOp)
    12   self.children = {}
    12   self.finished = false

         --(2) return
    12   return self
       end

       --@override
     1 function NaryOp:__tostring()
         local ops

         --(1) get expressions
    19   for ix, op in ipairs(self.children) do
    13     if ix == 1 then
     6       ops = op:__tostring()
           else
     7       ops = ops .. " " .. op.visib .. op.name
           end
         end

         --(2) return
     6   return string.format("(pack %s)", ops)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Param.lua
==============================================================================
       --A function parameter.
     1 local Param = {}
     1 Param.__index = Param
     1 package.loaded[...] = Param

       --Constructor.
       --
       --@param const:bool
       --@param mod?:string . or : or ....
       --@param name:string
       --@param opt:bool
       --@param dtype?:Exp
       --@param val?:Exp
     1 function Param.new(const, mod, name, opt, dtype, val)
         local self

         --(1) create
   148   self = setmetatable({
    74     const = const,
    74     modifier = mod,  --. or : or ...
    74     name = name,
    74     optional = not not opt,
    74     type = dtype,
    74     value = val
   148   }, Param)

         --(2) return
    74   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Params.lua
==============================================================================
       --A parameters list.
     1 local Params = {}
     1 Params.__index = Params
     1 setmetatable(Params, {__index = table})
     1 package.loaded[...] = Params

       --Constructor.
     1 function Params.new()
    98   return setmetatable({}, Params)
       end

       --Check whether a parameter exists.
       --
       --@param name:string  Parameter name.
       --@return bool
     1 function Params:has(name)
         local res

         --(1) check
     8   res = false

    16   for _, param in ipairs(self) do
    10     if param.name == name then
     2       res = true
             break
           end
         end

         --(2) return
     8   return res
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PevalFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A protected call.
     1 local PevalFn = {}
     1 PevalFn.__index = PevalFn
     1 setmetatable(PevalFn, {__index = Terminal})
     1 package.loaded[...] = PevalFn

       --Constructor.
     1 function PevalFn.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.PEVAL, {line = ln, col = col}), PevalFn)
     2   self.exp = exp

         --(2) return
     2   return self
       end

       --@override
     1 function PevalFn:__tostring()
     1   return string.format("(peval %s)", tostring(self.exp))
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PubStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")
     1 local UseStmt = require("dogma.syn._.UseStmt")

       --A pub statement.
     1 local PubStmt = {}
     1 PubStmt.__index = PubStmt
     1 setmetatable(PubStmt, {__index = Stmt})
     1 package.loaded[...] = PubStmt

       --Constructor.
     1 function PubStmt.new(ln, col, items)
         local self

         --(1) create
     8   self = setmetatable(Stmt.new(StmtType.PUB, ln, col), PubStmt)
     8   self.items = items

    18   for _, item in ipairs(items) do
    10     if item.type == "use" then
     5       item.value = {
     5         path = item.value,
     5         name = UseStmt.getNameFor(item.value)
     5       }
           end
         end

         --(2) return
     8   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ReturnStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A return statement.
     1 local ReturnStmt = {}
     1 ReturnStmt.__index = ReturnStmt
     1 setmetatable(ReturnStmt, {__index = Stmt})
     1 package.loaded[...] = ReturnStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param val?:Exp   Value to return.
     1 function ReturnStmt.new(ln, col, val)
         local self

         --(1) create
    24   self = setmetatable(Stmt.new(StmtType.RETURN, ln, col), ReturnStmt)
    24   if val then
     2     self.values = {val}
         else
    22     self.values = {}
         end

         --(2) return
    24   return self
       end

       --@override
     1 function ReturnStmt:__len()
     2   return #self.values
       end

       --Add a value.
       --
       --@param val:Exp  Value to add.
     1 function ReturnStmt:insert(val)
    20   table.insert(self.values, val)
       end

     1 function ReturnStmt:__tostring()
    24   if #self.values == 0 then
     3     return "return"
         else
    21     return "return " .. tostring(self.values[1])
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/RunWithDirective.lua
==============================================================================
       --imports
     1 local Directive = require("dogma.syn._.Directive")
     1 local DirectiveType = require("dogma.syn.DirectiveType")

       --A runWith directive.
     1 local RunWithDirective = {}
     1 RunWithDirective.__index = RunWithDirective
     1 setmetatable(RunWithDirective, {__index = Directive})
     1 package.loaded[...] = RunWithDirective

       --Constructor.
     1 function RunWithDirective.new(ln, col, cmd)
         local self

         --(1) create
     3   self = setmetatable(Directive.new(DirectiveType.RUNWITH, ln, col), RunWithDirective)
     3   self.cmd = cmd

         --(2) return
     3   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Sent.lua
==============================================================================
       --A sentence.
     1 local Sent = {}
     1 Sent.__index = Sent
     1 package.loaded[...] = Sent

       --Constructor.
     1 function Sent.new(t, ln, col)
  2324   return setmetatable({
  1162     type = t,
  1162     line = ln,
  1162     col = col,
  1162     _ = {}
  2324   }, Sent)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SliceOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A slice operator: [,].
     1 local SliceOp = {}
     1 SliceOp.__index = SliceOp
     1 setmetatable(SliceOp, {__index = Op})
     1 package.loaded[...] = SliceOp

       --Constructor.
       --
       --@param tok:Token
     1 function SliceOp.new(tok)
         local self

     5   self = setmetatable(Op.new("t", tok), SliceOp)
     5   self.children = {}

     5   return self
       end

       --@override
     1 function SliceOp:insert(node)
         -- if #self.children == 3 then
         --   error("children already set.")
         -- end

    15   table.insert(self.children, node)
       end

       --@override
       -- function SliceOp.remove()
       --   error("slice operator can't remove children.")
       -- end

       --@override
     1 function SliceOp:isWellFormed()
     5   return #self.children == 3
       end

       --@override
     1 function SliceOp:__tostring()
    15   return string.format("(%s %s %s %s)", self.op, self.children[1], self.children[2], self.children[3])
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Stmt.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --A statement.
     1 local Stmt = {}
     1 Stmt.__index = Stmt
     1 setmetatable(Stmt, {__index = Sent})
     1 package.loaded[...] = Stmt

       --Constructor.
       --
       --@param sub:StmtType   Statement type.
       --@param ln:number      Line number.
       --@param col:number     Column number.
     1 function Stmt.new(sub, ln, col)
         local self

         --(1) create
   289   self = setmetatable(Sent.new(SentType.STMT, ln, col), Stmt)
   289   self.subtype = sub

         --(2) return
   289   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubExp.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A subexpression: (Exp).
     1 local SubExp = {}
     1 SubExp.__index = SubExp
     1 setmetatable(SubExp, {__index = Terminal})
     1 package.loaded[...] = SubExp

       --Constructor.
     1 function SubExp.new(ln, col, exp)
    11   return setmetatable(Terminal.new(TerminalType.SUBEXP, {line = ln, col = col, value = exp}), SubExp)
       end

       --@override
     1 function SubExp:__tostring()
     7   return tostring(self.data)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")

       --A subparser.
     1 local SubParser = {}
     1 SubParser.__index = SubParser
     1 package.loaded[...] = SubParser

       --Constructor.
       --
       --@param Parser:Parser  Parent parser.
     1 function SubParser.new(parser)
         --(1) arguments
  2459   if not parser then error("parser expected.") end

         --(2) create
  4918   return setmetatable({
  2459     _ = {
  2459       parser = parser,
  2459       lexer = parser._.lexer
  2459     }
  4918   }, SubParser)
       end

       --Read next end of lines.
     1 function SubParser:_nextEols()
    16   local lex = self._.lexer

         while true do
    25     local tok = lex:advance()
    25     if tok.type == TokenType.EOL then
     9       lex:next()
           else
             break
           end
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SyntaxTree.lua
==============================================================================
       --imports
     1 local NodeType = require("dogma.syn.NodeType")
     1 local NonTerminal = require("dogma.syn._.NonTerminal")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")

       --A syntax tree, for example, an expression.
     1 local SyntaxTree = {}
     1 SyntaxTree.__index = SyntaxTree
     1 setmetatable(SyntaxTree, {__index = NonTerminal})
     1 package.loaded[...] = SyntaxTree

       --Constructor.
     1 function SyntaxTree.new()
         local self

         --(1) create
   814   self = setmetatable(NonTerminal.new(NonTerminalType.TREE), SyntaxTree)
   814   self.root = nil
   814   self._ = {
   814     current = nil
   814   }

         --(2) return
   814   return self
       end

       --@override
     1 function SyntaxTree:insert(node)
         --(1) arguments
  1820   if not node then error("node expected.") end

         --(2) add
  1820   if self.root == nil then --1st node to add
   805     self:_init(node)
         else
  1015     self:_update(node)
         end
       end

     1 function SyntaxTree:_init(node)
   805   self.root = node

   805   if node.type == NodeType.NON_TERMINAL then
    26     self._.current = node
         end
       end

     1 function SyntaxTree:_update(node)
  1015   if self.root.type == NodeType.TERMINAL then
   491     self:_updateTerminalRoot(node)
         else
   524     self:_updateFromCurrent(node)
         end
       end

       --Update the tree when this is well-formed with one terminal.
     1 function SyntaxTree:_updateTerminalRoot(node)
   491   if node.type == NodeType.TERMINAL then
     2     error(string.format(
     1       "(%s,%s): terminal can't follow to other terminal.",
     1       node.token.line,
     1       node.token.col
     1     ))
         end

         --node is non-terminal, for example, an operator
   490   node:insert(self.root)
   490   self.root = node
   490   self._.current = node
       end

       --Update th tree from the current node.
       --For example, when a+b for adding a call operator.
       --We use the precedence and the associativity for determining.
     1 function SyntaxTree:_updateFromCurrent(new)
   532   local cur = self._.current

   532   if self:isWellFormed() then
    76     if new.type == NodeType.TERMINAL then
     2       error(string.format(
     1         "on (%s,%s), invalid terminal node for well-formed expression.",
     1         new.token.line,
     1         new.token.col
     1       ))
           else
    75       if cur.prec > new.prec then
    31         self:_updateUpNodeFromCurrent(new)
    44       elseif cur.prec < new.prec then
    27         self:_updateDownNodeFromCurrent(new)
             else
    17         if cur.assoc == "l" then
    16           self:_updateUpNodeFromCurrent(new)
               else
     1           self:_updateDownNodeFromCurrent(new)
               end
             end
           end
         else  --non well-formed
   456     cur:insert(new)

   455     if new.type == NodeType.NON_TERMINAL then
     6       self._.current = new
           end
         end
       end

     1 function SyntaxTree:_updateUpNodeFromCurrent(node)
    47   if self.root == self._.current then
    39     node:insert(self.root)
    39     self.root = node
    39     self._.current = node
         else
     8     self._.current = self._.current.parent
     8     self:_updateFromCurrent(node)
         end
       end

     1 function SyntaxTree:_updateDownNodeFromCurrent(node)
    28   node:insert(self._.current:remove())
    28   self._.current:insert(node)
    28   self._.current = node
       end

       --@override
     1 function SyntaxTree:__tostring()
   720   return self.root:__tostring()
       end

       --@override
     1 function SyntaxTree:isWellFormed()
  1789   if not self.root then
    33     return false
  1756   elseif self.root.type == NodeType.TERMINAL then
   644     return true
         else
  1112     return self._.current:isWellFormed()
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Terminal.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local Node = require("dogma.syn._.Node")
     1 local NodeType = require("dogma.syn.NodeType")

       --A terminal node.
     1 local Terminal = {}
     1 Terminal.__index = Terminal
     1 setmetatable(Terminal, {__index = Node})
     1 package.loaded[...] = Terminal

       --Constructor.
       --
       --@param sub:TerminalTtype
       --@param tok:Token
     1 function Terminal.new(sub, tok)
         local self

         --(1) create
  1235   self = setmetatable(Node.new(NodeType.TERMINAL, tok), Terminal)
  1235   self.subtype = sub
  1235   self.data = tok.value

         --(2) return
  1235   return self
       end

       --@override
     1 function Terminal:__tostring()
  1003   return string.format("%s", self.data)
       end

       --Is it an identifier?
       --
       --@return bool
     1 function Terminal:isId()
    15   return self.token.type == TokenType.NAME
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ThrowFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A throw function.
     1 local ThrowFn = {}
     1 ThrowFn.__index = ThrowFn
     1 setmetatable(ThrowFn, {__index = Terminal})
     1 package.loaded[...] = ThrowFn

       --Constructor.
     1 function ThrowFn.new(ln, col, args)
         local self

         --(1) create
     6   self = setmetatable(Terminal.new(TerminalType.THROW, {line = ln, col = col}), ThrowFn)
     6   self.args = args

         --(2) return
     6   return self
       end

       --@override
     1 function ThrowFn:__tostring()
         local repr

         --(1) build
     3   repr = "(throw "

     9   for i, arg in ipairs(self.args) do
     6     repr = repr .. (i == 1 and "" or " ") .. tostring(arg)
         end

     3   repr = repr .. ")"

         --(2) return
     3   return repr
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/TypeStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A type statement.
     1 local TypeStmt = {}
     1 TypeStmt.__index = TypeStmt
     1 setmetatable(TypeStmt, {__index = ObjectStmt})
     1 package.loaded[...] = TypeStmt

       --Constructor.
     1 function TypeStmt.new(ln, col, annots, visib, name, params, btype, bargs, body, catch, fin)
         local self

         --(1) create
    14   self = setmetatable(ObjectStmt.new(StmtType.TYPE, ln, col, name, visib), TypeStmt)
    14   self.params = params
    14   self.base = btype
    14   self.bargs = bargs
    14   self.body = body
    14   self.catch = catch
    14   self.finally = fin
    14   self.annots = annots or {}

         --(2) return
    14   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UnaryOp.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local Op = require("dogma.syn._.Op")
     1 local NodeType = require("dogma.syn.NodeType")

       --Unary operator.
     1 local UnaryOp = {}
     1 UnaryOp.__index = UnaryOp
     1 setmetatable(UnaryOp, {__index = Op})
     1 package.loaded[...] = UnaryOp

       --Constructor.
       --
       --@param tok:Token
     1 function UnaryOp.new(tok)
         local self

         --(1) create
    32   self = setmetatable(Op.new("u", tok), UnaryOp)
    32   self.child = nil

         --(2) return
    32   return self
       end

       --@override
     1 function UnaryOp:insert(node)
         --(1) pre
    34   if tablex.find({".", ":"}, self.op) then
    15     if not (node.type == NodeType.TERMINAL and node:isId()) then
     2       error(string.format(
     1         "on (%s, %s), '.' and ':' must be followed by identifier.",
     1         node.token.line,
     1         node.token.col
     1       ))
           end
         end

         --(2) add
    33   self.child = node
    33   node.parent = self
       end

       --@override
     1 function UnaryOp:remove()
     2   local c = self.child
     2   self.child = nil
     2   return c
       end

       --@override
     1 function UnaryOp:isWellFormed()
    69   return not not self.child
       end

       --@override
     1 function UnaryOp:__tostring()
    18   return string.format("(%s %s)", self.op, self.child)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Unpack.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --An unpack sentence.
     1 local Unpack = {}
     1 Unpack.__index = Unpack
     1 setmetatable(Unpack, {__index = Sent})
     1 package.loaded[...] = Unpack

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param visib:string   Visibility: nil, export or pub.
       --@param def:string     Type definition: nil, var or const.
       --@param sub:string     Unpack type: [] or {}.
       --@param vars:array
       --@param assign:string  =, := or ?=.
       --@param exp:Exp
     1 function Unpack.new(ln, col, visib, def, sub, vars, assign, exp)
         local self

         --(1) create
    45   self = setmetatable(Sent.new(SentType.UNPACK, ln, col), Unpack)
    45   self.visib = visib
    45   self.def = def
    45   self.subtype = sub
    45   self.vars = vars
    45   self.assign = assign
    45   self.exp = exp

         --(2) return
    45   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --use statement.
     1 local UseStmt = {}
     1 UseStmt.__index = UseStmt
     1 setmetatable(UseStmt, {__index = Stmt})
     1 package.loaded[...] = UseStmt

       --Constructor.
     1 function UseStmt.new(ln, col)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.USE, ln, col), UseStmt)
    18   self.modules = {}

         --(2) return
    18   return self
       end

       --Add a module.
       --
       --@param mod:string   Module to use.
       --@param name?:string Variable module name.
     1 function UseStmt:insert(mod, name)
         --(1) set name if needed
    23   if not name then
    14     name = UseStmt.getNameFor(mod)
         end

         --(2) add module
    22   table.insert(self.modules, {name = name, path = mod})
       end

     1 function UseStmt.getNameFor(path)
    19   local NAME_PATTERN1 = "^[%a_][%w_]*$"
    19   local NAME_PATTERN2 = "^[%a_][%w_%-]*-([%a_][%w_]*)$"
    19   local Q_PATTERN1 = "^.*/([%a_][%w_]*)$"
    19   local Q_PATTERN2 = "^.*%.([%a_][%w_]*)$"
         local name

    19   if path:find(NAME_PATTERN1) then
    10     name = path
     9   elseif path:find(NAME_PATTERN2) then
     1     name = path:match(NAME_PATTERN2)
     8   elseif path:find(Q_PATTERN1) then
     6     name = path:match(Q_PATTERN1)
     2   elseif path:find(Q_PATTERN2) then
     1     name = path:match(Q_PATTERN2)
         else
     1     error(string.format("invalid module path format: '%s'.", path))
         end

    18   return name
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A var statement.
     1 local VarStmt = {}
     1 VarStmt.__index = VarStmt
     1 setmetatable(VarStmt, {__index = Stmt})
     1 package.loaded[...] = VarStmt

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param visib:string Visibility: export or pub.
     1 function VarStmt.new(ln, col, visib)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.VAR, ln, col), VarStmt)
    18   self.vars = {}
    18   self.visib = visib

         --(2) return
    18   return self
       end

       --Add a variable declaration.
       --
       --@param name:string  Variable name.
       --@param val?:Exp     Default value.
     1 function VarStmt:insert(name, val)
    22   table.insert(self.vars, {name = name, value = val})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WhileStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A while statement.
     1 local WhileStmt = {}
     1 WhileStmt.__index = WhileStmt
     1 setmetatable(WhileStmt, {__index = Stmt})
     1 package.loaded[...] = WhileStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param cond:Exp
       --@param iter?:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function WhileStmt.new(ln, col, cond, iter, body, catch, fin)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.WHILE, ln, col), WhileStmt)
    18   self.cond = cond
    18   self.iter = iter
    18   self.body = body
    18   self.catch = catch
    18   self.finally = fin

         --(2) return
    18   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WithStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --with statement.
     1 local WithStmt = {}
     1 WithStmt.__index = WithStmt
     1 setmetatable(WithStmt, {__index = Stmt})
     1 package.loaded[...] = WithStmt

       --Constructor.
     1 function WithStmt.new(ln, col, val, ifs, els)
         local self

         --(1) create
     7   self = setmetatable(Stmt.new(StmtType.WITH, ln, col), WithStmt)
     7   self.value = val
     7   self.ifs = ifs
     7   self.els = els

         --(2) return
     7   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/Trans.lua
==============================================================================
       --A transformer.
     1 local Trans = {}
     1 Trans.__index = Trans
     1 package.loaded[...] = Trans

       --Constructor.
     1 function Trans.new()
   508   return setmetatable({
   254     _ = {

   254     }
   508   }, Trans)
       end

       --Confirgue the transformer.
       --
       --@param parser:Parser  Parser to use.
     1 function Trans:transform(parser)
   253   self._.parser = parser
       end

       --Transform the next sentence or file from the parser configured previously.
       --
       --@abstract
       --@return string
     1 function Trans:next()
     1   error("abstract method.")
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/Trans.lua
==============================================================================
       --imports
     1 local Trans = require("dogma.trans.Trans")
     1 local DirectiveTrans = require("dogma.trans.js._.DirectiveTrans")
     1 local ExpTrans = require("dogma.trans.js._.ExpTrans")
     1 local StmtTrans = require("dogma.trans.js._.StmtTrans")
     1 local UnpackTrans = require("dogma.trans.js._.UnpackTrans")
     1 local SentType = require("dogma.syn.SentType")

       --internal data
       local PRE = [[
       import {any, bool, datetime, func, list, map, num, promise, proxy, text, abstract, coalesce, dogma, exec, fmt, keys, len, print, printf, todo, typename} from "dogmalang";
     1 ]]

       --A JavaScript transformer.
     1 local JsTrans = {}
     1 JsTrans.__index = JsTrans
     1 setmetatable(JsTrans, {__index = Trans})
     1 package.loaded[...] = JsTrans

       --Constructor.
     1 function JsTrans.new(opts)
         local self

         --(1) create
   253   self = setmetatable(Trans.new(opts), JsTrans)
   253   self._.directiveTrans = DirectiveTrans.new(self)
   253   self._.expTrans = ExpTrans.new(self)
   253   self._.stmtTrans = StmtTrans.new(self)
   253   self._.unpackTrans = UnpackTrans.new(self)

         --(2) return
   253   return self
       end

       --@override
     1 function JsTrans:next(opts)
   252   local parser = self._.parser
         local out

         --(1) arguments
   252   if not opts then
   250     opts = {}
         end

         --(2) transform
   252   local first = false

   252   out = ""
         while true do
           local sent

   505     sent = parser:next()

   505     if sent == nil then
             break
           end

   253     out = out .. self:_trans(sent, ";") .. "\n"

   253     if opts.importDogmalang then
     3       if not first then
     2         first = true

     2         if out:find("^#!/") then
     1           out = out .. PRE
               else
     1           out = PRE .. out
               end
             end
           end
         end

         --(2) return
   252   return out
       end

     1 function JsTrans:_trans(sent, eoe)
   445   if sent.type == SentType.DIRECTIVE then
    10     return self._.directiveTrans:transform(sent)
   435   elseif sent.type == SentType.EXP then
   284     return self._.expTrans:transform(sent) .. (eoe or "")
   151   elseif sent.type == SentType.STMT then
   121     return self._.stmtTrans:transform(sent)
    30   elseif sent.type == SentType.UNPACK then
    30     return self._.unpackTrans:transform(sent)
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/DirectiveTrans.lua
==============================================================================
       --imports
     1 local DirectiveType = require("dogma.syn.DirectiveType")
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --A directive transformer.
     1 local DirectiveTrans = {}
     1 DirectiveTrans.__index = DirectiveTrans
     1 setmetatable(DirectiveTrans, {__index = SubTrans})
     1 package.loaded[...] = DirectiveTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function DirectiveTrans.new(trans)
   253   return setmetatable(SubTrans.new(trans), DirectiveTrans)
       end

       --Transform a directive.
       --
       --@param dir:Directive  Directive to transform.
       --@return string
     1 function DirectiveTrans:transform(dir)
    10   if dir.subtype == DirectiveType.IF then
     8     return self:_transIf(dir)
     2   elseif dir.subtype == DirectiveType.RUNWITH then
     2     return self:_transRunWith(dir)
         end
       end

       --Transform an if directive.
       --
       --@return string
     1 function DirectiveTrans:_transIf(dir)
         local function transform(sents)
     6     local trans = self._.trans
           local code

     6     code = ""
    12     for _, sent in ipairs(sents) do
     6       code = code .. trans:_trans(sent)
           end

     6     return code
         end

         --(1) transform if
         local code

     8   if dir.cond == "js" or (dir.cond:find("^not") and dir.cond ~= "not js") then
     4     code = transform(dir.body)
     4   elseif dir.el then
     2     code = transform(dir.el)
         else
     2     code = ""
         end

         --(2) return
     8   return code
       end

       --Transform a runWith directive.
       --
       --@return string
     1 function DirectiveTrans:_transRunWith(dir)
     2   return "#!" .. dir.cmd
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/ExpTrans.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local NodeType = require("dogma.syn.NodeType")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")
     1 local transName = require("dogma.trans.js._.util").transName
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --An expression transformer to JavaScript.
     1 local ExpTrans = {}
     1 ExpTrans.__index = ExpTrans
     1 setmetatable(ExpTrans, {__index = SubTrans})
     1 package.loaded[...] = ExpTrans

       --Constructor.
     1 function ExpTrans.new(trans)
   253   return setmetatable(SubTrans.new(trans), ExpTrans)
       end

       --Transform an expression.
       --
       --@param exp:Exp      Expression to transform.
       --@return string
     1 function ExpTrans:transform(exp)
   303   return self:_transNode(exp.tree.root)
       end

       --Transform a node.
       --
       --@param node:Node
       --@return string
     1 function ExpTrans:_transNode(node)
   797   if node.type == NodeType.TERMINAL then
   542     return self:_transTerminal(node)
   255   elseif node.type == NodeType.NON_TERMINAL then
   255     return self:_transNonTerminal(node)
         end
       end

       --Transform a terminal node.
       --
       --@param node:Terminal
       --@return string
     1 function ExpTrans:_transTerminal(node)
   542   if node.subtype == TerminalType.NAME then
   296     return transName(node.data)
   246   elseif node.subtype == TerminalType.NUM then
   191     return tostring(node.data)
    55   elseif node.subtype == TerminalType.TEXT then
    14     return string.format([["%s"]], node.data)
    41   elseif node.subtype == TerminalType.TRUE then
    14     return "true"
    27   elseif node.subtype == TerminalType.FALSE then
     2     return "false"
    25   elseif node.subtype == TerminalType.NIL then
     1     return "null"
    24   elseif node.subtype == TerminalType.LIST then
     3     return self:_transLiteralList(node)
    21   elseif node.subtype == TerminalType.MAP then
     3     return self:_transLiteralMap(node)
    18   elseif node.subtype == TerminalType.SELF then
     1     return "this"
    17   elseif node.subtype == TerminalType.SUPER then
     1     return "super"
    16   elseif node.subtype == TerminalType.NOP then
     1     return "dogma.nop()"
    15   elseif node.subtype == TerminalType.FN then
     7     return self:_transLiteralFn(node)
     8   elseif node.subtype == TerminalType.SUBEXP then
     2     return self:transform(node.data)
     6   elseif node.subtype == TerminalType.NATIVE then
     1     return self:_transNativeFn(node)
     5   elseif node.subtype == TerminalType.PEVAL then
     1     return self:_transPevalFn(node)
     4   elseif node.subtype == TerminalType.THROW then
     3     return self:_transThrowFn(node)
     1   elseif node.subtype == TerminalType.IF then
     1     return self:_transIfSubExp(node)
         end
       end

       --Transform if Exp then Exp else Exp end
     1 function ExpTrans:_transIfSubExp(node)
     2   return string.format(
     1     "(%s ? %s : %s)",
     1     self:transform(node.cond),
     1     self:transform(node.trueCase),
     1     self:transform(node.falseCase)
     1   )
       end

       --Transform a native() function.
     1 function ExpTrans:_transNativeFn(fn)
     1   return string.format(fn.code)
       end

       --Transform a peval() function.
     1 function ExpTrans:_transPevalFn(fn)
     1   return string.format("dogma.peval(() => {return %s;})", self:transform(fn.exp))
       end

       --Transform a throw() function.
     1 function ExpTrans:_transThrowFn(fn)
         local code

         --(1) transform
     3   code = "dogma.raise("

     3   if #fn.args == 1 then
     1     code = code .. self:transform(fn.args[1])
         else
     7     for i, arg in ipairs(fn.args) do
     5       code = code .. (i == 1 and "" or ", ") .. self:transform(arg)
           end
         end

     3   code = code .. ")"

         --(2) return
     3   return code
       end

       --Transform a literal list.
     1 function ExpTrans:_transLiteralList(term)
         local code

         --(1) transform
     3   code = "["

     6   for ix, item in ipairs(term.data) do
     3     code = code .. (ix == 1 and "" or ", ") .. self:transform(item)
         end

     3   code = code .. "]"

         --(2) return
     3   return code
       end

       --Transform a literal map.
     1 function ExpTrans:_transLiteralMap(term)
         local code

         --(1) transform
     3   code = "{"

     7   for i, entry in ipairs(term.data) do
     8     code = code .. (i == 1 and "" or ", ") .. string.format(
     4       '["%s"]: %s',
     4       entry.name,
     4       self:transform(entry.value)
           )
         end

     3   code = code .. "}"

         --(2) return
     3   return code
       end

       --Transform a literal function.
     1 function ExpTrans:_transLiteralFn(term)
     7   local strans = self._.trans._.stmtTrans

    14   return string.format(
     7     "(%s) => { %s%s%s%s }",
     7     strans:_transParams(term.data.params),
     7     strans:_transReturnVar(term.data),
     7     strans:_transParamsCheck(term.data.params),
     7     strans:_transBody(term.data.body),
     7     term.data.rvar and string.format(" return %s;", term.data.rvar == "self" and "this" or term.data.rvar) or ""
    13   )
       end

       --Transform a non-terminal node.
       --
       --@param node:NonTerminal
       --@return string
     1 function ExpTrans:_transNonTerminal(node)
   255   if node.subtype == NonTerminalType.OP then
   255     return self:_transOp(node)
         end
       end

       --Transform an operator node.
       --
       --@param node:Op
       --@return string
     1 function ExpTrans:_transOp(node)
   255   if node.arity == "u" then
    10     return self:_transUnaryOp(node)
   245   elseif node.arity == "b" then
   223     return self:_transBinOp(node)
    22   elseif node.arity == "t" then
     2     return self:_transTernaryOp(node)
    20   elseif node.arity == "n" then
    20     return self:_transNaryOp(node)
         end
       end

     1 function ExpTrans:_transUnaryOp(node)
    10   if node.op == "." then
     3     return "this." .. node.child.data
     7   elseif node.op == ":" then
     1     return "this._" .. node.child.data
     6   elseif node.op == "not" or node.op == "!" then
     2     return string.format("!(%s)", self:_transNode(node.child))
     4   elseif node.op == "~" then
     1     return string.format("~(%s)", self:_transNode(node.child))
     3   elseif node.op == "+" then
     1     return string.format("+(%s)", self:_transNode(node.child))
     2   elseif node.op == "-" then
     1     return string.format("-(%s)", self:_transNode(node.child))
     1   elseif node.op == "..." then
     1     return string.format("...(%s)", self:_transNode(node.child))
         end
       end

     1 function ExpTrans:_transBinOp(node)
   223   local left, right = node.children[1], node.children[2]

   223   if tablex.find({"+", "-", "*", "**", "/", "%", "==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", "||", "&&"}, node.op) then
   152     return "(" .. self:_transNode(left) .. node.op .. self:_transNode(right) .. ")"
    71   elseif tablex.find({"=", "+=", "-=", "*=", "**=", "/=", "%=", "<<=", ">>=", "|=", "&=", "^="}, node.op) then
    28     return self:_transAssign(node)
    43   elseif node.op == "=~" then
     1     return self:_transEnumEq(node)
    42   elseif node.op == "!~" then
     1     return self:_transEnumNe(node)
    41   elseif node.op == "?=" then
     4     return self:_transCondAssign(node)
    37   elseif node.op == ".=" then
     1     return self:_transAssignWithPubProp(node)
    36   elseif node.op == ":=" then
     5     return self:_transConstAssign(node)
    31   elseif node.op == "and" then
     1     return "(" .. self:_transNode(left) .. "&&" .. self:_transNode(right) .. ")"
    30   elseif node.op == "or" then
     1     return "(" .. self:_transNode(left) .. "||" .. self:_transNode(right) .. ")"
    29   elseif node.op == "." then
    14     return self:_transNode(left) .. "." .. self:_transNode(right)
    15   elseif node.op == ":" then
     6     return self:_transNode(left) .. "._" .. right.data
     9   elseif node.op == "is" then
     1     return string.format("dogma.is(%s, %s)", self:_transNode(left), self:_transNode(right))
     8   elseif node.op == "isnot" then
     1     return string.format("dogma.isNot(%s, %s)", self:_transNode(left), self:_transNode(right))
     7   elseif node.op == "in" then
     1     return string.format("(%s).includes(%s)", self:_transNode(right), self:_transNode(left))
     6   elseif node.op == "notin" then
     1     return string.format("!(%s).includes(%s)", self:_transNode(right), self:_transNode(left))
     5   elseif node.op == "like" then
     1     return string.format("dogma.like(%s, %s)", self:_transNode(left), self:_transNode(right))
     4   elseif node.op == "notlike" then
     1     return string.format("dogma.notLike(%s, %s)", self:_transNode(left), self:_transNode(right))
     3   elseif node.op == "[]" then
     3     return string.format("dogma.getItem(%s, %s)", self:_transNode(left), self:_transNode(right))
         end
       end

     1 function ExpTrans:_transEnumEq(op)
     2   return string.format(
     1     'dogma.enumEq(%s, "%s")',
     1     self:_transNode(op.children[1]),
     1     self:_transNode(op.children[2])
     1   )
       end

     1 function ExpTrans:_transEnumNe(op)
     2   return string.format(
     1     '(!dogma.enumEq(%s, "%s"))',
     1     self:_transNode(op.children[1]),
     1     self:_transNode(op.children[2])
     1   )
       end

     1 function ExpTrans:_transCondAssign(op)
     4   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     4   if left.arity == "b" and left.op == "[]" then
     2     code = string.format(
     1       'dogma.setItem("=", %s, %s, coalesce(dogma.getItem(%s, %s), %s))',
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         else
     6     code = string.format(
     3       "(%s = coalesce(%s, %s))",
     3       self:_transNode(left),
     3       self:_transNode(left),
     3       self:_transNode(right)
     3     )
         end

         --(2) return
     4   return code
       end

     1 function ExpTrans:_transAssign(op)
    28   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
    28   if left.op == "[]" then
     2     code = string.format(
     1       [[dogma.setItem("%s", %s, %s, %s)]],
     1       op.op,
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         else
    27     code = string.format("(%s%s%s)", self:_transNode(left), op.op, self:_transNode(right))
         end

         --(2) return
    28   return code
       end

     1 function ExpTrans:_transConstAssign(op)
     5   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     5   if left.arity == "u" and left.op == "." then
     2     code = string.format(
     1       [[Object.defineProperty(this, "%s", {value: %s, enum: true})]],
     1       self:_transNode(left.child),
     1       self:_transNode(right)
     1     )
     4   elseif left.arity == "b" and left.op == "." then
     2     code = string.format(
     1       [[Object.defineProperty(%s, "%s", {value: %s, enum: true})]],
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
     3   elseif left.op == ":" then
     2     if left.arity == "u" then
     2       code = string.format(
     1         [[Object.defineProperty(this, "_%s", {value: %s})]],
     1         left.child.data,
     1         self:_transNode(right)
     1       )
           else
     2       code = string.format(
     1         [[Object.defineProperty(%s, "_%s", {value: %s})]],
     1         self:_transNode(left.children[1]),
     1         left.children[2].data,
     1         self:_transNode(right)
     1       )
           end
     1   elseif left.op == "[]" then
     2     code = string.format(
     1       [[dogma.setItem("=", %s, %s, %s)]],
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         end

         --(2) return
     5   return code
       end

     1 function ExpTrans:_transAssignWithPubProp(op)
     1   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     1   if left.arity == "u" then
     2     code = string.format(
     1       'Object.defineProperty(this, "_%s", {value: %s, writable: true});',
     1       left.child.data,
     1       self:_transNode(right)
     1     )

     2     code = code .. string.format(
     1       'Object.defineProperty(this, "%s", {enum: true, get() { return this._%s; }})',
     1       left.child.data,
     1       left.child.data
     1     )
         end

         --(2) return
     1   return code
       end

     1 function ExpTrans:_transTernaryOp(op)
     2   if op.op == "[]" then
     4     return string.format(
     2       "dogma.getSlice(%s, %s, %s)",
     2       self:_transNode(op.children[1]),
     2       self:_transNode(op.children[2]),
     2       self:_transNode(op.children[3])
     2     )
         end
       end

     1 function ExpTrans:_transNaryOp(node)
    20   if node.op == "()" then
    16     return self:_transCallOp(node)
     4   elseif node.op == "{}" then
     4     return self:_transPackOp(node)
         end
       end

     1 function ExpTrans:_transCallOp(node)
         local code

    16   code = self:_transNode(node.children[1]) .. "("
    47   for i, arg in ipairs(node.children) do
    31     if i > 1 then
    15       code = code .. (i == 2 and "" or ", ") .. self:_transNode(arg.tree.root)
           end
         end
    16   code = code .. ")"

    16   return code
       end

     1 function ExpTrans:_transPackOp(node)
         local code

         --(1) transform
     4   if #node.children == 2 and node.children[2].name == "*" then
     1     code = string.format("dogma.clone(%s)", self:_transNode(node.children[1]))
         else
     3     code = "dogma.pack("

    10     for i, item in ipairs(node.children) do
     7       if i == 1 then
     3         code = code .. self:_transNode(item)
             else
     4         code = code .. string.format(', "%s%s"', item.visib == "." and "" or "_", item.name)
             end
           end

     3     code = code .. ")"
         end

         --(2) return
     4   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/StmtTrans.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local StmtType = require("dogma.syn.StmtType")
     1 local transName = require("dogma.trans.js._.util").transName
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --A statement transformer.
     1 local StmtTrans = {}
     1 StmtTrans.__index = StmtTrans
     1 setmetatable(StmtTrans, {__index = SubTrans})
     1 package.loaded[...] = StmtTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function StmtTrans.new(trans)
   253   return setmetatable(SubTrans.new(trans), StmtTrans)
       end

       --Transform a statement.
       --
       --@param stmt:Stmt  Statement to transform.
       --@return string
     1 function StmtTrans:transform(stmt)
   121   if stmt.subtype == StmtType.ASYNC then
     4     return self:_transAsync(stmt)
   117   elseif stmt.subtype == StmtType.BREAK then
     1     return self:_transBreak(stmt)
   116   elseif stmt.subtype == StmtType.CONST then
     5     return self:_transConst(stmt)
   111   elseif stmt.subtype == StmtType.DO then
     5     return self:_transDo(stmt)
   106   elseif stmt.subtype == StmtType.ENUM then
     4     return self:_transEnum(stmt)
   102   elseif stmt.subtype == StmtType.EXPORT then
     1     return self:_transExport(stmt)
   101   elseif stmt.subtype == StmtType.FN then
    36     return self:_transFn(stmt)
    65   elseif stmt.subtype == StmtType.FOR then
     7     return self:_transFor(stmt)
    58   elseif stmt.subtype == StmtType.FOR_EACH then
     5     return self:_transForEach(stmt)
    53   elseif stmt.subtype == StmtType.FROM then
     4     return self:_transFrom(stmt)
    49   elseif stmt.subtype == StmtType.IF then
     6     return self:_transIf(stmt)
    43   elseif stmt.subtype == StmtType.NEXT then
     1     return self:_transNext(stmt)
    42   elseif stmt.subtype == StmtType.PUB then
     3     return self:_transPub(stmt)
    39   elseif stmt.subtype == StmtType.RETURN then
    14     return self:_transReturn(stmt)
    25   elseif stmt.subtype == StmtType.TYPE then
     7     return self:_transType(stmt)
    18   elseif stmt.subtype == StmtType.USE then
     4     return self:_transUse(stmt)
    14   elseif stmt.subtype == StmtType.VAR then
     7     return self:_transVar(stmt)
     7   elseif stmt.subtype == StmtType.WHILE then
     6     return self:_transWhile(stmt)
     1   elseif stmt.subtype == StmtType.WITH then
     1     return self:_transWith(stmt)
         end
       end

       --Transform a use statement.
       --
       --@return string
     1 function StmtTrans:_transUse(stmt)
         local code

         --(1) transform
     6   code = ""

    14   for _, mod in ipairs(stmt.modules) do
     8     code = code .. string.format('const %s = require("%s").default || require("%s");', mod.name, mod.path, mod.path)
         end

         --(2) return
     6   return code
       end

       --Transform a from statement.
       --
       --@return string
     1 function StmtTrans:_transFrom(stmt)
         local code

         --(1) transform
     4   code = "import {"

    10   for i, mem in ipairs(stmt.members) do
     6     code = code .. (i == 1 and "" or ", ")

     6     if mem.name == mem.as then
     3       code = code .. mem.name
           else
     3       code = code .. string.format("%s as %s", mem.name, mem.as)
           end
         end

     4   code = code .. [[} from "]] .. stmt.module .. [[";]]

         --(2) return
     4   return code
       end

       --Transform a break statement.
       --
       --@return string
     1 function StmtTrans:_transBreak(stmt)
     1   return "break;"
       end

       --Transform a next statement.
       --
       --@return string
     1 function StmtTrans:_transNext(stmt)
     1   return "continue;"
       end

       --Transform an enum statement.
       --
       --@return string
     1 function StmtTrans:_transEnum(enum)
         local code

         --(1) transform
     8   code = string.format([[
       %sclass %s {
         constructor(name, val) {
           Object.defineProperty(this, "name", {value: name, enum: true});
           Object.defineProperty(this, "value", {value: val, enum: true});
         }
       }
     4 ]],
     4     self:_transVisib(enum.visib),
           enum.name
     8   )

    12   for _, item in ipairs(enum.items) do
    16     code = code .. string.format(
     8       [[Object.defineProperty(%s, "%s", {value: new %s("%s", %s), enum: true});]] .. "\n",
     8       enum.name,
     8       item.name,
     8       enum.name,
     8       item.name,
     8       (type(item.value) == "string" and string.format([["%s"]], item.value) or item.value)
           )
         end

         --(2) return
     4   return code
       end

     1 function StmtTrans:_transVisib(visib)
    30   if visib == "export" then
     4     return "export default "
    26   elseif visib == "pub" then
     4     return "export "
         else
    22     return ""
         end
       end

       --Transform an async statement.
       --
       --@param node
       --@return string
     1 function StmtTrans:_transAsync(node)
     4   local trans = self._.trans
         local code

         --(1) get sentences to run
     4   if node.catch then
     2     code = "try "
         else
     2     code = ""
         end

     4   code = code .. self:_transBody(node.body)
     4   code = code .. self:_transCatch(node.catch)

         --(2) return
     4   if node.opts.delay then
     1     return string.format("setTimeout(() => %s, %s);", code, trans:_trans(node.opts.delay))
         else
     3     return string.format("setImmediate(() => %s);", code)
         end
       end

       --Transform a var statement.
       --
       --@return string
     1 function StmtTrans:_transVar(stmt)
         local code

         --(1) transform
     7   if #stmt.vars > 0 then
     6     if stmt.visib then
     2       code = "var "
           else
     4       code = "let "
           end

    14     for i, var in ipairs(stmt.vars) do
     8       code = code .. (i == 1 and "" or ", ") .. var.name

     8       if var.value then
     5         code = code .. " = " .. self._.trans:_trans(var.value)
             end
           end

     6     code = code .. ";"

     6     if stmt.visib then
     4       for _, var in ipairs(stmt.vars) do
     2         code = code .. self:_transVisib(stmt.visib) .. var.name .. ";"
             end
           end
         else
     1     code = ""
         end

         --(2) return
     7   return code
       end

       --Transform a const statement.
       --
       --@return string
     1 function StmtTrans:_transConst(stmt)
         local code

         --(1) transform
     5   if #stmt.vars > 0 then
     4     code = "const "

     9     for i, var in ipairs(stmt.vars) do
     5       code = code .. (i == 1 and "" or ", ") ..
     5              var.name .. " = " .. self._.trans:_trans(var.value)
           end

     4     code = code .. ";"

     4     if stmt.visib then
     4       for _, var in ipairs(stmt.vars) do
     2         code = code .. self:_transVisib(stmt.visib) .. var.name .. ";"
             end
           end
         else
     1     code = ""
         end

         --(2) return
     5   return code
       end

       --Transform an while statement.
       --
       --@return string
     1 function StmtTrans:_transWhile(node)
     6   local trans = self._.trans
         local code

         --(1) transform
     6   if node.iter then
     2     code = string.format(
     1       "for (; %s; %s) ",
     1       trans:_trans(node.cond),
     1       trans:_trans(node.iter)
     1     )
         else
     5     code = string.format("while (%s) ", trans:_trans(node.cond))
         end

     6   if node.catch or node.finally then
     3     code = code .. "try "
         end

     6   code = code .. self:_transBody(node.body)
     6   code = code .. self:_transCatch(node.catch)
     6   code = code .. self:_transFinally(node.finally)

         --(2) return
     6   return code
       end

       --Transform a statement body.
       --
       --2return string
     1 function StmtTrans:_transBody(body)
    90   local trans = self._.trans
         local code

         --(1) transform
    90   code = "{"

   155   for _, sent in ipairs(body) do
    65     code = code .. trans:_trans(sent, ";")
         end

    90   code = code .. "}"

         --(2) return
    90   return code
       end

       --Transform a catch clause.
       --
       --@return string
     1 function StmtTrans:_transCatch(catch)
    68   local trans = self._.trans
         local code

         --(1) transform
    68   if catch then
    10     code = string.format(" catch(%s) {", catch.var or "_")

    20     for _, sent in ipairs(catch.body) do
    10       code = code .. trans:_trans(sent, ";")
           end

    10     code = code .. "}"
         end

         --(2) return
    68   return code or ""
       end

       --Transform a finally clause.
       --
       --@return string
     1 function StmtTrans:_transFinally(fin)
    64   local trans = self._.trans
         local code

         --(1) transform
    64   if fin then
     7     code = " finally {"

    14     for _, sent in ipairs(fin.body) do
     7       code = code .. trans:_trans(sent, ";")
           end

     7     code = code .. "}"
         end

         --(2) return
    64   return code or ""
       end

       --Transform a do statement.
       --
       --@return string
     1 function StmtTrans:_transDo(node)
     5   local trans = self._.trans
         local code

         --(1) transform
     5   if node.catch or node.finally then
     4     if node.cond then
     1       code = "do try "
           else
     3       code = "try "
           end
         else
     1     code = "do "
         end

     5   code = code .. self:_transBody(node.body)
     5   code = code .. self:_transCatch(node.catch)
     5   code = code .. self:_transFinally(node.finally)

     5   if node.cond then
     2     code = code .. string.format(" while (%s);", trans:_trans(node.cond))
         end

         --(2) return
     5   return code
       end

       --Transfor a for statement.
       --
       --@return string
     1 function StmtTrans:_transFor(stmt)
     7   local trans = self._.trans
         local code

         --(1) transform
     7   code = "for (let "

    17   for i, var in ipairs(stmt.def) do
    10     code = code .. (i == 1 and "" or ", ") .. var.name

    10     if var.value then
     6       code = code .. " = " .. trans:_trans(var.value)
           end
         end

     7   code = code .. "; " .. trans:_trans(stmt.cond) .. "; "

     7   if stmt.iter then
     3     code = code .. trans:_trans(stmt.iter)
         end

     7   code = code .. ") "

     7   if stmt.catch or stmt.finally then
     1     code = code .. "try "
         end

     7   code = code .. self:_transBody(stmt.body)
     7   code = code .. self:_transCatch(stmt.catch)
     7   code = code .. self:_transFinally(stmt.finally)

         --(2) return
     7   return code
       end

       --Transform a for each statement.
       --
       --@return string
     1 function StmtTrans:_transForEach(node)
     5   local trans = self._.trans
         local code

         --(1) transform
     5   if node.key then
     1     local iter = self:_getRandomName()

     2     code = string.format(
     1       "const %s = %s; for (let %s in %s) { let %s = %s[%s]; ",
     1       iter,
     1       trans:_trans(node.iter),
     1       node.key,
     1       iter,
     1       node.value,
     1       iter,
             node.key
     2     )
         else
     8     code = string.format(
     4       "for (let %s of %s) ",
     4       node.value,
     4       trans:_trans(node.iter)
     4     )
         end

     5   if node.catch or node.finally then
     3     code = code .. "try "
         end

     5   code = code .. self:_transBody(node.body)
     5   code = code .. self:_transCatch(node.catch)
     5   code = code .. self:_transFinally(node.finally)

     5   if node.key then
     1     code = code .. " }"
         end

         --(2) return
     5   return code
       end

       --Transform a return statement.
       --
       --@return string
     1 function StmtTrans:_transReturn(node)
    14   local trans = self._.trans
         local code

         --(1) transform
    14   code = "return"

    14   if #node.values == 1 then
    13     code = code .. " " .. trans:_trans(node.values[1])
         end

    14   code = code .. ";"

         --(2) return
    14   return code
       end

       --Transform a type statement.
       --
       --@return string
     1 function StmtTrans:_transType(stmt)
         local code

         --(1) transform
         --$class
     7   code = string.format("const $%s = class %s", stmt.name, stmt.name)
     7   if stmt.base then
     3     code = code .. " extends " .. stmt.base
         end

     7   code = code .. " {\n"

     7   code = code .. string.format("  constructor(%s) { ", self:_transParams(stmt.params))
     7   code = code .. self:_transParamsCheck(stmt.params)
     7   code = code .. self:_transSuperConstructor(stmt.bargs)
     7   code = code .. self:_transSelfParams(stmt.params)
     7   if stmt.catch or stmt.finally then code = code .. " try " end
     7   code = code .. self:_transBody(stmt.body)
     7   code = code .. self:_transCatch(stmt.catch)
     7   code = code .. self:_transFinally(stmt.finally)
     7   code = code .. "  }\n"
     7   code = code .. "};\n"

         --class proxy
    14   code = code .. string.format(
     7     "const %s = new Proxy($%s, { apply(receiver, self, args) { return new $%s(...args); } });",
     7     stmt.name,
     7     stmt.name,
           stmt.name
     7   )

     7   if stmt.visib == "export" then
     1     code = code .. string.format("export default %s;", stmt.name)
         end

         --(2) return
     7   return code
       end

       --Transform function parameters.
       --
       --@return string
     1 function StmtTrans:_transParams(params)
    45   local trans = self._.trans
         local code

         --(1) transform
    45   if #params > 0 then
    30     code = ""

    72     for i, p in ipairs(params) do
    42       if i > 1 then
    12         code = code .. ", "
             end

    42       if p.modifier == "..." then
     1         code = code .. "..."
             end

    42       code = code .. transName(p.name)

    42       if p.value then
     1         code = code .. " = " .. trans:_trans(p.value)
             end
           end
         end

         --(2) return
    45   return code or ""
       end

       --Return the code for checking the function parameters.
       --
       --@return string
     1 function StmtTrans:_transParamsCheck(params)
         local function toJs(obj)
           local repr

     3     repr = "{"
     7     for ix, val in ipairs(obj) do
     4       repr = repr .. (ix == 1 and "" or ", ") .. val.name .. ": " .. val.type
           end
     3     repr = repr .. "}"

     3     return repr
         end

         local code

         --(1) transform
    45   if #params > 0 then
    30     code = ""

    72     for _, p in ipairs(params) do
    42       if not p.optional and p.modifier ~= "..." then  --mandatory parameter with(out) type check
    25         if type(p.type) == "table" then
     4           code = code .. string.format(
     2             [[dogma.paramExpectedToHave("%s", %s, %s);]],
     2             transName(p.name),
     2             transName(p.name),
     2             toJs(p.type)
     2           )
               else
    46           code = code .. string.format(
    23             [[dogma.paramExpected("%s", %s, %s);]],
    23             transName(p.name),
    23             transName(p.name),
    23             p.type or "null"
    21           )
               end
    17       elseif p.type then  --optional parameter with type check
     3         if type(p.type) == "table" then
     2           code = code .. string.format(
     1             [[dogma.paramExpectedToHave("%s", %s, %s);]],
     1             transName(p.name),
     1             transName(p.name),
     1             toJs(p.type)
     1           )
               else
     4           code = code .. string.format(
     2             [[dogma.paramExpectedToBe("%s", %s, %s);]],
     2             transName(p.name),
     2             transName(p.name),
                   p.type
     2           )
               end
             end
           end
         end

         --(2) return
    45   return code or ""
       end

       --Return the code for setting . or : attributes from parameters.
       --
       --@return string
     1 function StmtTrans:_transSelfParams(params)
         local code

         --(1) transform
    38   if #params > 0 then
    24     code = ""

    59     for _, p in ipairs(params) do
    35       if p.modifier == "." then
    18         code = code .. string.format(
     9           [[Object.defineProperty(this, "%s", {value: %s, enum: true, writable: %s});]],
     9           transName(p.name),
     9           transName(p.name),
     9           not p.const
     9         )
    26       elseif p.modifier == ":" then
     2         code = code .. string.format(
     1           [[Object.defineProperty(this, "_%s", {value: %s, writable: %s});]],
     1           p.name,
     1           p.name,
     1           not p.const
               )
             end
           end
         end

         --(2) return
    38   return code or ""
       end

       --Return a call to the super constructor.
       --
       --@return string
     1 function StmtTrans:_transSuperConstructor(bargs)
     7   local trans = self._.trans
         local code

         --(1) Transform
     7   if bargs then
     2     if #bargs == 0 then
     1       code = "super();"
           else
     1       code = "super("

     3       for i, a in ipairs(bargs) do
     2         code = code .. (i == 1 and "" or ", ") .. trans:_trans(a)
             end

     1       code =  code .. ");"
           end
         end

         --(2) return
     7   return code or ""
       end

       --Transform a fn statement.
       --
       --@return string
     1 function StmtTrans:_transFn(stmt)
    36   if stmt.itype then
    14     return self:_transTypeFn(stmt)
         else
    22     return self:_transStdFn(stmt)
         end
       end

     1 function StmtTrans:_transStdFn(fn)
         local code

         --(1) transform
    44   code = string.format(
    22     "%sfunction %s(%s) { ",
    22     self:_transVisib(fn.visib),
    22     fn.name,
    22     self:_transParams(fn.params)
    22   )

    22   code = code .. self:_transReturnVar(fn)
    22   code = code .. self:_transParamsCheck(fn.params)
    22   code = code .. self:_transSelfParams(fn.params)
    22   if fn.catch or fn.finally then code = code .. " try " end
    22   code = code .. self:_transBody(fn.body)
    22   code = code .. self:_transCatch(fn.catch)
    22   code = code .. self:_transFinally(fn.finally)
    22   if fn.rvar then
     6     code = code .. string.format(" return %s;", fn.rvar == "self" and "this" or fn.rvar)
         end
    22   code = code .. " }"

         --(2) return
    22   return code
       end

     1 function StmtTrans:_transTypeFn(stmt)
    14   if tablex.find(stmt.annots, "prop") then
     4     return self:_transProp(stmt)
         else
    10     return self:_transMethod(stmt)
         end
       end

     1 function StmtTrans:_transProp(stmt)
         local code

         --(1) transform
     8   code = string.format(
     4     [[Object.defineProperty(%s.prototype, "%s%s", {enum: %s, get: function() { ]],
     4     stmt.itype,
     4     stmt.visib == "pub" and "" or "_",
     4     stmt.name,
     4     stmt.visib == "pub"
     8   )

     4   if tablex.find(stmt.annots, "abstract") then
     1     code = code .. "abstract();"
         else
     3     code = code .. self:_transReturnVar(stmt)
     3     if stmt.catch or stmt.finally then code = code .. " try " end
     3     code = code .. self:_transBody(stmt.body)
     3     code = code .. self:_transCatch(stmt.catch)
     3     code = code .. self:_transFinally(stmt.finally)

     3     if stmt.rvar then
     1       code = code .. string.format(" return %s;", stmt.rvar == "self" and "this" or stmt.rvar)
           end
         end

     4   code = code .. " }});"

         --(2) return
     4   return code
       end

     1 function StmtTrans:_transMethod(stmt)
         local code

         --(1) transform
    10   if tablex.find(stmt.annots, "abstract") then
     2     code = string.format(
     1       "%s.prototype.%s%s = function() { abstract(); };",
     1       stmt.itype,
     1       stmt.visib == "pub" and "" or "_",
             stmt.name
     2     )
         else
     9     if tablex.find(stmt.annots, "static") then
     2       code = string.format(
     1         "%s.%s%s = function(%s) { ",
     1         stmt.itype,
     1         stmt.visib == "pub" and "" or "_",
     1         stmt.name,
     1         self:_transParams(stmt.params)
     1       )
           else
    16       code = string.format(
     8         "%s.prototype.%s%s = function(%s) { ",
     8         stmt.itype,
     8         stmt.visib == "pub" and "" or "_",
     8         stmt.name,
     8         self:_transParams(stmt.params)
     8       )
           end

     9     code = code .. self:_transReturnVar(stmt)
     9     code = code .. self:_transParamsCheck(stmt.params)
     9     code = code .. self:_transSelfParams(stmt.params)

     9     if stmt.catch or stmt.finally then code = code .. " try " end
     9     code = code .. self:_transBody(stmt.body)
     9     code = code .. self:_transCatch(stmt.catch)
     9     code = code .. self:_transFinally(stmt.finally)

     9     if stmt.rvar then
     2       code = code .. string.format(" return %s;", stmt.rvar == "self" and "this" or stmt.rvar)
           end

     9     code = code .. " };"
         end

         --(2) return
    10   return code
       end

     1 function StmtTrans:_transReturnVar(fn)
         local code

         --(1) transform
    41   code = ""

    41   if fn.rvar then
    10     if fn.rvar ~= "self" and not fn.params:has(fn.rvar) then
     6       if fn.rtype == "map" then
     1         code = string.format("let %s = {};", fn.rvar)
     5       elseif fn.rtype == "list" then
     1         code = string.format("let %s = [];", fn.rvar)
             else
     4         code = string.format("let %s;", fn.rvar)
             end
           end
         end

         --(2) return
    41   return code
       end

       --Transform an if statement.
       --
       --@return string
     1 function StmtTrans:_transIf(stmt)
     6   local trans = self._.trans
         local code

         --(1) transform
    12   code = string.format(
     6     "if (%s) %s",
     6     trans:_trans(stmt.cond),
     6     self:_transBody(stmt.body)
     6   )

     6   if stmt.elif then
     5     for _, cl in ipairs(stmt.elif) do
     6       code = code .. string.format(
     3         " else if (%s) %s",
     3         trans:_trans(cl.cond),
     3         self:_transBody(cl.body)
             )
           end
         end

     6   if stmt.el then
     3     code = code .. " else " .. self:_transBody(stmt.el)
         end

         --(2) return
     6   return code
       end

       --Transform a pub statement.
       --
       --@return string
     1 function StmtTrans:_transPub(stmt)
         local code

         --(1) transform
     3   code = ""

     7   for _, item in ipairs(stmt.items) do
     4     if item.type == "pub" then
     2       code = code .. string.format("export {%s};", item.value)
           else
     2       code = code .. self:_transUse({modules = {item.value}})
     2       code = code .. string.format("export {%s};", item.value.name)
           end
         end

         --(2) return
     3   return code
       end

       --Transform an export statement.
       --
       --@return string
     1 function StmtTrans:_transExport(stmt)
     1   local trans = self._.trans
         local code

         --(1) transform
     1   code = "export default " .. trans:_trans(stmt.exp) .. ";"

         --(2) return
     1   return code
       end

       --Transform a with statement.
       --
       --@return string
     1 function StmtTrans:_transWith(stmt)
     1   local trans = self._.trans
         local var, code

         --(1) transform
     1   var = self:_getRandomName()

     1   code = string.format("const %s = %s;", var, trans:_trans(stmt.value))

     3   for ix, cls in ipairs(stmt.ifs) do
     4     code = code .. string.format(
     2       "%sif (%s == %s) %s",
     2       ix == 1 and "" or " else ",
     2       var,
     2       trans:_trans(cls.cond),
     2       self:_transBody(cls.body)
           )
         end

     1   if stmt.els then
     1     code = code .. " else " .. self:_transBody(stmt.els)
         end

         --(2) return
     1   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/SubTrans.lua
==============================================================================
       --A sub transformer.
     1 local SubTrans = {}
     1 SubTrans.__index = SubTrans
     1 package.loaded[...] = SubTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function SubTrans.new(trans)
  2024   return setmetatable({
  1012     _ = {
  1012       trans = trans
  1012     }
  2024   }, SubTrans)
       end

       --Last seed used.
     1 local lastSeed = os.time()

       --Return a random name.
       --
       --@return string
     1 function SubTrans._getRandomName()
     8   lastSeed = math.random(1, lastSeed)
     8   math.randomseed(lastSeed)
     8   return "$aux" .. os.time() .. math.random(1, 10000)
       end

       --Transform a data access.
       --
       --@param def:DataAccess
       --@return string, string
     1 function SubTrans:_transDataAccess(def)
         local prefix

    45   if def.mod == "." then
     3     prefix = "this."
    42   elseif def.mod == ":" then
     3     prefix = "this._"
         else
    39     prefix = ""
         end

    45   return prefix .. def.name:gsub(":", "._")
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/UnpackTrans.lua
==============================================================================
       --imports
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --An unpack sentence transformer.
     1 local UnpackTrans = {}
     1 UnpackTrans.__index = UnpackTrans
     1 setmetatable(UnpackTrans, {__index = SubTrans})
     1 package.loaded[...] = UnpackTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function UnpackTrans.new(trans)
   253   return setmetatable(SubTrans.new(trans), UnpackTrans)
       end

       --Transform an unpack sentence.
       --
       --@param sent:Unpack  Sentence to transform.
       --@return string
     1 function UnpackTrans:transform(sent)
    30   if sent.subtype == "[]" then
    19     if sent.assign == "=" then
    14       return self:_transList(sent)
     5     elseif sent.assign == ":=" then
     1       return self:_transReadOnlyFieldsList(sent)
     4     elseif sent.assign == ".=" then
     3       return self:_transPropList(sent)
           else
     1       return self:_transOptionalList(sent)
           end
    11   elseif sent.subtype == "{}" then
    11     if sent.assign == "=" then
    10       return self:_transMap(sent)
           else
     1       return self:_transReadOnlyFieldsMap(sent)
           end
         end
       end

       --Transform [...] = Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transList(sent)
    14   local trans = self._.trans
         local code

         --(1) visibility?
    14   if sent.visib == nil then
    10     code = ""
     4   elseif sent.visib == "export" then
     2     code = "export default "
     2   elseif sent.visib == "pub" then
     2     code = "export "
         end

         --(2) var or const definition?
    14   if sent.def == "var" then
     6     code = code .. "let "
     8   elseif sent.def == "const" then
     3     code = code .. "const "
         end

         --(3) variables
    14   code = code .. "["

    45   for i, def in ipairs(sent.vars) do
    31     local var = self:_transDataAccess(def)

    62     code = code .. (i == 1 and "" or ", ") .. string.format(
    31       "%s%s%s",
    31       def.mod == "..." and "..." or "",
    31       var,
    31       def.value and (" = " .. trans:_trans(def.value)) or ""
    29     )
         end

    14   code = code .. "]"

         --(4) expression
    28   code = code .. string.format(
    14     " = dogma.getArrayToUnpack(%s, %s);",
    14     trans:_trans(sent.exp),
    14     #sent.vars
         )

         --(5) return
    14   return code
       end

       --Transform [...] := Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transReadOnlyFieldsList(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     2   code = string.format(
     1     "const %s = dogma.getArrayToUnpack(%s, %s);",
     1     valVar,
     1     trans:_trans(sent.exp),
     1     #sent.vars
     1   )

         --(2) unpack
     6   for ix, fld in ipairs(sent.vars) do
     5     local name = fld.name:gsub(":", "._")

     5     if fld.mod == "." then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "%s", {value: %s[%s], enum: true});',
     1         name,
     1         valVar,
     1         ix - 1
     1       )
     4     elseif fld.mod == ":" then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "_%s", {value: %s[%s]});',
     1         name,
     1         valVar,
     1         ix - 1
     1       )
           else
     3       code = code .. string.format('%s = %s[%s];', name, valVar, ix - 1)
           end
         end

         --(3) return
     1   return code
       end

       --Transform [...] ?= Exp
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transOptionalList(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     2   code = string.format(
     1     "const %s = dogma.getArrayToUnpack(%s, %s);",
     1     valVar,
     1     trans:_trans(sent.exp),
     1     #sent.vars
     1   )

         --(2) unpack
     1   local left, right = "", ""

     6   for ix, def in ipairs(sent.vars) do
     5     local js = self:_transDataAccess(def)

     5     if ix > 1 then
     4       left = left .. ", "
     4       right = right .. ", "
           end

     5     left = left .. js
    10     right = right .. string.format(
     5       "%s != null ? %s : %s[%s]",
     5       js,
     5       js,
     5       valVar,
     5       ix - 1
           )
         end

     1   code = code .. string.format("[%s] = [%s];", left, right)

         --(3) return
     1   return code
       end

       --Transform [...] .= Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transPropList(sent)
     3   local trans = self._.trans
         local code, valVar

         --(1) list value
     3   valVar = self:_getRandomName()
     6   code = string.format(
     3     "const %s = dogma.getArrayToUnpack(%s, %s);",
     3     valVar,
     3     trans:_trans(sent.exp),
     3     #sent.vars
     3   )

         --(2) unpack
     9   for ix, def in ipairs(sent.vars) do
     6     if def.name:find("[:.]") then
     2       local obj = def.name:match("(.+)[:.][^:.]+$")
     2       local fld = def.name:match(".+[:.]([^:.]+)$")

     4       code = code .. string.format(
     2         'Object.defineProperty(%s, "_%s", {value: %s[%s], writable: true});',
     2         obj,
     2         fld,
     2         valVar,
     2         ix - 1
             )

     4       code = code .. string.format(
     2         'Object.defineProperty(%s, "%s", {enum: true, get() { return %s._%s; }});',
     2         obj,
     2         fld,
     2         obj,
               fld
     4       )
           else
     8       code = code .. string.format(
     4         'Object.defineProperty(this, "_%s", {value: %s[%s], writable: true});',
     4         def.name,
     4         valVar,
     4         ix - 1
             )

     8       code = code .. string.format(
     4         'Object.defineProperty(this, "%s", {enum: true, get() { return this._%s; }});',
     4         def.name,
               def.name
     4       )
           end
         end

         --(3) return
     3   return code
       end

       --Transform {...} = Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transMap(sent)
    10   local trans = self._.trans
         local code

         --(1) visibility?
    10   if sent.visib == nil then
     6     code = ""
     4   elseif sent.visib == "export" then
     2     code = "export default "
     2   elseif sent.visib == "pub" then
     2     code = "export "
         end

         --(2) var or const definition?
    10   if sent.def == "var" then
     3     code = code .. "let "
     7   elseif sent.def == "const" then
     3     code = code .. "const "
         end

         --(3) variables
    10   if not sent.def then
     4     code = "({"
         else
     6     code = code .. "{"
         end

    25   for i, var in ipairs(sent.vars) do
    15     if sent.def then
    12       code = code .. (i == 1 and "" or ", ") .. string.format(
     6         "%s%s",
     6         var.name,
     6         var.value and (" = " .. trans:_trans(var.value)) or ""
    12       )
           else
    18       code = code .. (i == 1 and "" or ", ") .. string.format(
     9         "%s: %s%s",
     9         var.name,
     9         self:_transDataAccess(var),
     9         var.value and (" = " .. trans:_trans(var.value)) or ""
     7       )
           end
         end

    10   code = code .. "}"

         --(4) expression
    10   code = code .. " = " .. trans:_trans(sent.exp)

    10   if not sent.def then
     4     code = code .. ")"
         end

    10   code = code .. ";"

         --(5) return
    10   return code
       end

       --Transform {...} := Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transReadOnlyFieldsMap(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     1   code = string.format("const %s = %s;", valVar, trans:_trans(sent.exp))

         --(2) unpack
     4   for _, fld in ipairs(sent.vars) do
     3     local name = fld.name

     3     if fld.mod == "." then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "%s", {value: %s["%s"], enum: true});',
     1         name,
     1         valVar,
               name
     2       )
     2     elseif fld.mod == ":" then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "_%s", {value: %s["%s"]});',
     1         name,
     1         valVar,
               name
     2       )
           else
     1       code = code .. string.format('%s = %s["%s"];', name, valVar, name)
           end
         end

         --(3) return
     1   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/util.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")

     1 package.loaded[...] = {
         transName = function(name)
   412     local KEYWORDS = {
   412       "abstract", "await",
   412       "break",
   412       "case", "char", "class", "const", "continue",
   412       "debugger", "default", "do",
   412       "else", "enum", "export", "extends",
   412       "final", "finally", "for", "function",
   412       "goto",
   412       "if", "implements", "import", "in", "instanceof", "interface",
   412       "let",
   412       "native", "new",
   412       "private", "protected", "public",
   412       "return",
   412       "static", "super", "switch",
   412       "this", "throw", "transient", "try", "typeof",
   412       "var", "volatile",
   412       "while", "with",
             "yield"
   412     }

   412     if tablex.find(KEYWORDS, name) then
     5       return name .. "_"
           else
   407       return name
           end
         end
     1 }

==============================================================================
Summary
==============================================================================

File                                                                 Hits Missed Coverage
-----------------------------------------------------------------------------------------
/home/me/.luarocks/share/lua/5.3/dogma/lex/Lexer.lua                 428  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/LiteralType.lua           4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/TokenType.lua             10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/AdvancedList.lua        21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Annotation.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Char.lua                9    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Comment.lua             10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Directive.lua           10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Eol.lua                 10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Id.lua                  7    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Keyword.lua             61   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Literal.lua             12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Name.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/ProcessedList.lua       21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Reader.lua              51   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Symbol.lua              10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Token.lua               10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveParser.lua       43   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveType.lua         4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/ExpParser.lua             353  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/NodeType.lua              4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/NonTerminalType.lua       4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/Parser.lua                112  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/SentType.lua              6    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtParser.lua            596  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtType.lua              22   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/TerminalType.lua          19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/UnpackParser.lua          79   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AsyncStmt.lua           12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BinOp.lua               18   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BlockParser.lua         34   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BreakStmt.lua           8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CallOp.lua              15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CatchCl.lua             8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ConstStmt.lua           13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DataAccess.lua          5    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Directive.lua           10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DoStmt.lua              13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/EnumStmt.lua            19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Exp.lua                 15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ExportStmt.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FinallyCl.lua           7    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FnStmt.lua              17   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForEachStmt.lua         15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForStmt.lua             15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FromStmt.lua            13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfDirective.lua         12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfStmt.lua              13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfSubExp.lua            19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralFn.lua           28   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralList.lua         14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralMap.lua          14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NaryOp.lua              22   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NativeFn.lua            12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NextStmt.lua            8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Node.lua                9    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NonTerminal.lua         14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ObjectStmt.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Op.lua                  77   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PackOp.lua              16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Param.lua               13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Params.lua              12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PevalFn.lua             12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PubStmt.lua             17   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ReturnStmt.lua          20   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/RunWithDirective.lua    10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Sent.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SliceOp.lua             15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Stmt.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubExp.lua              10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubParser.lua           17   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SyntaxTree.lua          75   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Terminal.lua            16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ThrowFn.lua             16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/TypeStmt.lua            16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UnaryOp.lua             29   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Unpack.lua              15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseStmt.lua             29   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmt.lua             13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WhileStmt.lua           14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WithStmt.lua            12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/Trans.lua               12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/Trans.lua            43   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/DirectiveTrans.lua 27   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/ExpTrans.lua       285  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/StmtTrans.lua      456  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/SubTrans.lua       21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/UnpackTrans.lua    187  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/util.lua           24   0      100.00%
-----------------------------------------------------------------------------------------
Total                                                                3887 0      100.00%
