==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/Lexer.lua
==============================================================================
       --imports
     1 local stringx = require("pl.stringx")
     1 local Reader = require("dogma.lex._.Reader")
     1 local ProcessedList = require("dogma.lex._.ProcessedList")
     1 local AdvancedList = require("dogma.lex._.AdvancedList")
     1 local Eol = require("dogma.lex._.Eol")
     1 local Annotation = require("dogma.lex._.Annotation")
     1 local Comment = require("dogma.lex._.Comment")
     1 local Directive = require("dogma.lex._.Directive")
     1 local Name = require("dogma.lex._.Name")
     1 local Keyword = require("dogma.lex._.Keyword")
     1 local Literal = require("dogma.lex._.Literal")
     1 local LiteralType = require("dogma.lex.LiteralType")
     1 local Symbol = require("dogma.lex._.Symbol")
     1 local TokenType = require("dogma.lex.TokenType")

       --A lexer os scanner.
     1 local Lexer = {}
     1 Lexer.__index = Lexer
     1 package.loaded[...] = Lexer

       --Constructor.
       --
       --@param props:object Lexer properties.
     1 function Lexer.new(props)
         local self

         --(1) arguments
   615   if not props then props = {} end

         --(2) create
  1230   self = setmetatable({
   615     _ = {
   615       comments = not not props.comments
   615     }
  1230   }, Lexer)

         --(3) return
   615   return self
       end

       --Scan a text.
       --
       --@param text:string  Text to analyze.
       --@param file?:string File path.
       --
       --@return self
     1 function Lexer:scan(text, file)
         --(1) arguments
   613   if not text then error("text expected.") end

         --(2) init
   612   self._.reader = Reader.new(text)
   612   self._.file = file or "anonymous code"
   612   self._.processed = ProcessedList.new(3)
   612   self._.token = nil
   612   self._.advanced = AdvancedList.new(3)

         --(3) return
   612   return self
       end

       --Scan the next token.
       --
       --@overload
       --@return Token
       --
       --@overload
       --@param typ:TokenType  Token type to read.
       --@param val:string     Token value to read.
       --@return Token
     1 function Lexer:next(typ, val)
  8659   local reader = self._.reader
         local tok

         --(1) get token to return
  8659   if self:_hasTokenToShift() then
  3249     self:_shift()
         else
           local ch

           --get next char
  5410     ch = reader:next()

  7021     while ch ~= nil and (ch.char == " " or ch.char == "\t") do
  1611       ch = reader:next()
           end

  5410     if ch ~= nil then
  4588       ch = ch.char

             --analyze token
  4588       reader:unshift()

  4588       if ch == "\n" then
   773         tok = self:_scanEol()
  3815       elseif ch == "@" then
    14         tok = self:_scanAnnotation()
  3801       elseif ch == "_" or stringx.isalpha(ch) then
  1724         tok = self:_scanId()
  2077       elseif ch == "'" then
     1         tok = self:_scanName()
  2076       elseif stringx.isdigit(ch) then
   436         tok = self:_scanLiteralNumber()
  1640       elseif ch == '"' then
    86         tok = self:_scanLiteralString()
  1554       elseif ch == "#" then
    43         reader:next()
    43         ch = reader:next().char

    43         reader:unshift()
    43         reader:unshift()

    43         if ch == "!" then
    38           tok = self:_scanDirective()
               else
     5           tok = self:_scanComment()

     5           if not self._.comments then
     1             return self:next()
                 end
               end
             else
  1511         tok = self:_scanSymbol()
             end

  4579       self:_backUpToken()
  4579       self._.token = tok
           else
   822       self:_backUpToken()
   822       self._.token = nil
           end
         end

         --(2) check
  8650   if typ then
  1750     tok = self._.token

  1750     if tok == nil then
     2       error(string.format("'%s' expected at the end of code.", val))
           end

  1748     if tok.type ~= typ or (val ~= nil and tok.value ~= val) then
    13       if typ == TokenType.EOL then
     4         error(string.format(
     2           "end of line expected on (%s, %s).",
     2           tok.line,
                 tok.col
     2         ))
    11       elseif typ == TokenType.NAME then
     6         error(string.format(
     3           "name expected on (%s, %s).",
     3           tok.line,
                 tok.col
     3         ))
     8       elseif typ == TokenType.LITERAL then
     2         error(string.format(
     1           "literal expected on (%s, %s).",
     1           tok.line,
                 tok.col
     1         ))
             else
    14         error(string.format(
     7           "'%s' expected on (%s, %s).",
     7           val,
     7           tok.line,
                 tok.col
     7         ))
             end
           end
         end

         --(3) return
  8635   return self._.token
       end

       --Advance the next token.
       --
       --@return Token
     1 function Lexer:advance(i)
         local tok

         --(1) arguments
  5807   if i == nil then
  5679     i = 1
         end

         --(2) get token
  5807   if #self._.advanced >= i then
  2680     tok = self._.advanced._.items[i]
         else
  3127     if i == 1 then
  3000       tok = self:next()
  3000       self:unshift()
   127     elseif i == 2 then
   104       self:next()
   104       tok = self:next()
   104       self:unshift()
   104       self:unshift()
    23     elseif i == 3 then
    23       self:next()
    23       self:next()
    23       tok = self:next()
    23       self:unshift()
    23       self:unshift()
    23       self:unshift()
           end
         end

         --(3) return
  5807   return tok
       end

       --Check whether the lexer has some token to shift.
       --
       --@return bool
     1 function Lexer:_hasTokenToShift()
  8659   return #self._.advanced > 0
       end

       --Shift a token: <- processed <- current <- advanced
     1 function Lexer:_shift()
         --(1) pre
  3250   if #self._.advanced == 0 then
     1     error("no advanced token to shift.")
         end

         --(2) current to processed
  3249   if self._.token then
  2599     self._.processed:insert(self._.token)
         end

         --(3) advanced to current
  3249   self._.token = self._.advanced:remove()
       end

       --Unshift a char: processed -> current -> advanced
     1 function Lexer:unshift()
         --(1) pre
  4178   if not self._.token and #self._.processed == 0 then
     1     error("no current token to unshift.")
         end

         --(2) current to advanced
  4177   self._.advanced:insert(self._.token)

         --(3) last processed to current
  4177   if #self._.processed == 0 then
   653     self._.token = nil
         else
  3524     self._.token = self._.processed:remove()
         end
       end

       --Shift current token to processed tokens: processed <- token.
     1 function Lexer:_backUpToken()
  5401   if self._.token then
  4801     self._.processed:insert(self._.token)
         end
       end

       --Scan an end of line.
       --
       --@return Eol
     1 function Lexer:_scanEol()
   773   local reader = self._.reader
   773   local ch = reader:next()

   773   return Eol.new(ch.line, ch.col)
       end

       --Scan an annotation.
       --
       --@return Annotation
     1 function Lexer:_scanAnnotation()
    14   local rdr = self._.reader
         local state, ln, col, val
    14   local State = {
    14     START = 1,
    14     VALUE = 2,
    14     END = 3
         }

         --(1) state machine
    14   state = State.START

   124   while state ~= State.END do
   110     local ch = rdr:next()

   110     if state == State.START then
    14       ln, col, val = ch.line, ch.col, ""
    14       state = State.VALUE
    96     elseif state == State.VALUE then
    96       ch = ch.char

    96       if not (stringx.isalnum(ch) or ch == "_") then
    14         rdr:unshift()
    14         state = State.END
             else
    82         val = val .. ch
             end
           end
         end

         --(2) return
    14   return Annotation.new(ln, col, val)
       end

       --Scan a directive.
       --
       --@return Directive
     1 function Lexer:_scanDirective()
    38   local rdr = self._.reader
         local state, ln, col, val
    38   local State = {
    38     START1 = 1,
    38     START2 = 2,
    38     VALUE = 3,
    38     END = 4
         }

         --(1) state machine
    38   state = State.START1

   431   while state ~= State.END do
   393     local ch = rdr:next()

   393     if state == State.START1 then
    38       ln, col, val = ch.line, ch.col, ""
    38       state = State.START2
   355     elseif state == State.START2 then
    38       state = State.VALUE
   317     elseif state == State.VALUE then
   317       ch = ch.char

   317       if ch == "\n" then
    38         state = State.END
             else
   279         val = val .. ch
             end
           end
         end

    38   if not (val:find("^if [a-zA-Z]+ then$") or val:find("^if not [a-zA-Z]+ then$") or val == "end" or val == "else") then
     1     error(string.format("on (%s,%s), invalid directive.", ln, col))
         end

         --(2) return
    37   return Directive.new(ln, col, val)
       end

       --Scan a comment.
       --
       --@return Comment
     1 function Lexer:_scanComment()
     5   local reader = self._.reader
         local state, ln, col, comm
     5   local State = {
     5     START = 1,
     5     TEXT = 2,
     5     POSSIBLE_END = 3,
     5     END = 4
         }

         --(1) state machine
     5   state = State.START

   120   while state ~= State.END do
   115     local ch = reader:next()

   115     if state == State.START then
     5       ln, col, comm = ch.line, ch.col, ""
     5       state = State.TEXT
   110     elseif state == State.TEXT then
   104       ch = ch.char

   104       if ch == "\n" then
     6         state = State.POSSIBLE_END
             else
    98         comm = comm .. ch
             end
           else  --POSSIBLE_END
     6       if ch == nil then
     4         reader:unshift()  --current: nil
     4         reader:unshift()  --end of line
     4         state = State.END
             else
     2         ch = ch.char

     2         if ch == "#" then
     1           comm = comm .. "\n"
     1           state = State.TEXT
               else
     1           reader:unshift()  --current char
     1           reader:unshift()  --eol
     1           state = State.END
               end
             end
           end
         end

         --(2) return
     5   return Comment.new(ln, col, comm)
       end

       --Scan an identifier.
       --
       --@return Id
     1 function Lexer:_scanId()
  1724   local reader = self._.reader
         local state, ln, col, id
  1724   local State = {
  1724     START = 1,
  1724     MIDDLE = 2,
  1724     END = 3
         }

         --(1) state machine
  1724   state = State.START

  7990   while state ~= State.END do
  6266     local ch = reader:next()

  6266     if state == State.START then
  1724       ln, col = ch.line, ch.col
  1724       id = ch.char
  1724       state = State.MIDDLE
           else
  4542       ch = ch.char

  4542       if ch == "_" or stringx.isalnum(ch) then
  2818         id = id .. ch
             else
  1724         state = State.END
  1724         reader:unshift()
             end
           end
         end

         --(2) return
  1724   if Keyword.isKeyword(id) then
   609     return Keyword.new(ln, col, id)
         else
  1115     return Name.new(ln, col, id)
         end
       end

       --Scan a name.
       --
       --@return Name
     1 function Lexer:_scanName()
     1   local reader = self._.reader
         local state, ln, col, id, ch
     1   local State = {
     1     START = 1,
     1     ID = 2,
     1     END = 3
         }

         --(1) state machine
     1   state = State.START
     1   ch = reader:next()  --'
     1   ln, col = ch.line, ch.col

     9   while state ~= State.END do
     8     ch = reader:next()

     8     if state == State.START then
     1       id = ch.char
     1       state = State.ID
           else --State.ID
     7       ch = ch.char

     7       if ch == "'" then
     1         state = State.END
             else
     6         id = id .. ch
             end
           end
         end

         --(2) return
     1   return Name.new(ln, col, id)
       end

       --Scan a symbol.
       --
       --@return Symbol
     1 function Lexer:_scanSymbol()
  1511   local reader = self._.reader
         local state, ln, col, sym
  1511   local State = {
  1511     START = 1,
  1511     MIDDLE = 2,
  1511     END = 3
         }
  1511   local SYMBOLS = {
  1511     ["$"] = true,
  1511     ["+"] = true,
  1511     ["+="] = true,
  1511     ["-"] = true,
  1511     ["-="] = true,
  1511     ["->"] = true,
  1511     ["*"] = true,
  1511     ["*="] = true,
  1511     ["**"] = true,
  1511     ["**="] = true,
  1511     ["/"] = true,
  1511     ["/="] = true,
  1511     ["%"] = true,
  1511     ["%="] = true,
  1511     ["="] = true,
  1511     ["=="] = true,
  1511     ["==="] = true,
  1511     ["!"] = true,
  1511     ["!="] = true,
  1511     ["!=="] = true,
  1511     ["<"] = true,
  1511     ["<<"] = true,
  1511     ["<<="] = true,
  1511     ["<="] = true,
  1511     [">"] = true,
  1511     [">>"] = true,
  1511     [">>="] = true,
  1511     [">="] = true,
  1511     ["^"] = true,
  1511     ["^="] = true,
  1511     ["~"] = true,
  1511     ["~="] = true,
  1511     ["("] = true,
  1511     [")"] = true,
  1511     ["["] = true,
  1511     ["]"] = true,
  1511     ["{"] = true,
  1511     ["}"] = true,
  1511     [";"] = true,
  1511     [":"] = true,
  1511     [":="] = true,
  1511     [":=|"] = true,
  1511     ["."] = true,
  1511     [".."] = true,
  1511     ["..."] = true,
  1511     [".="] = true,
  1511     ["?"] = true,
  1511     ["&"] = true,
  1511     ["&="] = true,
  1511     ["&&"] = true,
  1511     ["|"] = true,
  1511     ["|="] = true,
  1511     ["||"] = true,
  1511     [","] = true
         }

         --(1) state machine
  1511   state = State.START

  4664   while state ~= State.END do
  3153     local ch = reader:next()

  3153     if state == State.START then
  1511       if SYMBOLS[ch.char] then
  1509         ln, col, sym = ch.line, ch.col, ch.char
  1509         state = State.MIDDLE
             else
     2         reader:unshift()
     2         state = State.END
             end
           else
  1642       if SYMBOLS[sym .. ch.char] then
   133         sym = sym .. ch.char
             else
  1509         reader:unshift()
  1509         state = State.END
             end
           end
         end

         --(2) return
  1511   if sym == nil then
     2     error(string.format("invalid symbol on (%s, %s).", reader._.line, reader._.col - 1))
         end

  1509   return Symbol.new(ln, col, sym)
       end

       --Scan a literal hnumber.
       --
       --@return Literal
     1 function Lexer:_scanLiteralNumber()
   436   local reader = self._.reader
         local state, ln, col, lit
   436   local State = {
   436     START = 1,
   436     INT = 2,
   436     DOT = 3,
   436     DECIMAL = 4,
   436     END = 5
         }

         --(1) state machine
   436   state = State.START

  1616   while state ~= State.END do
  1180     local ch = reader:next()

  1180     if state == State.START then
   436       ln, col, lit = ch.line, ch.col, ch.char
   436       state = State.INT
   744     elseif state == State.INT then
   734       ch = ch.char

   734       if stringx.isdigit(ch) then
   234         lit = lit .. ch
   500       elseif ch == " " then
    64         lit = lit --nothing to do
   436       elseif ch == "." then
     4         state = State.DOT
             else
   432         reader:unshift()
   432         state = State.END
             end
    10     elseif state == State.DOT then
     4       ch = ch.char

     4       if stringx.isdigit(ch) then
     2         lit = lit .. "." .. ch
     2         state = State.DECIMAL
             else
     2         reader:unshift() --current
     2         reader:unshift() --dot
     2         state = State.END
             end
           else  --DECIMAL
     6       ch = ch.char

     6       if stringx.isdigit(ch) then
     4         lit = lit .. ch
             else
     2         reader:unshift()
     2         state = State.END
             end
           end
         end

         --(2) return
   436   return Literal.new(ln, col, LiteralType.NUMBER, tonumber(lit))
       end

       --Scan a literal string.
       --
       --@return Literal
     1 function Lexer:_scanLiteralString()
    86   local reader = self._.reader
         local state, ln, col, lit
    86   local State = {
    86     START = 1,
    86     START1 = 2,
    86     START2 = 3,
    86     TEXT1 = 4,
    86     TEXT3 = 5,
    86     END1 = 6,
    86     END2 = 7,
    86     END = 8
         }

         --(1) state machine
    86   state = State.START

   740   while state ~= State.END do
   659     local ch = reader:next()

   659     if state == State.START then
    86       ln, col, lit = ch.line, ch.col, ""
    86       state = State.START1
   573     elseif state == State.START1 then
    86       ch = ch.char

    86       if ch == '"' then
     5         state = State.START2
             else
    81         lit = lit .. ch
    81         state = State.TEXT1
             end
   487     elseif state == State.START2 then
     5       ch = ch.char

     5       if ch == '"' then
     4         state = State.TEXT3
             else
     1         reader:unshift()
     1         state = State.END
             end
   482     elseif state == State.TEXT1 then  --"literal"
   454       if ch == nil then
     2         error(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

   452       ch = ch.char

   452       if ch == '"' then
    79         state = State.END
             else
   373         lit = lit .. ch
             end
    28     elseif state == State.TEXT3 then  --"""literal"""
    22       if ch == nil then
     2         error(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

    20       ch = ch.char

    20       if ch == '"' then
     3         state = State.END1
             else
    17         lit = lit .. ch
             end
     6     elseif state == State.END1 then
     3       ch = ch.char

     3       if ch == '"' then
     2         state = State.END2
             else
     1         lit = lit .. '"' .. ch
     1         state = State.TEXT3
             end
           else  --State.END2
     3       if ch == nil then
     1         error(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

     2       ch = ch.char

     2       if ch == '"' then
     1         state = State.END
             else
     1         lit = lit .. '""' .. ch
             end
           end
         end

         --(2) return
    81   return Literal.new(ln, col, LiteralType.STRING, lit)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/LiteralType.lua
==============================================================================
     1 return {
     1   STRING = 1,
     1   NUMBER = 2
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/TokenType.lua
==============================================================================
     1 return {
     1   COMMENT = 1,
     1   EOL = 2,
     1   NAME = 3,
     1   KEYWORD = 4,
     1   LITERAL = 5,
     1   SYMBOL = 6,
     1   DIRECTIVE = 7,
     1   ANNOTATION = 8
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/AdvancedList.lua
==============================================================================
     1 local AdvancedList = {}
     1 AdvancedList.__index = AdvancedList
     1 package.loaded[...] = AdvancedList

     1 function AdvancedList.new(max)
         --(1) arguments
  1249   if max == nil then error("max expected.") end

         --(2) return
  2496   return setmetatable({
  1248     _ = {
  1248       max = max,
  1248       items = {}
  1248     }
  2496   }, AdvancedList)
       end

     1 function AdvancedList:__len()
 69945   return #self._.items
       end

     1 function AdvancedList:insert(item)
 12568   if #self == self._.max then
     1     error("list already full.")
         end

 12567   table.insert(self._.items, 1, item)
       end

     1 function AdvancedList:remove()
 11531   if #self == 0 then
     1     error("empty list, nothing to remove.")
         end

 11530   return table.remove(self._.items, 1)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Annotation.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --An annotation.
     1 local Annotation = {}
     1 Annotation.__index = Annotation
     1 setmetatable(Annotation, {__index = Token})
     1 package.loaded[...] = Annotation

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param val:string
     1 function Annotation.new(ln, col, val)
    14   return setmetatable(Token.new(TokenType.ANNOTATION, ln, col, val), Annotation)
       end

       --@override
     1 function Annotation:__tostring()
     7   return string.format("<annotation>%s</annotation>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Char.lua
==============================================================================
       --A character.
     1 local Char = {}
     1 Char.__index = Char
     1 package.loaded[...] = Char

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param ch:char    Character.
     1 function Char.new(ln, col, ch)
 21448   return setmetatable({
 10724     line = ln,
 10724     col = col,
 10724     char = ch
 21448   }, Char)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Comment.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A comment.
     1 local Comment = {}
     1 Comment.__index = Comment
     1 setmetatable(Comment, {__index = Token})
     1 package.loaded[...] = Comment

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param text:string  Comment text.
     1 function Comment.new(ln, col, text)
     5   return setmetatable(Token.new(TokenType.COMMENT, ln, col, text), Comment)
       end

       --@override
     1 function Comment:__tostring()
    20   return string.format("<comment>%s</comment>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Directive.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A comilation directive.
     1 local Directive = {}
     1 Directive.__index = Directive
     1 setmetatable(Directive, {__index = Token})
     1 package.loaded[...] = Directive

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param val:string
     1 function Directive.new(ln, col, val)
    37   return setmetatable(Token.new(TokenType.DIRECTIVE, ln, col, val), Directive)
       end

       --@override
     1 function Directive:__tostring()
    28   return string.format("<directive>%s</directive>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Eol.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --An end of line.
     1 local Eol = {}
     1 Eol.__index = Eol
     1 setmetatable(Eol, {__index = Token})
     1 package.loaded[...] = Eol

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function Eol.new(ln, col)
   773   return setmetatable(Token.new(TokenType.EOL, ln, col, "\n"), Eol)
       end

     1 function Eol:__tostring()
    79   return "<eol/>"
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Id.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")

       --An identifier.
     1 local Id = {}
     1 Id.__index = Id
     1 setmetatable(Id, {__index = Token})
     1 package.loaded[...] = Id

       --Constructor.
       --
       --@param t:string   Token type.
       --@param ln:number  Line number.
       --@param col:number Column number
       --@param id:string  Identifier.
     1 function Id.new(t, ln, col, id)
  1731   return setmetatable(Token.new(t, ln, col, id), Id)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Keyword.lua
==============================================================================
       --imports
     1 local Id = require("dogma.lex._.Id")
     1 local TokenType = require("dogma.lex.TokenType")

       --A keyword.
     1 local Keyword = {}
     1 Keyword.__index = Keyword
     1 setmetatable(Keyword, {__index = Id})
     1 package.loaded[...] = Keyword

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param id:string  Identifier.
     1 function Keyword.new(ln, col, id)
   615   return setmetatable(Id.new(TokenType.KEYWORD, ln, col, id), Keyword)
       end

       --Check whether an identifier is a keyword.
       --
       --@param id:string  Identifier to check.
       --@return bool
     1 function Keyword.isKeyword(id)
  1724   local KEYWORDS = {
  1724     ["and"] = true,
  1724     ["as"] = true,
  1724     ["async"] = true,
  1724     ["await"] = true,
  1724     ["break"] = true,
  1724     ["catch"] = true,
  1724     ["const"] = true,
  1724     ["do"] = true,
  1724     ["dogma"] = true,
  1724     ["each"] = true,
  1724     ["else"] = true,
  1724     ["end"] = true,
  1724     ["enum"] = true,
  1724     ["export"] = true,
  1724     ["extern"] = true,
  1724     ["false"] = true,
  1724     ["finally"] = true,
  1724     ["fn"] = true,
  1724     ["for"] = true,
  1724     ["from"] = true,
  1724     ["if"] = true,
  1724     ["impl"] = true,
  1724     ["in"] = true,
  1724     ["is"] = true,
  1724     ["like"] = true,
  1724     ["native"] = true,
  1724     ["next"] = true,
  1724     ["nil"] = true,
  1724     ["nop"] = true,
  1724     ["not"] = true,
  1724     ["op"] = true,
  1724     ["or"] = true,
  1724     ["peval"] = true,
  1724     ["pub"] = true,
  1724     ["pvt"] = true, --private
  1724     ["return"] = true,
  1724     ["self"] = true,
  1724     ["Self"] = true,
  1724     ["super"] = true,
  1724     ["then"] = true,
  1724     ["throw"] = true,
  1724     ["true"] = true,
  1724     ["type"] = true,
  1724     ["use"] = true,
  1724     ["var"] = true,
  1724     ["while"] = true,
  1724     ["yield"] = true
         }

  1724   return KEYWORDS[id] or false
       end

       --@override
     1 function Keyword:__tostring()
    10   return string.format("<keyword>%s</keyword>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Literal.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A literal.
     1 local Literal = {}
     1 Literal.__index = Literal
     1 setmetatable(Literal, {__index = Token})
     1 package.loaded[...] = Literal

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param t:string     Literal type: number, string...
       --@param val:any      Literal value.
     1 function Literal.new(ln, col, t, val)
         local self

         --(1) create
   517   self = setmetatable(Token.new(TokenType.LITERAL, ln, col, val), Literal)
   517   self.subtype = t

         --(2) return
   517   return self
       end

       --@override
     1 function Literal:__tostring()
   156   return string.format("<literal type='%s'>%s</literal>", self.type, self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Name.lua
==============================================================================
       --imports
     1 local Id = require("dogma.lex._.Id")
     1 local TokenType = require("dogma.lex.TokenType")

       --An identifier.
     1 local Name = {}
     1 Name.__index = Id
     1 setmetatable(Name, {__index = Id})
     1 package.loaded[...] = Name

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number
       --@param id:string  Identifier.
     1 function Name.new(ln, col, id)
  1116   return setmetatable(Id.new(TokenType.NAME, ln, col, id), Id)
       end

       --@override
     1 function Id:__tostring()
    92   return string.format("<name>%s</name>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/ProcessedList.lua
==============================================================================
     1 local List = {}
     1 List.__index = List
     1 package.loaded[...] = List

     1 function List.new(max)
         --(1) arguments
  1249   if max == nil then error("max expected.") end

         --(2) return
  2496   return setmetatable({
  1248     _ = {
  1248       max = max,
  1248       items = {}
  1248     }
  2496   }, List)
       end

     1 function List:__len()
 50173   return #self._.items
       end

     1 function List:insert(item)
 25506   if #self == self._.max then
 11469     table.remove(self._.items, 1)
         end

 25506   table.insert(self._.items, item)
       end

     1 function List:remove()
 11278   if #self == 0 then
     1     error("internal error: invalid remove from previous list.")
         end

 11277   return table.remove(self._.items)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Reader.lua
==============================================================================
       --imports
     1 local stringx = require("pl.stringx")
     1 local Char = require("dogma.lex._.Char")
     1 local ProcessedList = require("dogma.lex._.ProcessedList")
     1 local AdvancedList = require("dogma.lex._.AdvancedList")

       --A text reader.
     1 local Reader = {}
     1 Reader.__index = Reader
     1 package.loaded[...] = Reader

       --Constructor.
     1 function Reader.new(txt)
  1258   return setmetatable({
   629     _ = {
   629       text = stringx.split(txt, "\n"),
   629       line = 1,
   629       col = 1,
   629       processed = ProcessedList.new(3),
   629       char = nil,
   629       advanced = AdvancedList.new(3),
   629     }
  1258   }, Reader)
       end

       --Check whether the lexer has some char to shift.
       --
       --@return bool
     1 function Reader:_hasCharToShift()
 19830   return #self._.advanced > 0
       end

       --Read the next character.
       --
       --@return Char
     1 function Reader:next()
         --(1) read
 19830   if self:_hasCharToShift() then
  8273     self:_shift()
         else
 11557     local ln = self._.text[self._.line]

 11557     if ln then
 10724       if self._.col > #ln then
   849         self:_backUp()
   849         self._.char = Char.new(self._.line, self._.col, "\n")
   849         self._.line = self._.line + 1
   849         self._.col = 1
             else
  9875         self:_backUp()
  9875         self._.char = Char.new(self._.line, self._.col, ln:sub(self._.col, self._.col))
  9875         self._.col = self._.col + 1
             end
           else  --end of input
   833       self:_backUp()
   833       self._.char = nil
           end
         end

         --(2) return
 19830   return self._.char
       end

       --Shift a char: <- processed <- current <- advanced
     1 function Reader:_shift()
         --(1) pre
  8277   if #self._.advanced == 0 then
     1     error("no advanced char to shift.")
         end

         --(2) current to processed
  8276   if self._.char then
  7644     self._.processed:insert(self._.char)
         end

         --(3) advanced to current
  8276   self._.char = self._.advanced:remove()
       end

       --Unshift a char: processed -> current -> advanced
     1 function Reader:unshift()
         --(1) current to advanced
  8384   if self._.char then
  8379     self._.advanced:insert(self._.char)
         end

         --(2) last processed to current
  8384   if #self._.processed == 0 then
   636     self._.char = nil
         else
  7748     self._.char = self._.processed:remove()
         end
       end

       --Shift current char to processed chars: processed <- char.
     1 function Reader:_backUp()
 11557   if self._.char then
 10450     self._.processed:insert(self._.char)
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Symbol.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A symbol.
     1 local Symbol = {}
     1 Symbol.__index = Symbol
     1 setmetatable(Symbol, {__index = Token})
     1 package.loaded[...] = Symbol

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param sym:string   Symbol.
     1 function Symbol.new(ln, col, sym)
  1509   return setmetatable(Token.new(TokenType.SYMBOL, ln, col, sym), Symbol)
       end

       --@override
     1 function Symbol:__tostring()
   470   return string.format("<symbol>%s</symbol>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Token.lua
==============================================================================
       --A token.
     1 local Token = {}
     1 Token.__index = Token
     1 package.loaded[...] = Token

       --Constructor.
       --
       --@param t:TokenType  Token type.
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param val:any      Value.
     1 function Token.new(t, ln, col, val)
  9172   return setmetatable({
  4586     type = t,
  4586     line = ln,
  4586     col = col,
  4586     value = val
  9172   }, Token)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveParser.lua
==============================================================================
       --imports
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local IfDirective = require("dogma.syn._.IfDirective")

       --A directive parser.
     1 local DirectiveParser = {}
     1 DirectiveParser.__index = DirectiveParser
     1 setmetatable(DirectiveParser, {__index = SubParser})
     1 package.loaded[...] = DirectiveParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function DirectiveParser.new(parser)
   512   return setmetatable(SubParser.new(parser), DirectiveParser)
       end

       --Read the next if directive.
       --
       --@return Directive
     1 function DirectiveParser:nextIf()
    14   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, el

         --(1) read if
    14   tok = lex:next(TokenType.DIRECTIVE)
    14   ln, col = tok.line, tok.col

    14   if tok.value:find("^if [a-zA-Z_0-9]+ then$") then
     9     cond = tok.value:match("^if ([a-zA-Z_0-9]+) then$")
         else
     5     cond = tok.value:match("^if (not [a-zA-Z_0-9]+) then$")
         end

    14   body = {}
         while true do
    55     tok = lex:advance()

    55     if tok == nil then
             break
    54     elseif tok.type == TokenType.EOL then
    21       lex:next()
           else
    33       if tok.type == TokenType.DIRECTIVE then
    13         if tok.value == "else" or tok.value == "end" then
                 break
               else
     1           error(string.format("on (%s,%s), if directive can't be nested.", tok.line, tok.col))
               end
             end

    20       table.insert(body, parser:next())
           end
         end

         --(2) read else
    13   tok = lex:advance()

    13   if tok and tok.type == TokenType.DIRECTIVE and tok.value == "else" then
     6     lex:next()

     6     el = {}
           while true do
    18       tok = lex:advance()

    18       if tok.type == TokenType.EOL then
     6         lex:next()
             else
    12         if tok.type == TokenType.DIRECTIVE then
     6           if tok.value == "end" then
                   break
                 else
     1             error(string.format("on (%s,%s), else directive can't be nested.", tok.line, tok.col))
                 end
               end

     6         table.insert(el, parser:next())
             end
           end
         end

         --(3) read end
    12   lex:next(TokenType.DIRECTIVE, "end")

         --(4) return
    11   return IfDirective.new(ln, col, cond, body, el)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveType.lua
==============================================================================
     1 return {
     1   IF = "if"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/ExpParser.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local Keyword = require("dogma.lex._.Keyword")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local SubExp = require("dogma.syn._.SubExp")
     1 local IfSubExp = require("dogma.syn._.IfSubExp")
     1 local UnaryOp = require("dogma.syn._.UnaryOp")
     1 local BinOp = require("dogma.syn._.BinOp")
     1 local SliceOp = require("dogma.syn._.SliceOp")
     1 local CallOp = require("dogma.syn._.CallOp")
     1 local Exp = require("dogma.syn._.Exp")
     1 local LiteralList = require("dogma.syn._.LiteralList")
     1 local LiteralMap = require("dogma.syn._.LiteralMap")
     1 local LiteralFn = require("dogma.syn._.LiteralFn")
     1 local PevalFn = require("dogma.syn._.PevalFn")
     1 local NativeFn = require("dogma.syn._.NativeFn")
     1 local ThrowFn = require("dogma.syn._.ThrowFn")
     1 local ReturnStmt = require("dogma.syn._.ReturnStmt")

       --An expression parser.
     1 local ExpParser = {}
     1 ExpParser.__index = ExpParser
     1 setmetatable(ExpParser, {__index = SubParser})
     1 package.loaded[...] = ExpParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function ExpParser.new(parser)
         local self

         --(1) create
   512   self = setmetatable(SubParser.new(parser), ExpParser)
   512   self._.stmtParser = parser._.stmtParser

         --(2) return
   512   return self
       end

       --Read an expression.
       --
       --@return Exp
     1 function ExpParser:next()
   558   return self:_readExp()
       end

     1 function ExpParser:_readExp()
   734   local lex = self._.lexer
         local tok, node, exp

         --(1) init expression
   734   tok = lex:advance()
   734   exp = Exp.new(tok.line, tok.col)

         --(2) read
         while true do
  2397     tok = lex:next()

  2397     if tok == nil then
     1       if exp.tree:isWellFormed() then
               break
             else
     2         error(string.format(
     1           "incomplete expression started on (%s, %s).",
     1           exp.line,
                 exp.col
     1         ))
             end
           end

  2396     if tok.type == TokenType.EOL then
   459       if exp.tree:isWellFormed() then
   456         lex:unshift()
               break
             end
  1937     elseif tok.type == TokenType.SYMBOL and tok.value == "(" then
   115       lex:unshift()

   115       if exp.tree:isWellFormed() then
   103         self:_readCallArgs(exp)
             else
    12         exp:insert(self:_readSubExp())
             end
  1822     elseif tok.type == TokenType.SYMBOL and tok.value == "[" then
    25       lex:unshift()

    25       if exp.tree:isWellFormed() then
    14         self:_readIndexOp(exp)
             else
    11         exp:insert(self:_readLiteralList())
             end
  1797     elseif tok.type == TokenType.SYMBOL and tok.value == "{" then
    11       lex:unshift()
    11       exp:insert(self:_readLiteralMap())
  1786     elseif tok.type == TokenType.KEYWORD and tok.value == "fn" then
    11       lex:unshift()
    11       exp:insert(self:_readFn())
  1775     elseif tok.type == TokenType.KEYWORD and tok.value == "if" then
     5       lex:unshift()
     5       exp:insert(self:_readIfSubExp())
  1770     elseif tok.type == TokenType.KEYWORD and tok.value == "native" then
     3       lex:unshift()
     3       exp:insert(self:_readNative())
  1767     elseif tok.type == TokenType.KEYWORD and tok.value == "peval" then
     4       lex:unshift()
     4       exp:insert(self:_readPeval())
  1763     elseif tok.type == TokenType.KEYWORD and tok.value == "throw" then
     6       lex:unshift()
     6       exp:insert(self:_readThrow())
           else
  1757       if tok.type == TokenType.KEYWORD and tok.value == "not" then
     8         local aux = lex:advance()

     8         if aux.type == TokenType.KEYWORD and aux.value == "in" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "notin"))
     6         elseif aux.type == TokenType.KEYWORD and aux.value == "like" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "notlike"))
               else
     4           node = UnaryOp.new(tok)
               end
  1749       elseif tok.type == TokenType.KEYWORD and tok.value == "is" then
     4         local aux = lex:advance()

     4         if aux.type == TokenType.KEYWORD and aux.value == "not" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "isnot"))
               else
     2           node = self:_getNodeOf(tok)
               end
  1745       elseif tok.type == TokenType.SYMBOL and (tok.value == "+" or tok.value == "-") then
   237         if exp.tree:isWellFormed() then
   229           node = BinOp.new(tok)
               else
     8           node = UnaryOp.new(tok)
               end
  1508       elseif tok.type == TokenType.SYMBOL and tok.value == ":" then
    14         if exp.tree:isWellFormed() then
     8           node = BinOp.new(tok)
               else
     6           node = UnaryOp.new(tok)
               end
             else
  1494         node = self:_getNodeOf(tok)
             end

  1757       if node == nil then
   263         if exp.tree:isWellFormed() then
   262           lex:unshift()
                 break
               else
     2           error(string.format(
     1             "invalid expression node on (%s, %s).",
     1             tok.line,
                   tok.col
     1           ))
               end
             else
  1494         exp:insert(node)
             end
           end
         end

         --(3) return
   718   return exp
       end

       --Return a node for a given token.
       --
       --@param tok:Token  The token.
       --@return Node
     1 function ExpParser:_getNodeOf(tok)
         local node

         --(1) create node
  1496   if tok.type == TokenType.NAME then
   606     node = Terminal.new(TerminalType.NAME, tok)
   890   elseif tok.type == TokenType.LITERAL then
   428     if type(tok.value) == "string" then
    34       node = Terminal.new(TerminalType.TEXT, tok)
   394     elseif type(tok.value) == "number" then
   394       node = Terminal.new(TerminalType.NUM, tok)
           end
   462   elseif tok.type == TokenType.KEYWORD then
   120     local kw = tok.value

   120     if kw == "nop" then
     1       node = Terminal.new(TerminalType.NOP, tok)
   119     elseif kw == "false" then
     2       node = Terminal.new(TerminalType.FALSE, tok)
   117     elseif kw == "nil" then
     1       node = Terminal.new(TerminalType.NIL, tok)
   116     elseif kw == "self" then
     2       node = Terminal.new(TerminalType.SELF, tok)
   114     elseif kw == "super" then
     1       node = Terminal.new(TerminalType.SUPER, tok)
   113     elseif kw == "true" then
    25       node = Terminal.new(TerminalType.TRUE, tok)
    88     elseif tablex.find({"and", "in", "is", "like", "or"}, kw) then
    10       node = BinOp.new(tok)
           end
   342   elseif tok.type == TokenType.SYMBOL then
   342     local sym = tok.value

   342     if tablex.find({"$", "!", "~", "..."}, sym) then
    15       node = UnaryOp.new(tok)
   654     elseif tablex.find({
   327                           "+=", "-=", "*", "*=", "**", "**=", "/", "/=", "%", "%=",
   327                           "=", ".=", ":=", "==", "===", "!=", "!==",
   327                           "<", "<<", "<<=", "<=", ">", ">>", ">>=", ">=",
   327                           "^", "^=", ".", ":", "&", "&=", "&&", "|", "|=", "||"
   654                        }, sym) then
   142       node = BinOp.new(tok)
           end
         end

         --(2) return
  1496   return node
       end

       --Read (expr).
       --
       --@return Exp
     1 function ExpParser:_readSubExp()
    12   local lex = self._.lexer
         local term, tok, ln, col

         --(1) read
    12   tok = lex:next(TokenType.SYMBOL, "(")
    12   ln, col = tok.line, tok.col
    12   term = SubExp.new(ln, col, self:_readExp())
    11   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     9   return term
       end

       --Read if then else end.
       --
       --@return IfSubExp
     1 function ExpParser:_readIfSubExp()
     5   local lex = self._.lexer
         local tok, ln, col, cond, tcase, fcase

         --(1) read
     5   tok = lex:next(TokenType.KEYWORD, "if")
     5   ln, col = tok.line, tok.col
     5   cond = self:_readExp()
     5   lex:next(TokenType.KEYWORD, "then")
     4   tcase = self:_readExp()
     4   lex:next(TokenType.KEYWORD, "else")
     4   fcase = self:_readExp()
     4   lex:next(TokenType.KEYWORD, "end")

         --(2) return
     3   return IfSubExp.new(ln, col, cond, tcase, fcase)
       end

       --Read a native(code) terminal.
       --
       --@return NativeFn
     1 function ExpParser:_readNative()
     3   local lex = self._.lexer
         local tok, ln, col, code

         --(1) read
     3   tok = lex:next(TokenType.KEYWORD, "native")
     3   ln, col = tok.line, tok.col
     3   lex:next(TokenType.SYMBOL, "(")
     3   code = lex:next(TokenType.LITERAL).value
     2   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return NativeFn.new(ln, col, code)
       end

       --Read a peval(Exp) terminal.
       --
       --@return PevalFn
     1 function ExpParser:_readPeval()
     4   local lex = self._.lexer
         local tok, ln, col, exp

         --(1) read
     4   tok = lex:next(TokenType.KEYWORD, "peval")
     4   ln, col = tok.line, tok.col
     4   lex:next(TokenType.SYMBOL, "(")
     4   exp = self:_readExp()
     3   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return PevalFn.new(ln, col, exp)
       end

       --Read a throw(Exp [, Exp]) terminal.
       --
       --@return ThrowFn
     1 function ExpParser:_readThrow()
     6   local lex = self._.lexer
         local tok, ln, col, args

         --(1) read
     6   tok = lex:next(TokenType.KEYWORD, "throw")
     6   ln, col = tok.line, tok.col
     6   lex:next(TokenType.SYMBOL, "(")

     6   args = {}
         while true do
    12     table.insert(args, self:_readExp())

    12     tok = lex:advance()
    12     if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
             break
           end

     6     lex:next(TokenType.SYMBOL, ",")
         end

     6   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     6   return ThrowFn.new(ln, col, args)
       end

       --Read a call arguments.
       --
       --@param exp:Exp  Current expression.
     1 function ExpParser:_readCallArgs(exp)
   103   local lex = self._.lexer
         local tok, call

         --(1) pre: read (
   103   tok = lex:next(TokenType.SYMBOL, "(")
   103   tok.value = "()"

         --(2) create operator
   103   call = CallOp.new(tok)
   103   exp:insert(call)

         --(3) read arguments
   103   tok = lex:advance()

   103   if tok.type == TokenType.SYMBOL and tok.value == ")" then
    22     lex:next()
    22     call.finished = true
         else
    81     local sep = ","

    81     if tok.type == TokenType.EOL then
     5       lex:next()
     5       sep = "\n"
           end

           while true do
    86       call:insert(self:_readExp())

    86       tok = lex:next()

    86       if tok.type == TokenType.SYMBOL and tok.value == ")" then
    77         call.finished = true
               break
             end

     9       if sep == "," then
     4         if tok.type ~= TokenType.SYMBOL and tok.value ~= "," then
     2           error(string.format(
     1             "on (%s, %s), comma expected for argument end or ) for call end.",
     1             tok.line,
                   tok.col
     1           ))
               end
     5       elseif sep == "\n" then
     5         if tok.type ~= TokenType.EOL then
     2           error(string.format(
     1             "on (%s, %s), end of line expected for argument end.",
     1             tok.line,
                   tok.col
     1           ))
               end

     4         tok = lex:advance()

     4         if tok.type == TokenType.SYMBOL and tok.value == ")" then
     2           lex:next()
     2           call.finished = true
                 break
               end
             end
           end
         end
       end

       --Read a literal list: [...].
       --
       --@return LiteralList
     1 function ExpParser:_readLiteralList()
    11   local lex = self._.lexer
         local tok, ln, col, items

         --(1) read [
    11   tok = lex:next(TokenType.SYMBOL, "[")
    11   ln, col = tok.line, tok.col

         --(2) read items]
    11   items = {}

    11   tok = lex:advance()
    11   if not (tok.type == TokenType.SYMBOL and tok.value == ']') then
           local sep

     9     if tok.type == TokenType.EOL then
     3       lex:next()
     3       sep = "\n"
           else
     6       sep = ","
           end

           while true do
    18       table.insert(items, self:_readExp())

    18       if sep == "," then
    12         tok = lex:advance()

    12         if tok.type == TokenType.SYMBOL and tok.value == "," then
     6           lex:next()
               else
                 break
               end
             else
     6         lex:next(TokenType.EOL)

     6         tok = lex:advance()
     6         if tok.type == TokenType.SYMBOL and tok.value == "]" then
                 break
               end
             end
           end
         end

    11   lex:next(TokenType.SYMBOL, "]")

         --(4) return
    11   return LiteralList.new(ln, col, items)
       end

       --Read a literal map: {...}.
       --
       --@return LiteralMap
     1 function ExpParser:_readLiteralMap()
    11   local lex = self._.lexer
         local tok, ln, col, entries

         --(1) read [
    11   tok = lex:next(TokenType.SYMBOL, "{")
    11   ln, col = tok.line, tok.col

         --(2) read entries}
    11   entries = {}

    11   tok = lex:advance()
    11   if not (tok.type == TokenType.SYMBOL and tok.value == '}') then
           local sep

     9     if tok.type == TokenType.EOL then
     4       lex:next()
     4       sep = "\n"
           else
     5       sep = ","
           end

           while true do
             local name, val

             --skip ends of line
    17       if sep == "\n" then
     8         tok = lex:advance()

     9         while tok and tok.type == TokenType.EOL do
     1           lex:next()
     1           tok = lex:advance()
               end
             end

             --read item
    17       name = lex:next(TokenType.NAME).value
    17       lex:next(TokenType.SYMBOL, "=")
    17       val = self:_readExp()

    17       table.insert(entries, {name = name, value = val})

    17       if sep == "," then
     9         tok = lex:advance()

     9         if tok.type == TokenType.SYMBOL and tok.value == "," then
     4           lex:next()
               else
                 break
               end
             else
     8         lex:next(TokenType.EOL)

     8         tok = lex:advance()
     8         if tok.type == TokenType.SYMBOL and tok.value == "}" then
                 break
               end
             end
           end
         end

    11   lex:next(TokenType.SYMBOL, "}")

         --(4) return
    11   return LiteralMap.new(ln, col, entries)
       end

       --Read a fn.
       --
       --@return LiteralFn
     1 function ExpParser:_readFn()
    11   local lex, stmt = self._.lexer, self._.stmtParser
         local tok, ln, col, params, rtype, rvar, body

         --(1) read
    11   tok = lex:next(TokenType.KEYWORD, "fn")
    11   ln, col = tok.line, tok.col

    11   params = stmt:_readFnParams()
    11   rvar = stmt:_readFnReturnVar()
    11   rtype = stmt:_readFnType()

    11   tok = lex:advance()
    11   if tok.type == TokenType.SYMBOL and tok.value == "=" then
     2     lex:next()
     2     body = self:_readExp()
     2     body = {ReturnStmt.new(body.ln, body.col, body)}
     2     lex:next(TokenType.KEYWORD, "end")
         else
     9     body = stmt:_readBody(3)
         end

         --(2) return
    11   return LiteralFn.new(ln, col, params, rtype, rvar, body)
       end

       --Read an indexing operator.
       --
       --@param exp:Exp  Expression to update.
     1 function ExpParser:_readIndexOp(exp)
    14   local lex = self._.lexer
         local tok, ln, col, init, fin

         --(1) read [Exp
    14   tok = lex:next(TokenType.SYMBOL, "[")
    14   ln, col = tok.line, tok.col
    14   init = self:next()

         --(2) read "", Exp" if existing
    14   tok = lex:advance()

    14   if tok.type == TokenType.SYMBOL and tok.value == "," then
     5     lex:next()
     5     fin = self:next()
         end

         --(3) read ]
    14   lex:next(TokenType.SYMBOL, "]")

         --(4) add
         local op

    14   if fin == nil then
     9     op = BinOp.new({line = ln, col = col, value = "[]"})
     9     exp:insert(op)
     9     op:insert(init.tree.root)
         else
     5     op = SliceOp.new({line = ln, col = col, value = "[]"})
     5     exp:insert(op)
     5     op:insert(init.tree.root)
     5     op:insert(fin.tree.root)
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/NodeType.lua
==============================================================================
     1 return {
     1   TERMINAL = "terminal",
     1   NON_TERMINAL = "non-terminal"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/NonTerminalType.lua
==============================================================================
     1 return {
     1   OP = 1,
     1   TREE = 2
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/Parser.lua
==============================================================================
       --imports
     1 local Lexer = require("dogma.lex.Lexer")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local DirectiveParser = require("dogma.syn.DirectiveParser")
     1 local ExpParser = require("dogma.syn.ExpParser")
     1 local StmtParser = require("dogma.syn.StmtParser")
     1 local UnpackParser = require("dogma.syn.UnpackParser")

       --A parser.
     1 local Parser = {}
     1 Parser.__index = Parser
     1 package.loaded[...] = Parser

       --Constructor.
     1 function Parser.new()
         local self

         --(1) create
   512   self = setmetatable({_ = {}}, Parser)
   512   self._.lexer = Lexer.new()
   512   self._.directiveParser = DirectiveParser.new(self)
   512   self._.expParser = ExpParser.new(self)
   512   self._.stmtParser = StmtParser.new(self)
   512   self._.unpackParser = UnpackParser.new(self)
   512   self._.expParser._.stmtParser = self._.stmtParser

         --(2) return
   512   return self
       end

       --Parse a given text.
       --
       --@param txt:string   Text to parse.
       --@param file?:string File name..
     1 function Parser:parse(txt, file)
   512   self._.lexer:scan(txt, file)
       end

       --Parse the next sentence.
       --
       --@return Sentence
     1 function Parser:next()
   886   local lex, stmter, unpacker, direr = self._.lexer, self._.stmtParser, self._.unpackParser, self._.directiveParser
         local sent, tok, annots

         --(1) remove white lines and read annotations
   886   annots = {}
   886   tok = lex:advance()
         while true do
  1051     if tok == nil then
             break
   807     elseif tok.type == TokenType.EOL then
   152       lex:next()
   655     elseif tok.type == TokenType.ANNOTATION then
    13       lex:next()
    13       table.insert(annots, tok.value)
           else
             break
           end

   165     tok = lex:advance()
         end

          --(2) parse next sentence
   886   tok = lex:advance()

   886   if tok ~= nil then
   642     if tok.type == TokenType.DIRECTIVE then
    14       if tok.value:find("^if") then
    14         sent = direr:nextIf()
             end
   628     elseif tok.type == TokenType.KEYWORD then
   304       if tok.value == "async" then
     6         sent = stmter:nextAsync()
   298       elseif tok.value == "break" then
     3         sent = stmter:nextBreak()
   295       elseif tok.value == "const" then
    14         tok = lex:advance(2)

    14         if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     3           sent = self._.unpackParser:next()
               else
    11           sent = stmter:nextConst()
               end
   281       elseif tok.value == "do" then
    11         sent = stmter:nextDo()
   270       elseif tok.value == "enum" then
    22         sent = stmter:nextEnum(annots)
   248       elseif tok.value == "export" or tok.value == "pub" or tok.value == "pvt" then
    38         tok = lex:advance(2)

    38         if tok.type == TokenType.KEYWORD then
    38           if tok.value == "const" then
    10             tok = lex:advance(3)

    10             if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     6               sent = unpacker:next()
                   else
     4               sent = stmter:nextConst()
                   end
    28           elseif tok.value == "enum" then
     7             sent = stmter:nextEnum(annots)
    21           elseif tok.value == "fn" then
     5             sent = stmter:nextFn(annots)
    16           elseif tok.value == "type" then
     3             sent = stmter:nextType(annots)
    13           elseif tok.value == "var" then
    12             tok = lex:advance(3)

    12             if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     8               sent = unpacker:next()
                   else
     4               sent = stmter:nextVar()
                   end
                 end
               end

    38         if not sent then
     1           error(string.format("invalid export/pub on (%s, %s).", tok.line, tok.col))
               end
   210       elseif tok.value == "fn" then
    64         sent = stmter:nextFn(annots)
   146       elseif tok.value == "for" then
    22         tok = lex:advance(2)

    22         if tok.type == TokenType.KEYWORD and tok.value == "each" then
    10           sent = stmter:nextForEach()
               else
    12           sent = stmter:nextFor()
               end
   124       elseif tok.value == "from" then
    10         sent = stmter:nextFrom()
   114       elseif tok.value == "if" then
    14         sent = stmter:nextIf()
   100       elseif tok.value == "next" then
     3         sent = stmter:nextNext()
    97       elseif tok.value == "return" then
    10         sent = stmter:nextReturn()
    87       elseif tok.value == "type" then
    11         sent = stmter:nextType(annots)
    76       elseif tok.value == "use" then
    18         sent = stmter:nextUse()
    58       elseif tok.value == "var" then
    19         tok = lex:advance(2)

    19         if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     5           sent = self._.unpackParser:next()
               else
    14           sent = stmter:nextVar()
               end
    39       elseif tok.value == "while" then
    18         sent = stmter:nextWhile()
             end
           end

   625     if not sent and tok.type == TokenType.SYMBOL and (tok.value == "[" or tok.value == "{") then
    17       sent = self._.unpackParser:next()
           end

   624     if not sent then
   328       sent = self:nextExp()
           end
         end

         --(3) return
   862   return sent
       end

       --Read the next expression.
       --
       --@return Exp
     1 function Parser:nextExp()
   501   return self._.expParser:next()
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/SentType.lua
==============================================================================
     1 return {
     1   EXP = "exp",
     1   STMT = "stmt",
     1   UNPACK = "unpack",
     1   DIRECTIVE = "directive"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SentType = require("dogma.syn.SentType")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local BlockParser = require("dogma.syn._.BlockParser")
     1 local BreakStmt = require("dogma.syn._.BreakStmt")
     1 local ConstStmt = require("dogma.syn._.ConstStmt")
     1 local EnumStmt = require("dogma.syn._.EnumStmt")
     1 local NextStmt = require("dogma.syn._.NextStmt")
     1 local ReturnStmt = require("dogma.syn._.ReturnStmt")
     1 local UseStmt = require("dogma.syn._.UseStmt")
     1 local FromStmt = require("dogma.syn._.FromStmt")
     1 local VarStmt = require("dogma.syn._.VarStmt")
     1 local WhileStmt = require("dogma.syn._.WhileStmt")
     1 local DoStmt = require("dogma.syn._.DoStmt")
     1 local ForEachStmt = require("dogma.syn._.ForEachStmt")
     1 local ForStmt = require("dogma.syn._.ForStmt")
     1 local CatchCl = require("dogma.syn._.CatchCl")
     1 local FinallyCl = require("dogma.syn._.FinallyCl")
     1 local FnStmt = require("dogma.syn._.FnStmt")
     1 local TypeStmt = require("dogma.syn._.TypeStmt")
     1 local Param = require("dogma.syn._.Param")
     1 local Params = require("dogma.syn._.Params")
     1 local AsyncStmt = require("dogma.syn._.AsyncStmt")
     1 local IfStmt = require("dogma.syn._.IfStmt")
     1 local Exp = require("dogma.syn._.Exp")
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --Parser for the Dogma statements.
     1 local StmtParser = {}
     1 StmtParser.__index = StmtParser
     1 setmetatable(StmtParser, {__index = SubParser})
     1 package.loaded[...] = StmtParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function StmtParser.new(parser)
         local self

         --(1) create
   512   self = setmetatable(SubParser.new(parser), StmtParser)
   512   self._.expParser = parser._.expParser

         --(2) return
   512   return self
       end

       --Read a const statement.
       --
       --@return ConstStmt
     1 function StmtParser:nextConst()
    15   local lexer, exper = self._.lexer, self._.expParser
         local tok, ln, col, visib, stmt, sep

         --(1) read visibility
    15   tok = lexer:advance()
    15   ln, col = tok.line, tok.col

    15   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     4     lexer:next()
     4     visib = tok.value
         end

         --(2) read
    15   lexer:next(TokenType.KEYWORD, "const")
    15   stmt = ConstStmt.new(ln, col, visib)

         --(3) get separator
    15   tok = lexer:advance()

    15   if tok.type == TokenType.EOL then
     5     sep = "\n"
     5     lexer:next()
         else
    10     sep = ","
         end

         --(4) get variables
         while true do
           local name, val

           --read name
    23     tok = lexer:advance()

    23     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

    18     name = lexer:next(TokenType.NAME).value

           --read value
    18     lexer:next(TokenType.SYMBOL, "=")
    17     val = exper:next()

           --insert variable
    17     stmt:insert(name, val)

           --read separator
    17     if sep == "\n" then
     5       lexer:next(TokenType.EOL)
           else  --using comma as separator
    12       tok = lexer:next()

    12       if tok.type == TokenType.EOL then
               break
             end

     4       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating variables.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(5) return
    13   return stmt
       end

       --Read a break statement.
       --
       --@return BreakStmt
     1 function StmtParser:nextBreak()
     3   local lexer = self._.lexer
         local tok, stmt

         --(1) read
     3   tok = lexer:next(TokenType.KEYWORD, "break")
     3   stmt = BreakStmt.new(tok.line, tok.col)

         --(2) get end of line
     3   lexer:next(TokenType.EOL)

         --(3) return
     2   return stmt
       end

       --Read a next statement.
       --
       --@return NextStmt
     1 function StmtParser:nextNext()
     3   local lexer = self._.lexer
         local tok, stmt

         --(1) read
     3   tok = lexer:next(TokenType.KEYWORD, "next")
     3   stmt = NextStmt.new(tok.line, tok.col)

         --(2) get end of line
     3   lexer:next(TokenType.EOL)

         --(3) return
     2   return stmt
       end

       --Read a return statement.
       --
       --@return ReturnStmt
     1 function StmtParser:nextReturn()
    10   local lex, exper = self._.lexer, self._.expParser
         local tok, stmt

         --(1) read
    10   tok = lex:next(TokenType.KEYWORD, "return")
    10   stmt = ReturnStmt.new(tok.line, tok.col)

         --(2) get values
    10   tok = lex:advance()

    10   if tok.type ~= TokenType.EOL then
     8     stmt:insert(exper:next())
         end

    10   lex:next(TokenType.EOL)

         --(3) return
    10   return stmt
       end

       --Read a use stament.
       --
       --@return UseStmt
     1 function StmtParser:nextUse()
    18   local lex = self._.lexer
         local tok, stmt, sep

         --(1) read
    18   tok = lex:next(TokenType.KEYWORD, "use")
    18   stmt = UseStmt.new(tok.line, tok.col)

         --(2) get separator
    18   tok = lex:advance()

    18   if tok.type == TokenType.EOL then
     6     sep = "\n"
     6     lex:next()
         else
    12     sep = ","
         end

         --(3) get variables
         while true do
           local type, path, name

    31     tok = lex:advance()

    31     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

           --type?
    25     tok = lex:advance()

    25     if tok.type == TokenType.KEYWORD and tok.value == "type" then
     3       lex:next()
     3       type = true
           else
    22       type = false
           end

           --path
    25     path = lex:next(TokenType.LITERAL).value

           --as
    25     tok = lex:advance()

    25     if tok.type == TokenType.KEYWORD and tok.value == "as" then
     9       lex:next()  --as
     9       name = lex:next(TokenType.NAME).value
           end

           --insert
    25     stmt:insert(type, path, name)

           --read separator
    24     if sep == "\n" then
     9       lex:next(TokenType.EOL)
           else  --using comma as separator
    15       tok = lex:next()

    15       if tok.type == TokenType.EOL then
               break
             end

     5       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating modules.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(4) return
    16   return stmt
       end

       --Read a from statement.
       --
       --@return FromStmt
     1 function StmtParser:nextFrom()
    10   local lex = self._.lexer
         local tok, ln, col, stmt

         --(1) read module
    10   tok = lex:next(TokenType.KEYWORD, "from")
    10   ln, col = tok.line, tok.col
    10   stmt = FromStmt.new(ln, col, lex:next(TokenType.LITERAL).value)

         --(2) items
    10   lex:next(TokenType.KEYWORD, "use")

         while true do
           local typ, name, as

           --(1) item
    16     tok = lex:advance()
    16     if tok.type == TokenType.KEYWORD and tok.value == "type" then
     3       typ = true
     3       lex:next()
           else
    13       typ = false
           end

    16     name = lex:next(TokenType.NAME).value

    16     tok = lex:advance()
    16     if tok.type == TokenType.KEYWORD and tok.value == "as" then
     6       lex:next()  --as
     6       as = lex:next(TokenType.NAME).value
           end

    16     stmt:insert(typ, name, as)

           --(2) end?
    16     tok = lex:advance()
    16     if tok.type == TokenType.EOL then
    10       lex:next()
             break
           else
     6       lex:next(TokenType.SYMBOL, ",")
           end
         end

         --(3) return
    10   return stmt
       end

       --Read a var statement.
       --
       --@return VarStmt
     1 function StmtParser:nextVar()
    18   local lexer, exper = self._.lexer, self._.expParser
         local tok, ln, col, stmt, visib, sep

         --(1) read visibility
    18   tok = lexer:advance()
    18   ln, col = tok.line, tok.col

    18   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     4     lexer:next()
     4     visib = tok.value
         end

         --(2) read
    18   lexer:next(TokenType.KEYWORD, "var")
    18   stmt = VarStmt.new(ln, col, visib)

         --(3) get separator
    18   tok = lexer:advance()

    18   if tok.type == TokenType.EOL then
     6     sep = "\n"
     6     lexer:next()
         else
    12     sep = ","
         end

         --(4) get variables
         while true do
           local name, val

           --read name
    28     tok = lexer:advance()

    28     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

    22     name = lexer:next(TokenType.NAME).value

           --read value
    22     tok = lexer:advance()

    22     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    13       lexer:next()
    13       val = exper:next()
           else
     9       val = nil
           end

           --insert variable
    22     stmt:insert(name, val)

           --read separator
    22     if sep == "\n" then
     6       lexer:next(TokenType.EOL)
           else  --using comma as separator
    16       tok = lexer:next()

    16       if tok.type == TokenType.EOL then
               break
             end

     5       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating variables.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(5) return
    17   return stmt
       end

       --Read a next statement.
       --
       --@return EnumStmt
     1 function StmtParser:nextEnum(annots)
    29   local lexer = self._.lexer
         local tok, ln, col, visib, name, stmt, sep

         --(1) create stmt
    29   tok = lexer:advance()
    29   ln, col = tok.line, tok.col

         --visibility
    29   if tok.type == TokenType.KEYWORD then
    29     if tok.value == "export" or tok.value == "pub" then
     7       lexer:next()
     7       visib = tok.value
           end
         end

         --enum Name
    29   lexer:next(TokenType.KEYWORD, "enum")
    29   name = lexer:next(TokenType.NAME).value

         --create
    28   stmt = EnumStmt.new(ln, col, annots, visib, name)

         --(2) read items
    28   tok = lexer:next()

    28   if tok.type == TokenType.SYMBOL and tok.value == "{" then
    11     sep = ","
    17   elseif tok.type == TokenType.EOL then
    16     sep = "\n"
         else
     1     error(string.format("invalid token on (%s, %s).", tok.line, tok.col))
         end

         while true do
           local item, value

    57     tok = lexer:advance()

    57     if tok == nil then
             break
           end

    43     if sep == "\n" and tok.col <= stmt.col then
             break
           end

           --name
    41     item = lexer:next(TokenType.NAME).value

           --value
    40     tok = lexer:advance()

    40     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    21       lexer:next()  --=
    21       value = lexer:next(TokenType.LITERAL).value
           else
    19       value = nil
           end

           --insert
    40     stmt:insert(item, value)

           --separator
    40     if sep == "," then
    21       tok = lexer:advance()

    21       if tok.type == TokenType.SYMBOL and tok.value == "}" then
    10         lexer:next()
               break
             else
    11         lexer:next(TokenType.SYMBOL, ",")
             end
           else
    19       lexer:next(TokenType.EOL)
           end
         end

         --(3) return
    26   return stmt
       end

       --Read a while statement.
       --
       --@return WhileStmt
     1 function StmtParser:nextWhile()
    18   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, btype, cond, iter, body, catch, fin

         --(1) read while keyword
    18   tok = lex:next(TokenType.KEYWORD, "while")
    18   ln, col = tok.line, tok.col

         --(2) read condition and iter
         --condition
    18   cond = parser:nextExp()

         --iter
    18   tok = lex:advance()

    18   if tok.type == TokenType.SYMBOL and tok.value == ";" then
     3     lex:next()
     3     iter = parser:nextExp()
         end

         --do
    18   lex:next(TokenType.KEYWORD, "do")

    18   tok = lex:advance()
    18   if tok.type == TokenType.EOL then
    13     lex:next()
    13     btype = 2
         else
     5     btype = 1
         end

         --(4) read rest
    18   body = self:_readBody(btype, col)
    18   catch = self:_readCatch(col)
    18   fin = self:_readFinally(col)

         --(5) return
    18   return WhileStmt.new(ln, col, cond, iter, body, catch, fin)
       end

       --Read a do statement.
       --
       --@return Dotmt
     1 function StmtParser:nextDo()
    11   local lexer, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, catch, fin

         --(1) read while keyword
    11   tok = lexer:next(TokenType.KEYWORD, "do")
    11   ln, col = tok.line, tok.col

    11   lexer:next(TokenType.DO)

         --(2) read body
    11   body = self:_readBody(2, col)

         --(3) read condition if existing
    11   tok = lexer:advance()

    11   if tok and tok.type == TokenType.KEYWORD and tok.value == "while" then
     4     lexer:next()
     4     cond = parser:nextExp()
     4     lexer:next(TokenType.EOL)
         end

         --(4) read rest
    11   catch = self:_readCatch(col)
    11   fin = self:_readFinally(col)

         --(5) return
    11   return DoStmt.new(ln, col, body, cond, catch, fin)
       end

       --Read for statement.
       --
       --@return ForStmt
     1 function StmtParser:nextFor()
    12   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, def, cond, iter, btype, body, catch, fin

         --(1) read for keyword
    12   tok = lex:next(TokenType.KEYWORD, "for")
    12   ln, col = tok.line, tok.col

         --(2) variables
    12   def = {}

         while true do
           local name, val

           --name [= value]
    17     name = lex:next(TokenType.NAME).value

    17     tok = lex:advance()
    17     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    10       lex:next()
    10       val = parser:nextExp()
           else
     7       val = nil
           end

    17     table.insert(def, {name = name, value = val})

           --end?
    17     tok = lex:advance()

    17     if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
             break
           end

     5     lex:next(TokenType.SYMBOL, ",")
         end

    12   lex:next(TokenType.SYMBOL, ";")

         --(3) cond
    12   cond = parser:nextExp()

         --(4) iter
    12   tok = lex:advance()
    12   if tok.type == TokenType.SYMBOL and tok.value == ";" then
     4     lex:next()
     4     iter = parser:nextExp()
         end

         --(5) rest
    12   lex:next(TokenType.KEYWORD, "do")

    12   tok = lex:advance()
    12   if tok.type == TokenType.EOL then
     1     lex:next()
     1     btype = 2
         else
    11     btype = 1
         end

    12   body = self:_readBody(btype, col)
    12   catch = self:_readCatch(col)
    12   fin = self:_readFinally(col)

         --(5) return
    12   return ForStmt.new(ln, col, def, cond, iter, body, catch, fin)
       end

       --Read for each statement.
       --
       --@return ForEachStmt
     1 function StmtParser:nextForEach()
    10   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, key, val, iter, btype, body, catch, fin

         --(1) read for each keywords
    10   tok = lex:next(TokenType.KEYWORD, "for")
    10   lex:next(TokenType.KEYWORD, "each")
    10   ln, col = tok.line, tok.col

         --key
    10   key = lex:next(TokenType.NAME).value

         --value
    10   tok = lex:advance()

    10   if tok.type == TokenType.SYMBOL and tok.value == "," then
     3     lex:next()
     3     val = lex:next(TokenType.NAME).value
         else
     7     val, key = key, nil
         end

         --(3) read iter
    10   lex:next(TokenType.KEYWORD, "in")
    10   iter = parser:nextExp()

         --(4) read rest
    10   lex:next(TokenType.KEYWORD, "do")

    10   tok = lex:advance()
    10   if tok.type == TokenType.EOL then
     8     lex:next()
     8     btype = 2
         else
     2     btype = 1
         end

    10   body = self:_readBody(btype, col)
    10   catch = self:_readCatch(col)
    10   fin = self:_readFinally(col)

         --(5) return
    10   return ForEachStmt.new(ln, col, key, val, iter, body, catch, fin)
       end

       --Read a body statement as, fo example, while, for, if, etc.
       --
       --@param btype:number Body type: 1, one line; 2, block; 3, between {}.
       --@param col:number   Column line where it starts.
       --
       --@return Sent[]
     1 function StmtParser:_readBody(btype, col)
   151   local parser = self._.parser
         local body

         --(1) read body
   151   if btype == 1 then
    19     body = {parser:next()}
   132   elseif btype == 2 then
   123     body = BlockParser.new(parser, col):next()
     9   elseif btype == 3 then
     9     body = BlockParser.new(parser):next()
         end

         --(2) return
   151   return body
       end

       --Read a catch clause.
       --
       --@param col:number Column number where this must start.
       --@return CatchCl
     1 function StmtParser:_readCatch(col)
   136   local lexer, parser = self._.lexer, self._.parser
         local tok, var, body

         --(1) read catch keyword
   136   tok = lexer:advance()

   136   if tok == nil or not (tok.type == TokenType.KEYWORD and tok.value == "catch" and tok.col == col) then
   117     return
         end

    19   lexer:next()

         --(2) read error variable name
    19   tok = lexer:advance()

    19   if tok.type == TokenType.NAME then
     4     lexer:next()
     4     var = tok.value
         end

    19   lexer:next(TokenType.EOL)

         --(3) read body
    19   body = BlockParser.new(parser, col):next()

         --(4) return
    19   return CatchCl.new(var, body)
       end

       --Read a finally clause.
       --
       --@param col:number Column number where this must start.
       --@return FinallyCl
     1 function StmtParser:_readFinally(col)
   131   local lexer, parser = self._.lexer, self._.parser
         local tok, body

         --(1) read finally keyword
   131   tok = lexer:advance()

   131   if tok == nil or not (tok.type == TokenType.KEYWORD and tok.value == "finally" and tok.col == col) then
   118     return
         end

    13   lexer:next()
    13   lexer:next(TokenType.EOL)

         --(2) read body
    13   body = BlockParser.new(parser, col):next()

         --(4) return
    13   return FinallyCl.new(body)
       end

       --Read a fn statement.
       --
       --@return FnStmt
     1 function StmtParser:nextFn(annots)
    69   local lexer = self._.lexer
         local tok, ln, col, visib, itype, name, params, rtype, rvar, body, catch, fin

         --(1) read visibility
    69   tok = lexer:advance()
    69   ln, col = tok.line, tok.col

    69   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub" or tok.value == "pvt") then
     5     lexer:next()
     5     visib = tok.value
         end

         --(2) read fn type.name
    69   lexer:next(TokenType.KEYWORD, "fn")
    69   name = lexer:next(TokenType.NAME).value

    69   tok = lexer:advance()
    69   if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
    16     lexer:next()
    16     visib = (tok.value == "." and "pub" or "pvt")
    16     itype = name
    16     name = lexer:next(TokenType.NAME).value
         end

         --(3) read parameters, return type and return variable
    69   params = self:_readFnParams()
    68   rvar = self:_readFnReturnVar()
    67   rtype = self:_readFnType()

         --(4) read body
    66   tok = lexer:advance()

    66   if tok.type == TokenType.SYMBOL and tok.value == "=" then
    12     lexer:next()
    12     body = {self._.expParser:_readExp()}

    12     if #body > 0 and body[1].type == SentType.EXP then
    12       local exp = body[1]

    12       body[1] = ReturnStmt.new(exp.line, exp.col)
    12       body[1]:insert(exp)
           end
         else
    54     lexer:next(TokenType.EOL)
    54     body = self:_readBody(2, col)
         end

         --(5) read rest
    66   catch = self:_readCatch(col)
    66   fin = self:_readFinally(col)

         --(6) return
    66   return FnStmt.new(ln, col, annots, visib, itype, name, params, rtype, rvar, body, catch, fin)
       end

       --Read the function parameters.
       --
       --@return Param[]
     1 function StmtParser:_readFnParams()
    94   local lex = self._.lexer
    94   local params = Params.new()
         local tok

         --(1) read (
    94   lex:next(TokenType.SYMBOL, "(")

         --(2) read params
    94   tok = lex:advance()

    94   if not (tok.type == TokenType.SYMBOL and tok.value == ")") then
           while true do
             local const, mod, name, opt, dtype, val

             --const
    69       tok = lex:advance()

    69       if tok.type == TokenType.KEYWORD and tok.value == "const" then
     2         lex:next()
     2         const = true
             else
    67         const = false
             end

             --$ or : or ...
    69       tok = lex:advance()

    69       if tok.type == TokenType.SYMBOL and
    14          (tok.value == "$" or tok.value == ":" or tok.value == "...") then
    14         lex:next()
    14         mod = tok.value
             end

             --name
    69       name = lex:next(TokenType.NAME).value

             --optional?
    69       tok = lex:advance()

    69       if tok.type == TokenType.SYMBOL and tok.value == "?" then
    15         lex:next()
    15         opt = true
             end

             --type
    69       tok = lex:advance()

    69       if tok.type == TokenType.SYMBOL and tok.value == ":" then
    15         dtype = self:_readFnParamType()
             else
    54         dtype = nil
             end

             --default value
    69       tok = lex:advance()

    69       if tok.type == TokenType.SYMBOL and tok.value == "=" then
     4         val = self:_readFnParamValue()
    65       elseif tok.type == TokenType.SYMBOL and tok.value == ":=" then
     5         val, dtype = self:_readFnParamValueWithInference()
             end

             --insert param
    68       params:insert(Param.new(const, mod, name, opt, dtype, val))

             --,
    68       tok = lex:advance()

    68       if tok.type == TokenType.SYMBOL and tok.value == "," then
    16         lex:next()
             else
               break
             end
           end
         end

         --(3) read close
    93   lex:next(TokenType.SYMBOL, ")")

         --(4) return
    93   return params
       end

       --Read the parameter type.
       --
       --@return string
     1 function StmtParser:_readFnParamType()
    15   local lex = self._.lexer
         local tok, dtype

         --(1) read
    15   lex:next(TokenType.SYMBOL, ":")

    15   tok = lex:advance()
    15   if tok.type == TokenType.SYMBOL and tok.value == "{" then
     7     lex:next()

     7     dtype = {}

     7     tok = lex:advance()
     7     if tok.type == TokenType.SYMBOL and tok.value == "}" then
     2       lex:next()
           else
             while true do
               --read field
               local pname, ptype

     8         pname = lex:next(TokenType.NAME).value

     8         tok = lex:advance()
     8         if tok.type == TokenType.SYMBOL and tok.value == ":" then
     5           lex:next()
     5           ptype = lex:next(TokenType.NAME).value
               else
     3           ptype = "any"
               end

     8         table.insert(dtype, {name = pname, type = ptype})

               --read next or end
     8         tok = lex:advance()
     8         if tok.type == TokenType.SYMBOL and tok.value == "}" then
     5           lex:next()
                 break
               end

     3         lex:next(TokenType.SYMBOL, ",")
             end --while
           end
         else
     8     dtype = lex:next(TokenType.NAME).value
         end

         --(2) return
    15   return dtype
       end

       --Read the parameter value wihtout inference.
       --
       --@return string
     1 function StmtParser:_readFnParamValue()
     4   self._.lexer:next(TokenType.SYMBOL, "=")
     4   return self._.parser:nextExp()
       end

       --Read the parameter value using inference.
       --
       --@return val, type
     1 function StmtParser:_readFnParamValueWithInference()
     5   local lex = self._.lexer
         local tok, val, dtype

         --(1) read
     5   lex:next(TokenType.SYMBOL, ":=")
     5   tok = lex:next()

     5   if tok.type == TokenType.LITERAL and type(tok.value) == "string" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.TEXT, tok))
     1     dtype = "text"
     4   elseif tok.type == TokenType.LITERAL and type(tok.value) == "number" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.NUM, tok))
     1     dtype = "num"
     3   elseif tok.type == TokenType.KEYWORD and tok.value == "true" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.TRUE, tok))
     1     dtype = "bool"
     2   elseif tok.type == TokenType.KEYWORD and tok.value == "false" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.FALSE, tok))
     1     dtype = "bool"
         else
     2     error(string.format(
     1       "on (%s, %s), for infering type, the default value must be a literal: text, num or bool.",
     1       tok.line,
             tok.col
     1     ))
         end

         --(2) return
     4   return val, dtype
       end

       --Read the function return type.
       --
       --@return string
     1 function StmtParser:_readFnType()
    78   local lex = self._.lexer
         local tok, rtype

         --(1) read
    78   tok = lex:advance()

    78   if tok.type == TokenType.SYMBOL and tok.value == ":" then
     3     lex:next()  --:
     3     rtype = lex:next(TokenType.NAME).value
         end

         --(2) return
    77   return rtype
       end

       --Read the function return variable.
       --
       --@return string
     1 function StmtParser:_readFnReturnVar()
    79   local lex = self._.lexer
         local tok, rvar

         --(1) read
    79   tok = lex:advance()

    79   if tok.type == TokenType.SYMBOL and tok.value == "->" then
    12     lex:next()  -- ->
    12     tok = lex:next()

    12     if tok.type == TokenType.KEYWORD and tok.value == "self" then
     3       rvar = "self"
     9     elseif tok.type == TokenType.NAME then
     8       rvar = tok.value
           else
     2       error(string.format(
     1         "on (%s, %s), return value must be 'self' or a name.",
     1         tok.line,
               tok.col
     1       ))
           end
         end

         --(2) return
    78   return rvar
       end

       --Read a type statement.
       --
       --@return TypeStmt
     1 function StmtParser:nextType(annots)
    14   local lexer, parser = self._.lexer, self._.parser
         local tok, ln, col, visib, name, params, btype, bargs, body, catch, fin

         --(1) read visibility
    14   tok = lexer:advance()
    14   ln, col = tok.line, tok.col

    14   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     3     lexer:next()
     3     visib = tok.value
         end

         --(2) read type name
    14   lexer:next(TokenType.KEYWORD, "type")
    14   name = lexer:next(TokenType.NAME).value

         --(3) read parameters
    14   params = self:_readFnParams()

         --(4) read base type
    14   tok = lexer:advance()

    14   if tok.type == TokenType.SYMBOL and tok.value == ":" then
     5     lexer:next()
     5     btype = lexer:next(TokenType.NAME).value

     5     tok = lexer:advance()
     5     if tok.type == TokenType.SYMBOL and tok.value == "(" then
     3       lexer:next()
     3       bargs = {}

     3       tok = lexer:advance()
     3       if not (tok.type == TokenType.SYMBOL and tok.value == ")") then
               while true do
     4           table.insert(bargs, parser:nextExp())

     4           tok = lexer:advance()
     4           if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
                   break
                 end

     2           lexer:next(TokenType.SYMBOL, ",")
               end
             end

     3       lexer:next(TokenType.SYMBOL, ")")
           end
         end

         --(5) read body
    14   lexer:next(TokenType.EOL)
    14   body = self:_readBody(2, col)

         --(6) read rest
    14   catch = self:_readCatch(col)
    14   fin = self:_readFinally(col)

         --(6) return
    14   return TypeStmt.new(ln, col, annots, visib, name, params, btype, bargs, body, catch, fin)
       end

       --Read an async statement.
       --
       --@return AsyncStmt
     1 function StmtParser:nextAsync()
     6   local lexer = self._.lexer
         local tok, ln, col, body, catch

         --(1) read async keyword
     6   tok = lexer:next(TokenType.KEYWORD, "async")
     6   ln, col = tok.line, tok.col

         --(2) read body
     6   tok = lexer:advance()

     6   if tok.type == TokenType.EOL then
     5     lexer:next()
     5     body = self:_readBody(2, col)
     5     catch = self:_readCatch(col)
         else
     1     body = self:_readBody(1, col)
         end

         --(3) return
     6   return AsyncStmt.new(ln, col, body, catch)
       end

       --Read an if statement.
       --
       --@return IfStmt
     1 function StmtParser:nextIf()
    14   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, elif, el

         --(1) read if keyword
    14   tok = lex:next(TokenType.KEYWORD, "if")
    14   ln, col = tok.line, tok.col

         --.(2) read condition
    14   cond = parser:nextExp()
    14   lex:next(TokenType.KEYWORD, "then")

    14   tok = lex:advance()

    14   if tok.type ~= TokenType.EOL then
     7     body = {parser:next()}

     7     tok = lex:advance()
     7     if tok and tok.type == TokenType.KEYWORD and tok.value == "else" then
     3       lex:next()
     3       el = {parser:next()}
           end
         else
     7     lex:next(TokenType.EOL)
     7     body = self:_readBody(2, col)

           while true do
    17       tok = lex:advance()

    17       if tok == nil or tok.col ~= col then
               break
             end

    10       if tok.type == TokenType.KEYWORD and tok.value == "else" then
    10         tok = lex:advance(2)

    10         if tok.type == TokenType.KEYWORD and tok.value == "if" then
                 local c, b

     7           lex:next()  --else
     7           lex:next()  --if
     7           c = parser:nextExp()
     7           lex:next(TokenType.KEYWORD, "then")
     7           lex:next(TokenType.EOL)
     7           b = self:_readBody(2, col)

     7           if elif == nil then
     5             elif = {}
                 end

     7           table.insert(elif, {cond = c, body = b})
               else
     3           lex:next()  --else
     3           el = self:_readBody(2, col)
               end
             else
               break
             end
           end
         end

         --(3) return
    14   return IfStmt.new(ln, col, cond, body, elif, el)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtType.lua
==============================================================================
     1 return {
     1   ASYNC = "async",
     1   BREAK = "break",
     1   CONST = "const",
     1   DO = "do",
     1   ENUM = "enum",
     1   FN = "fn",
     1   FOR = "for",
     1   FOR_EACH = "for each",
     1   FROM = "from",
     1   IF = "if",
     1   NEXT = "next",
     1   RETURN = "return",
     1   TYPE = "type",
     1   USE = "use",
     1   VAR = "var",
     1   WHILE = "while",
     1   YIELD = "yield"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/TerminalType.lua
==============================================================================
     1 return {
     1   NAME = 1,
     1   NUM = 2,
     1   TEXT = 3,
     1   TRUE = 4,
     1   FALSE = 5,
     1   NIL = 6,
     1   LIST = 7,
     1   MAP = 8,
     1   SELF = 9,
     1   SUPER = 10,
     1   FN = 11,
     1   SUBEXP = 12,
     1   IF = 13,
     1   PEVAL = 14,
     1   THROW = 15,
     1   NOP = 16,
     1   NATIVE = 17
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/UnpackParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local Unpack = require("dogma.syn._.Unpack")

       --An unpack sentence parser.
     1 local UnpackParser = {}
     1 UnpackParser.__index = UnpackParser
     1 setmetatable(UnpackParser, {__index = SubParser})
     1 package.loaded[...] = UnpackParser

       --Constructor.
       --
       --@param parser:Parser  Parent parser.
     1 function UnpackParser.new(parser)
   512   return setmetatable(SubParser.new(parser), UnpackParser)
       end

       --Parse the next unpack sentence.
       --
       --@return Unpack
     1 function UnpackParser:next()
    39   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, visib, def, typ, vars, assign, exp

         --(1) read visibility if needed
    39   tok = lex:advance()
    39   ln, col = tok.line, tok.col

    39   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
    14     lex:next()
    14     visib = tok.value
         end

         --(2) get type definition
    39   tok = lex:advance()

    39   if tok.type == TokenType.KEYWORD and (tok.value == "var" or tok.value == "const") then
    22     lex:next()
    22     def = tok.value
         end

         --(3) get type
    39   tok = lex:next()

    39   if tok.type == TokenType.SYMBOL and tok.value == "[" then
    23     typ = "[]"
         else
    16     typ = "{}"
         end

         --(4) get vars
    39   vars = {}

         while true do
           local rest, name, val

           --rest?
    89     tok = lex:advance()
    89     if tok.type == TokenType.SYMBOL and tok.value == "..." then
     3       rest = true
     3       lex:next()
           else
    86       rest = false
           end

           --name
    89     tok = lex:advance()
    89     if tok.type == TokenType.SYMBOL and (tok.value == "$" or tok.value == ":") then
    10       name = tok.value
    10       lex:next()
           else
    79       name = ""
           end

    89     name = name .. lex:next(TokenType.NAME).value

           --default value
    89     tok = lex:advance()

    89     if tok.type == TokenType.SYMBOL and tok.value == "=" then
     8       lex:next()
     8       val = parser:nextExp()
           else
    81       val = nil
           end

           --insert
    89     table.insert(vars, {rest = rest, name = name, value = val})

           --comma or end
    89     tok = lex:advance()

    89     if typ == "[]" then
    57       if tok.type == TokenType.SYMBOL and tok.value == "]" then
    23         lex:next()
               break
             end
    32     elseif typ == "{}" then
    32       if tok.type == TokenType.SYMBOL and tok.value == "}" then
    16         lex:next()
               break
             end
           end

    50     lex:next(TokenType.SYMBOL, ",")
         end

         --(5) expression
    39   tok = lex:advance()
    39   if not (tok.type == TokenType.SYMBOL and (tok.value == "=" or tok.value == ":=")) then
     1     error(string.format("on (%s,%s), = or := expected.", tok.line, tok.col))
         end

    38   lex:next()
    38   assign = tok.value
    38   exp = parser:nextExp()
    38   lex:next(TokenType.EOL)

         --(6) return
    38   return Unpack.new(ln, col, visib, def, typ, vars, assign, exp)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AsyncStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An async statement.
     1 local AsyncStmt = {}
     1 AsyncStmt.__index = AsyncStmt
     1 setmetatable(AsyncStmt, {__index = Stmt})
     1 package.loaded[...] = AsyncStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param body:Sent[]
       --@param catch:CatchCls
     1 function AsyncStmt.new(ln, col, body, catch)
         local self

         --(1) create
     6   self = setmetatable(Stmt.new(StmtType.ASYNC, ln, col), AsyncStmt)
     6   self.body = body
     6   self.catch = catch

         --(2) return
     6   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BinOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A binary operator.
     1 local BinOp = {}
     1 BinOp.__index = BinOp
     1 setmetatable(BinOp, {__index = Op})
     1 package.loaded[...] = BinOp

       --Constructor.
       --
       --@param tok:Token
     1 function BinOp.new(tok)
         local self

         --(1) create
   404   self = setmetatable(Op.new("b", tok), BinOp)
   404   self.children = {}

         --(2) return
   404   return self
       end

       --@override
     1 function BinOp:insert(node)
         -- if #self.children == 2 then
         --   error("children already set.")
         -- end

   830   table.insert(self.children, node)
   830   node.parent = self
       end

       --@override
     1 function BinOp:remove(node)
         -- if #self.children == 0 then
         --   error("no child to remove from the operator.")
         -- end

    25   return table.remove(self.children)
       end

       --@override
     1 function BinOp:isWellFormed()
   843   return #self.children == 2
       end

       --@override
     1 function BinOp:__tostring()
   346   return string.format("(%s %s %s)", self.op, self.children[1], self.children[2])
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BlockParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SubParser = require("dogma.syn._.SubParser")

       --An expression parser.
     1 local BlockParser = {}
     1 BlockParser.__index = BlockParser
     1 setmetatable(BlockParser, {__index = SubParser})
     1 package.loaded[...] = BlockParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
       --@param col:number     Column number.
     1 function BlockParser.new(parser, col)
         local self

   164   self = setmetatable(SubParser.new(parser), BlockParser)
   164   if col == nil then
     9     self._.col = 0
     9     self._.type = "end"
         else
   155     self._.col = col
   155     self._.type = "\n"
         end

   164   return self
       end

       --Parse the next block.
       --
       --@return Sent[]
     1 function BlockParser:next()
   164   local lex, parser, btype = self._.lexer, self._.parser, self._.type
         local tok
   164   local col, block = self._.col, {}

         --(1) see if empty function
   164   if btype == "end" then
     9     tok = lex:advance()

     9     if tok.type == TokenType.KEYWORD and tok.value == "end" then
     7       lex:next()
     7       return block
           end
         end

         --(1) read
         while true do
           local sent

   262     tok = lex:advance()

           --remove white lines
   369     while tok and tok.type == TokenType.EOL do
   107       lex:next()
   107       tok = lex:advance()
           end

   262     if btype == "end" and tok and tok.type == TokenType.KEYWORD and tok.value == "end" then
             break
           end

   260     if tok == nil or tok.col <= col then
             break
           end

           --parse next sentence
   105     sent = parser:next()

   105     if sent then
   105       table.insert(block, sent)
           else
             break
           end
         end

         --(3) read } if needed
   157   if btype == "end" then
     2     lex:next(TokenType.KEYWORD, "end")
         end

         --(3) return
   157   return block
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BreakStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A break statement.
     1 local BreakStmt = {}
     1 BreakStmt.__index = BreakStmt
     1 setmetatable(BreakStmt, {__index = Stmt})
     1 package.loaded[...] = BreakStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function BreakStmt.new(ln, col)
     3   return setmetatable(Stmt.new(StmtType.BREAK, ln, col), BreakStmt)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CallOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A ternary operator.
     1 local CallOp = {}
     1 CallOp.__index = CallOp
     1 setmetatable(CallOp, {__index = Op})
     1 package.loaded[...] = CallOp

       --Constructor.
       --
       --@param tok:Token
     1 function CallOp.new(tok)
         local self

         --(1) create
   105   self = setmetatable(Op.new("n", tok), CallOp)
   105   self.children = {}
   105   self.finished = false

         --(2) return
   105   return self
       end

       --@override
     1 function CallOp:insert(node)
   190   if self.finished then
     2     error(string.format(
     1       "(%s,%s): node can't be inserted to full call.",
     1       node.tok.line,
     1       node.tok.col
     1     ))
         end

   189   table.insert(self.children, node)
       end

       --@override
     1 function CallOp.remove()
     1   error("call operator can't remove children.")
       end

       --@override
     1 function CallOp:isWellFormed()
   103   return self.finished
       end

       --@override
     1 function CallOp:__tostring()
         local ops

         --(1) get expressions
    74   ops = ""
   206   for _, op in ipairs(self.children) do
   132     ops = ops .. (ops == "" and "" or " ") .. op:__tostring()
         end

         --(2) return
    74   return string.format("(call %s)", ops)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CatchCl.lua
==============================================================================
       --A catch clause.
     1 local CatchCl = {}
     1 CatchCl.__index = CatchCl
     1 package.loaded[...] = CatchCl

       --Constructor.
       --
       --@param var:string Exception variable name.
       --@param body:Body  Body sentences.
     1 function CatchCl.new(var, body)
    38   return setmetatable({
    19     var = var,
    19     body = body
    38   }, CatchCl)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ConstStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A var statement.
     1 local ConstStmt = {}
     1 ConstStmt.__index = ConstStmt
     1 setmetatable(ConstStmt, {__index = Stmt})
     1 package.loaded[...] = ConstStmt

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param visib:string Visibility: export or pub.
     1 function ConstStmt.new(ln, col, visib)
         local self

         --(1) create
    15   self = setmetatable(Stmt.new(StmtType.CONST, ln, col), ConstStmt)
    15   self.vars = {}
    15   self.visib = visib

         --(2) return
    15   return self
       end

       --Add a variable declaration.
       --
       --@param name:string  Variable name.
       --@param val?:Exp     Default value.
     1 function ConstStmt:insert(name, val)
    17   table.insert(self.vars, {name = name, value = val})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Directive.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --A directive.
       --@abstract
     1 local Directive = {}
     1 Directive.__index = Directive
     1 setmetatable(Directive, {__index = Sent})
     1 package.loaded[...] = Directive

       --Constructor.
       --
       --@param subtype:DirectiveType  Directive type.
       --@param ln:number              Line number.
       --@param col:number             Column number.
     1 function Directive.new(subtype, ln, col)
         local self

         --(1) create
    11   self = setmetatable(Sent.new(SentType.DIRECTIVE, ln, col), Directive)
    11   self.subtype = subtype

         --(2) return
    11   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DoStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A while statement.
     1 local DoStmt = {}
     1 DoStmt.__index = DoStmt
     1 setmetatable(DoStmt, {__index = Stmt})
     1 package.loaded[...] = DoStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param body:Sent[]
       --@param cond?:Exp
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function DoStmt.new(ln, col, body, cond, catch, fin)
         local self

         --(1) create
    11   self = setmetatable(Stmt.new(StmtType.DO, ln, col), DoStmt)
    11   self.body = body
    11   self.cond = cond
    11   self.catch = catch
    11   self.finally = fin

         --(2) return
    11   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/EnumStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An enum statement.
     1 local EnumStmt = {}
     1 EnumStmt.__index = EnumStmt
     1 setmetatable(EnumStmt, {__index = ObjectStmt})
     1 package.loaded[...] = EnumStmt

       --Constructor.
     1 function EnumStmt.new(ln, col, annots, visib, name)
         local self

         --(1) create
    28   self = setmetatable(ObjectStmt.new(StmtType.ENUM, ln, col, name, visib), EnumStmt)
    28   self.items = {}
    28   self.annots = annots or {}
    28   self._.lastValue = nil

         --(2) return
    28   return self
       end

       --Insert an item.
       --
       --@param item:string    Item name.
       --@param value:any      Item value.
     1 function EnumStmt:insert(item, value)
         --(1) set value if needed
    40   if value == nil then
    19     if self._.lastValue == nil then
    11       self._.lastValue = 1
           else
     8       self._.lastValue = self._.lastValue + 1
           end

    19     value = self._.lastValue
         end

         --(2) insert
    40   table.insert(self.items, {name = item, value = value})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Exp.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")
     1 local SyntaxTree = require("dogma.syn._.SyntaxTree")

       --An expression.
     1 local Exp = {}
     1 Exp.__index = Exp
     1 setmetatable(Exp, {__index = Sent})
     1 package.loaded[...] = Exp

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function Exp.new(ln, col)
         local self

         --(1) create
   738   self = setmetatable(Sent.new(SentType.EXP, ln, col), Exp)
   738   self.tree = SyntaxTree.new()

         --(2) return
   738   return self
       end

       --Add a new node to the expression.
       --
       --@param node:Node  Node to add.
     1 function Exp:insert(node)
  1670   self.tree:insert(node)
       end

       --@override
     1 function Exp:__tostring()
   658   return self.tree:__tostring()
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FinallyCl.lua
==============================================================================
       ----A finally clause.
     1 local FinallyCl = {}
     1 FinallyCl.__index = FinallyCl
     1 package.loaded[...] = FinallyCl

       --Constructor.
       --
       --@param body:Body  Body sentences.
     1 function FinallyCl.new(body)
    26   return setmetatable({
    13     body = body
    26   }, FinallyCl)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FnStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A fn statement.
     1 local FnStmt = {}
     1 FnStmt.__index = FnStmt
     1 setmetatable(FnStmt, {__index = ObjectStmt})
     1 package.loaded[...] = FnStmt

       --Constructor.
     1 function FnStmt.new(ln, col, annots, visib, itype, name, params, rtype, rvar, body, catch, fin)
         local self

         --(1) create
    66   self = setmetatable(ObjectStmt.new(StmtType.FN, ln, col, name, visib), FnStmt)
    66   self.itype = itype
    66   self.params = params
    66   self.rtype = rtype
    66   self.rvar = rvar
    66   self.body = body
    66   self.catch = catch
    66   self.finally = fin
    66   self.annots = annots or {}

         --(2) return
    66   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForEachStmt.lua
==============================================================================
       --Imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A for each statement.
     1 local ForEachStmt = {}
     1 ForEachStmt.__index = ForEachStmt
     1 setmetatable(ForEachStmt, {__index = Stmt})
     1 package.loaded[...] = ForEachStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param key?:string
       --@param value:string
       --@param iter:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function ForEachStmt.new(ln, col, key, val, iter, body, catch, fin)
         local self

         --(1) create
    10   self = setmetatable(Stmt.new(StmtType.FOR_EACH, ln, col), ForEachStmt)
    10   self.key = key
    10   self.value = val
    10   self.iter = iter
    10   self.body = body
    10   self.catch = catch
    10   self.finally = fin

         --(2) return
    10   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForStmt.lua
==============================================================================
       --Imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A for statement.
     1 local ForStmt = {}
     1 ForStmt.__index = ForStmt
     1 setmetatable(ForStmt, {__index = Stmt})
     1 package.loaded[...] = ForStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param def:VarStmt
       --@param cond:Exp
       --@param iter:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function ForStmt.new(ln, col, def, cond, iter, body, catch, fin)
         local self

         --(1) create
    12   self = setmetatable(Stmt.new(StmtType.FOR, ln, col), ForStmt)
    12   self.def = def
    12   self.cond = cond
    12   self.iter = iter
    12   self.body = body
    12   self.catch = catch
    12   self.finally = fin

         --(2) return
    12   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FromStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A from statement.
     1 local FromStmt = {}
     1 FromStmt.__index = FromStmt
     1 setmetatable(FromStmt, {__index = Stmt})
     1 package.loaded[...] = FromStmt

       --Constructor.
     1 function FromStmt.new(ln, col, mod)
         local self

         --(1) create
    10   self = setmetatable(Stmt.new(StmtType.FROM, ln, col), FromStmt)
    10   self.module = mod
    10   self.members = {}

         --(2) return
    10   return self
       end

       --Insert an imported member.
       --
       --@param type:bool    Is a type?
       --@param name:string  Member name to import.
       --@param as?:string   Name to use in the code.
     1 function FromStmt:insert(type, name, as)
    16   table.insert(self.members, {type = type, name = name, as = as or name})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfDirective.lua
==============================================================================
       --imports
     1 local Directive = require("dogma.syn._.Directive")
     1 local DirectiveType = require("dogma.syn.DirectiveType")

       --An if directive.
     1 local IfDirective = {}
     1 IfDirective.__index = IfDirective
     1 setmetatable(IfDirective, {__index = Directive})
     1 package.loaded[...] = IfDirective

       --Constructor.
     1 function IfDirective.new(ln, col, cond, body, el)
         local self

         --(1) create
    11   self = setmetatable(Directive.new(DirectiveType.IF, ln, col), IfDirective)
    11   self.cond = cond
    11   self.body = body
    11   self.el = el

         --(2) return
    11   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfStmt.lua
==============================================================================
       --importsa
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An if statement.
     1 local IfStmt = {}
     1 IfStmt.__index = IfStmt
     1 setmetatable(IfStmt, {__index = Stmt})
     1 package.loaded[...] = IfStmt

       --Constructor.
     1 function IfStmt.new(ln, col, cond, body, elif, el)
         local self

         --(1) create
    14   self = setmetatable(Stmt.new(StmtType.IF, ln, col), IfStmt)
    14   self.cond = cond
    14   self.body = body
    14   self.elif = elif
    14   self.el = el

         --(2) return
    14   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfSubExp.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An (if Exp then Exp else Exp) subexpression.
     1 local IfSubExp = {}
     1 IfSubExp.__index = IfSubExp
     1 setmetatable(IfSubExp, {__index = Terminal})
     1 package.loaded[...] = IfSubExp

       --Constructor.
     1 function IfSubExp.new(ln, col, cond, ifTrue, ifFalse)
         local self

         --(1) create
     3   self = setmetatable(Terminal.new(TerminalType.IF, {line = ln, col = col}), IfSubExp)
     3   self.cond = cond
     3   self.trueCase = ifTrue
     3   self.falseCase = ifFalse

         --(2) return
     3   return self
       end

       --@override
     1 function IfSubExp:__tostring()
     4   return string.format(
     2     "(if %s %s %s)",
     2     tostring(self.cond),
     2     tostring(self.trueCase),
     2     tostring(self.falseCase)
     2   )
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An array terminal node.
     1 local LiteralFn = {}
     1 LiteralFn.__index = LiteralFn
     1 setmetatable(LiteralFn, {__index = Terminal})
     1 package.loaded[...] = LiteralFn

       --Constructor.
     1 function LiteralFn.new(ln, col, params, rtype, rvar, body)
         local self

    33   self = setmetatable(Terminal.new(TerminalType.FN, {
    11     line = ln,
    11     col = col,
    11     value = {
    11       params = params,
    11       type = rtype,
    11       rvar = rvar,
    11       body = body
    11     }
    22   }), LiteralFn)

    11   return self
       end

       --@override
     1 function LiteralFn:__tostring()
         local desc

    24   desc = "fn("
    48   for i, p in ipairs(self.data.params) do
    24     desc = desc .. (i == 1 and "" or ", ") .. p.name
         end
    24   desc = desc .. ")"

    24   desc = desc .. "{"
    48   for i, s in ipairs(self.data.body) do
    24     desc = desc .. (i == 1 and "" or "; ") .. tostring(s)
         end
    24   desc = desc .. "}"

    24   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralList.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A literal list node.
     1 local LiteralList = {}
     1 LiteralList.__index = LiteralList
     1 setmetatable(LiteralList, {__index = Terminal})
     1 package.loaded[...] = LiteralList

       --Constructor.
     1 function LiteralList.new(ln, col, arr)
    11   return setmetatable(Terminal.new(TerminalType.LIST, {line = ln, col = col, value = arr}), LiteralList)
       end

       --@override
     1 function LiteralList:__tostring()
         local desc

    48   desc = "["
   138   for i, v in ipairs(self.data) do
    90     desc = desc .. (i == 1 and "" or ", ") .. tostring(v)
         end
    48   desc = desc .. "]"

    48   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralMap.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A map terminal node.
     1 local LiteralMap = {}
     1 LiteralMap.__index = LiteralMap
     1 setmetatable(LiteralMap, {__index = Terminal})
     1 package.loaded[...] = LiteralMap

       --Constructor.
     1 function LiteralMap.new(ln, col, map)
    11   return setmetatable(Terminal.new(TerminalType.MAP, {line = ln, col = col, value = map}), LiteralMap)
       end

       --@override
     1 function LiteralMap:__tostring()
         local desc

    48   desc = "{"
   132   for i, e in ipairs(self.data) do
    84     desc = desc .. (i == 1 and "" or ", ") .. e.name .. " = " .. tostring(e.value)
         end
    48   desc = desc .. "}"

    48   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NativeFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A native code.
     1 local NativeFn = {}
     1 NativeFn.__index = NativeFn
     1 setmetatable(NativeFn, {__index = Terminal})
     1 package.loaded[...] = NativeFn

       --Constructor.
     1 function NativeFn.new(ln, col, code)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.NATIVE, {line = ln, col = col}), NativeFn)
     2   self.code = code

         --(2) return
     2   return self
       end

       --@override
     1 function NativeFn:__tostring()
     1   return string.format('(native "%s")', self.code)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NextStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A next statement.
     1 local NextStmt = {}
     1 NextStmt.__index = NextStmt
     1 setmetatable(NextStmt, {__index = Stmt})
     1 package.loaded[...] = NextStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function NextStmt.new(ln, col)
     3   return setmetatable(Stmt.new(StmtType.NEXT, ln, col), NextStmt)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Node.lua
==============================================================================
       --A node.
     1 local Node = {}
     1 Node.__index = Node
     1 package.loaded[...] = Node

       --Constructor.
       --
       --@param t:string           Node type.
     1 function Node.new(t, tok)
  4828   return setmetatable({
  2414     type = t,
  2414     parent = nil,
  2414     token = tok
  4828   }, Node)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NonTerminal.lua
==============================================================================
       --imports
     1 local Node = require("dogma.syn._.Node")
     1 local NodeType = require("dogma.syn.NodeType")

       --A non-terminal node, that is, a branch.
     1 local NonTerminal = {}
     1 NonTerminal.__index = NonTerminal
     1 setmetatable(NonTerminal, {__index = Node})
     1 package.loaded[...] = NonTerminal

       --Constructor.
       --
       --@param sub:NonTerminalType
       --@param tok:Token
     1 function NonTerminal.new(sub, tok)
         local self

         --(1) create
  1287   self = setmetatable(Node.new(NodeType.NON_TERMINAL, tok), NonTerminal)
  1287   self.subtype = sub

         --(2) return
  1287   return self
       end

       --Add a node to the non-terminal.
       --
       --@param child:Node Node to add.
     1 function NonTerminal.insert()
     1   error("abstract node.")
       end

       --Remove and return last child for transfering to other node.
       --
       --@return Node
     1 function NonTerminal.remove()
     1   error("abstract node.")
       end

       --Is it well-formed?
       --
       --@return bool
       -- function NonTerminal:isWellFormed()
       --   error("abstract method.")
       -- end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ObjectStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")

       --A statement for defining an object.
     1 local ObjectStmt = {}
     1 ObjectStmt.__index = ObjectStmt
     1 setmetatable(ObjectStmt, {__index = Stmt})
     1 package.loaded[...] = ObjectStmt

       --Constructor.
       --
       --@param sub:StmtType   Statement type.
       --@param ln:number      Line number.
       --@param col:number     Column number.
       --@param name:string    Object name.
       --@param visib:string   export or pub if indicated?
     1 function ObjectStmt.new(sub, ln, col, name, visib)
         local self

         --(1) create
   108   self = setmetatable(Stmt.new(sub, ln, col), ObjectStmt)
   108   self.name = name
   108   self.visib = visib

         --(2) return
   108   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Op.lua
==============================================================================
       --imports
     1 local NonTerminal = require("dogma.syn._.NonTerminal")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")

       --An operator.
     1 local Op = {}
     1 Op.__index = Op
     1 setmetatable(Op, {__index = NonTerminal})
     1 package.loaded[...] = Op

       --Constructor.
       --
       --@param arity:string       Arity: u, b, t, n.
       --@param optor:string       The operator.
     1 function Op.new(arity, tok)
         local self

         --(1) create
   547   self = setmetatable(NonTerminal.new(NonTerminalType.OP, tok), Op)
   547   self.op = tok.value
   547   self.arity = arity
   547   local desc = self:getDesc()
   547   self.assoc = desc.assoc
   547   self.prec = desc.prec

         --(2) return
   547   return self
       end

       --Return the operator descriptor: assoc and prec.
     1 function Op:getDesc()
   547   local OPS = {
   547     ["u $"] = {assoc = "r", prec = 20},
   547     ["u :"] = {assoc = "r", prec = 20},

   547     ["b ."] = {assoc = "l", prec = 19},
   547     ["b :"] = {assoc = "l", prec = 19},
   547     ["b []"] = {assoc = "l", prec = 19}, --index
   547     ["t []"] = {assoc = "l", prec = 19}, --index
   547     ["n ()"] = {assoc = "l", prec = 19}, --call

   547     ["u !"] = {assoc = "r", prec = 18},
   547     ["u not"] = {assoc = "r", prec = 18},
   547     ["u ~"] = {assoc = "r", prec = 18},
   547     ["u +"] = {assoc = "r", prec = 18},
   547     ["u -"] = {assoc = "r", prec = 18},

   547     ["b **"] = {assoc = "r", prec = 17},

   547     ["b *"] = {assoc = "l", prec = 16},
   547     ["b /"] = {assoc = "l", prec = 16},
   547     ["b %"] = {assoc = "l", prec = 16},

   547     ["b +"] = {assoc = "l", prec = 15},
   547     ["b -"] = {assoc = "l", prec = 15},

   547     ["b <<"] = {assoc = "l", prec = 14},
   547     ["b >>"] = {assoc = "l", prec = 14},

   547     ["b <"] = {assoc = "l", prec = 13},
   547     ["b <="] = {assoc = "l", prec = 13},
   547     ["b >"] = {assoc = "l", prec = 13},
   547     ["b >="] = {assoc = "l", prec = 13},
   547     ["b in"] = {assoc = "l", prec = 13},
   547     ["b notin"] = {assoc = "l", prec = 13},
   547     ["b is"] = {assoc = "l", prec = 13},
   547     ["b isnot"] = {assoc = "l", prec = 13},
   547     ["b like"] = {assoc = "l", prec = 13},
   547     ["b notlike"] = {assoc = "l", prec = 13},

   547     ["b =="] = {assoc = "l", prec = 12},
   547     ["b ==="] = {assoc = "l", prec = 12},
   547     ["b !="] = {assoc = "l", prec = 12},
   547     ["b !=="] = {assoc = "l", prec = 12},

   547     ["b &"] = {assoc = "l", prec = 11},
   547     ["b ^"] = {assoc = "l", prec = 10},
   547     ["b |"] = {assoc = "l", prec = 9},

   547     ["b &&"] = {assoc = "l", prec = 8},
   547     ["b and"] = {assoc = "l", prec = 8},

   547     ["b ||"] = {assoc = "l", prec = 7},
   547     ["b or"] = {assoc = "l", prec = 7},

   547     ["b ="] = {assoc = "r", prec = 6},
   547     ["b :="] = {assoc = "r", prec = 6},
   547     ["b .="] = {assoc = "r", prec = 6},
   547     ["b +="] = {assoc = "r", prec = 6},
   547     ["b -="] = {assoc = "r", prec = 6},
   547     ["b *="] = {assoc = "r", prec = 6},
   547     ["b **="] = {assoc = "r", prec = 6},
   547     ["b /="] = {assoc = "r", prec = 6},
   547     ["b %="] = {assoc = "r", prec = 6},
   547     ["b <<="] = {assoc = "r", prec = 6},
   547     ["b >>="] = {assoc = "r", prec = 6},
   547     ["b &="] = {assoc = "r", prec = 6},
   547     ["b |="] = {assoc = "r", prec = 6},
   547     ["b ^="] = {assoc = "r", prec = 6},

   547     ["u ..."] = {assoc = "r", prec = 5}
         }

   547   return OPS[self.arity .. " " .. self.op]
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Param.lua
==============================================================================
       --A function parameter.
     1 local Param = {}
     1 Param.__index = Param
     1 package.loaded[...] = Param

       --Constructor.
       --
       --@param const:bool
       --@param mod?:string $ or : or ....
       --@param name:string
       --@param opt:bool
       --@param dtype?:Exp
       --@param val?:Exp
     1 function Param.new(const, mod, name, opt, dtype, val)
   136   return setmetatable({
    68     const = const,
    68     modifier = mod,  --$ or : or ...
    68     name = name,
    68     optional = not not opt,
    68     type = dtype,
    68     value = val
   136   }, Param)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Params.lua
==============================================================================
       --A parameters list.
     1 local Params = {}
     1 Params.__index = Params
     1 setmetatable(Params, {__index = table})
     1 package.loaded[...] = Params

       --Constructor.
     1 function Params.new()
    94   return setmetatable({}, Params)
       end

       --Check whether a parameter exists.
       --
       --@param name:string  Parameter name.
       --@return bool
     1 function Params:has(name)
         local res

         --(1) check
     6   res = false

    10   for _, param in ipairs(self) do
     6     if param.name == name then
     2       res = true
             break
           end
         end

         --(2) return
     6   return res
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PevalFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A protected call.
     1 local PevalFn = {}
     1 PevalFn.__index = PevalFn
     1 setmetatable(PevalFn, {__index = Terminal})
     1 package.loaded[...] = PevalFn

       --Constructor.
     1 function PevalFn.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.PEVAL, {line = ln, col = col}), PevalFn)
     2   self.exp = exp

         --(2) return
     2   return self
       end

       --@override
     1 function PevalFn:__tostring()
     1   return string.format("(peval %s)", tostring(self.exp))
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ReturnStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A return statement.
     1 local ReturnStmt = {}
     1 ReturnStmt.__index = ReturnStmt
     1 setmetatable(ReturnStmt, {__index = Stmt})
     1 package.loaded[...] = ReturnStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param val?:Exp   Value to return.
     1 function ReturnStmt.new(ln, col, val)
         local self

         --(1) create
    24   self = setmetatable(Stmt.new(StmtType.RETURN, ln, col), ReturnStmt)
    24   if val then
     2     self.values = {val}
         else
    22     self.values = {}
         end

         --(2) return
    24   return self
       end

       --@override
     1 function ReturnStmt:__len()
     2   return #self.values
       end

       --Add a value.
       --
       --@param val:Exp  Value to add.
     1 function ReturnStmt:insert(val)
    20   table.insert(self.values, val)
       end

     1 function ReturnStmt:__tostring()
    24   if #self.values == 0 then
     3     return "return"
         else
    21     return "return " .. tostring(self.values[1])
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Sent.lua
==============================================================================
       --A sentence.
     1 local Sent = {}
     1 Sent.__index = Sent
     1 package.loaded[...] = Sent

       --Constructor.
     1 function Sent.new(t, ln, col)
  2114   return setmetatable({
  1057     type = t,
  1057     line = ln,
  1057     col = col,
  1057     _ = {}
  2114   }, Sent)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SliceOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A slice operator: [,].
     1 local SliceOp = {}
     1 SliceOp.__index = SliceOp
     1 setmetatable(SliceOp, {__index = Op})
     1 package.loaded[...] = SliceOp

       --Constructor.
       --
       --@param tok:Token
     1 function SliceOp.new(tok)
         local self

     5   self = setmetatable(Op.new("t", tok), SliceOp)
     5   self.children = {}

     5   return self
       end

       --@override
     1 function SliceOp:insert(node)
         -- if #self.children == 3 then
         --   error("children already set.")
         -- end

    15   table.insert(self.children, node)
       end

       --@override
       -- function SliceOp.remove()
       --   error("slice operator can't remove children.")
       -- end

       --@override
     1 function SliceOp:isWellFormed()
     5   return #self.children == 3
       end

       --@override
     1 function SliceOp:__tostring()
    15   return string.format("(%s %s %s %s)", self.op, self.children[1], self.children[2], self.children[3])
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Stmt.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --A statement.
     1 local Stmt = {}
     1 Stmt.__index = Stmt
     1 setmetatable(Stmt, {__index = Sent})
     1 package.loaded[...] = Stmt

       --Constructor.
       --
       --@param sub:StmtType   Statement type.
       --@param ln:number      Line number.
       --@param col:number     Column number.
     1 function Stmt.new(sub, ln, col)
         local self

         --(1) create
   270   self = setmetatable(Sent.new(SentType.STMT, ln, col), Stmt)
   270   self.subtype = sub

         --(2) return
   270   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubExp.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A subexpression: (Exp).
     1 local SubExp = {}
     1 SubExp.__index = SubExp
     1 setmetatable(SubExp, {__index = Terminal})
     1 package.loaded[...] = SubExp

       --Constructor.
     1 function SubExp.new(ln, col, exp)
    11   return setmetatable(Terminal.new(TerminalType.SUBEXP, {line = ln, col = col, value = exp}), SubExp)
       end

       --@override
     1 function SubExp:__tostring()
     7   return tostring(self.data)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubParser.lua
==============================================================================
       --A subparser.
     1 local SubParser = {}
     1 SubParser.__index = SubParser
     1 package.loaded[...] = SubParser

       --Constructor.
       --
       --@param Parser:Parser  Parent parser.
     1 function SubParser.new(parser)
         --(1) arguments
  2212   if not parser then error("parser expected.") end

         --(2) create
  4424   return setmetatable({
  2212     _ = {
  2212       parser = parser,
  2212       lexer = parser._.lexer
  2212     }
  4424   }, SubParser)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SyntaxTree.lua
==============================================================================
       --imports
     1 local NodeType = require("dogma.syn.NodeType")
     1 local NonTerminal = require("dogma.syn._.NonTerminal")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")

       --A syntax tree, for example, an expression.
     1 local SyntaxTree = {}
     1 SyntaxTree.__index = SyntaxTree
     1 setmetatable(SyntaxTree, {__index = NonTerminal})
     1 package.loaded[...] = SyntaxTree

       --Constructor.
     1 function SyntaxTree.new()
         local self

         --(1) create
   738   self = setmetatable(NonTerminal.new(NonTerminalType.TREE), SyntaxTree)
   738   self.root = nil
   738   self._ = {
   738     current = nil
   738   }

         --(2) return
   738   return self
       end

       --@override
     1 function SyntaxTree:insert(node)
         --(1) arguments
  1670   if not node then error("node expected.") end

         --(2) add
  1670   if self.root == nil then --1st node to add
   731     self:_init(node)
         else
   939     self:_update(node)
         end
       end

     1 function SyntaxTree:_init(node)
   731   self.root = node

   731   if node.type == NodeType.NON_TERMINAL then
    27     self._.current = node
         end
       end

     1 function SyntaxTree:_update(node)
   939   if self.root.type == NodeType.TERMINAL then
   452     self:_updateTerminalRoot(node)
         else
   487     self:_updateFromCurrent(node)
         end
       end

       --Update the tree when this is well-formed with one terminal.
     1 function SyntaxTree:_updateTerminalRoot(node)
   452   if node.type == NodeType.TERMINAL then
     2     error(string.format(
     1       "(%s,%s): terminal can't follow to other terminal.",
     1       node.token.line,
     1       node.token.col
     1     ))
         end

         --node is non-terminal, for example, an operator
   451   node:insert(self.root)
   451   self.root = node
   451   self._.current = node
       end

       --Update th tree from the current node.
       --For example, when a+b for adding a call operator.
       --We use the precedence and the associativity for determining.
     1 function SyntaxTree:_updateFromCurrent(new)
   495   local cur = self._.current

   495   if self:isWellFormed() then
    70     if new.type == NodeType.TERMINAL then
     2       error(string.format(
     1         "on (%s,%s), invalid terminal node for well-formed expression.",
     1         new.token.line,
     1         new.token.col
     1       ))
           else
    69       if cur.prec > new.prec then
    27         self:_updateUpNodeFromCurrent(new)
    42       elseif cur.prec < new.prec then
    26         self:_updateDownNodeFromCurrent(new)
             else
    16         if cur.assoc == "l" then
    15           self:_updateUpNodeFromCurrent(new)
               else
     1           self:_updateDownNodeFromCurrent(new)
               end
             end
           end
         else  --non well-formed
   425     cur:insert(new)

   423     if new.type == NodeType.NON_TERMINAL then
     6       self._.current = new
           end
         end
       end

     1 function SyntaxTree:_updateUpNodeFromCurrent(node)
    42   if self.root == self._.current then
    34     node:insert(self.root)
    34     self.root = node
    34     self._.current = node
         else
     8     self._.current = self._.current.parent
     8     self:_updateFromCurrent(node)
         end
       end

     1 function SyntaxTree:_updateDownNodeFromCurrent(node)
    27   node:insert(self._.current:remove())
    27   self._.current:insert(node)
    27   self._.current = node
       end

       --@override
     1 function SyntaxTree:__tostring()
   658   return self.root:__tostring()
       end

       --@override
     1 function SyntaxTree:isWellFormed()
  1609   if not self.root then
    21     return false
  1588   elseif self.root.type == NodeType.TERMINAL then
   569     return true
         else
  1019     return self._.current:isWellFormed()
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Terminal.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local Node = require("dogma.syn._.Node")
     1 local NodeType = require("dogma.syn.NodeType")

       --A terminal node.
     1 local Terminal = {}
     1 Terminal.__index = Terminal
     1 setmetatable(Terminal, {__index = Node})
     1 package.loaded[...] = Terminal

       --Constructor.
       --
       --@param sub:TerminalTtype
       --@param tok:Token
     1 function Terminal.new(sub, tok)
         local self

         --(1) create
  1127   self = setmetatable(Node.new(NodeType.TERMINAL, tok), Terminal)
  1127   self.subtype = sub
  1127   self.data = tok.value

         --(2) return
  1127   return self
       end

       --@override
     1 function Terminal:__tostring()
   922   return string.format("%s", self.data)
       end

       --Is it an identifier?
       --
       --@return bool
     1 function Terminal:isId()
    16   return self.token.type == TokenType.NAME
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ThrowFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A throw function.
     1 local ThrowFn = {}
     1 ThrowFn.__index = ThrowFn
     1 setmetatable(ThrowFn, {__index = Terminal})
     1 package.loaded[...] = ThrowFn

       --Constructor.
     1 function ThrowFn.new(ln, col, args)
         local self

         --(1) create
     6   self = setmetatable(Terminal.new(TerminalType.THROW, {line = ln, col = col}), ThrowFn)
     6   self.args = args

         --(2) return
     6   return self
       end

       --@override
     1 function ThrowFn:__tostring()
         local repr

         --(1) build
     3   repr = "(throw "

     9   for i, arg in ipairs(self.args) do
     6     repr = repr .. (i == 1 and "" or " ") .. tostring(arg)
         end

     3   repr = repr .. ")"

         --(2) return
     3   return repr
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/TypeStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A type statement.
     1 local TypeStmt = {}
     1 TypeStmt.__index = TypeStmt
     1 setmetatable(TypeStmt, {__index = ObjectStmt})
     1 package.loaded[...] = TypeStmt

       --Constructor.
     1 function TypeStmt.new(ln, col, annots, visib, name, params, btype, bargs, body, catch, fin)
         local self

         --(1) create
    14   self = setmetatable(ObjectStmt.new(StmtType.TYPE, ln, col, name, visib), TypeStmt)
    14   self.params = params
    14   self.base = btype
    14   self.bargs = bargs
    14   self.body = body
    14   self.catch = catch
    14   self.finally = fin
    14   self.annots = annots or {}

         --(2) return
    14   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UnaryOp.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local Op = require("dogma.syn._.Op")
     1 local NodeType = require("dogma.syn.NodeType")

       --Unary operator.
     1 local UnaryOp = {}
     1 UnaryOp.__index = UnaryOp
     1 setmetatable(UnaryOp, {__index = Op})
     1 package.loaded[...] = UnaryOp

       --Constructor.
       --
       --@param tok:Token
     1 function UnaryOp.new(tok)
         local self

         --(1) create
    33   self = setmetatable(Op.new("u", tok), UnaryOp)
    33   self.child = nil

         --(2) return
    33   return self
       end

       --@override
     1 function UnaryOp:insert(node)
         --(1) pre
    35   if tablex.find({"$", ":"}, self.op) then
    16     if not (node.type == NodeType.TERMINAL and node:isId()) then
     4       error(string.format(
     2         "on (%s, %s), '$' or ':' must be followed by identifier.",
     2         node.token.line,
     2         node.token.col
     2       ))
           end
         end

         --(2) add
    33   self.child = node
    33   node.parent = self
       end

       --@override
     1 function UnaryOp:remove()
     2   local c = self.child
     2   self.child = nil
     2   return c
       end

       --@override
     1 function UnaryOp:isWellFormed()
    68   return not not self.child
       end

       --@override
     1 function UnaryOp:__tostring()
    18   return string.format("(%s %s)", self.op, self.child)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Unpack.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --An unpack sentence.
     1 local Unpack = {}
     1 Unpack.__index = Unpack
     1 setmetatable(Unpack, {__index = Sent})
     1 package.loaded[...] = Unpack

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param visib:string   Visibility: nil, export or pub.
       --@param def:string     Type definition: nil, var or const.
       --@param sub:string     Unpack type: [] or {}.
       --@param vars:array
       --@param assign:string  = or :=.
       --@param exp:Exp
     1 function Unpack.new(ln, col, visib, def, sub, vars, assign, exp)
         local self

         --(1) create
    38   self = setmetatable(Sent.new(SentType.UNPACK, ln, col), Unpack)
    38   self.visib = visib
    38   self.def = def
    38   self.subtype = sub
    38   self.vars = vars
    38   self.assign = assign
    38   self.exp = exp

         --(2) return
    38   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --use statement.
     1 local UseStmt = {}
     1 UseStmt.__index = UseStmt
     1 setmetatable(UseStmt, {__index = Stmt})
     1 package.loaded[...] = UseStmt

       --Constructor.
     1 function UseStmt.new(ln, col)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.USE, ln, col), UseStmt)
    18   self.modules = {}

         --(2) return
    18   return self
       end

       --Add a module.
       --
       --@param type:bool    Is a type?
       --@param mod:string   Module to use.
       --@param name?:string Variable module name.
     1 function UseStmt:insert(type, mod, name)
    25   local NAME_PATTERN = "^[%a_][%w_]*$"
    25   local Q_PATTERN = "^.*/([%a_][%w_]*)$"

         --(1) set name if needed
    25   if not name then
    16     if mod:find(NAME_PATTERN) then
    10       name = mod
     6     elseif mod:find(Q_PATTERN) then
     5       name = mod:match(Q_PATTERN)
           else
     1       error(string.format("invalid module path format: '%s'.", mod))
           end
         end

         --(2) add module
    24   table.insert(self.modules, {type = type, name = name, path = mod})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A var statement.
     1 local VarStmt = {}
     1 VarStmt.__index = VarStmt
     1 setmetatable(VarStmt, {__index = Stmt})
     1 package.loaded[...] = VarStmt

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param visib:string Visibility: export or pub.
     1 function VarStmt.new(ln, col, visib)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.VAR, ln, col), VarStmt)
    18   self.vars = {}
    18   self.visib = visib

         --(2) return
    18   return self
       end

       --Add a variable declaration.
       --
       --@param name:string  Variable name.
       --@param val?:Exp     Default value.
     1 function VarStmt:insert(name, val)
    22   table.insert(self.vars, {name = name, value = val})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WhileStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A while statement.
     1 local WhileStmt = {}
     1 WhileStmt.__index = WhileStmt
     1 setmetatable(WhileStmt, {__index = Stmt})
     1 package.loaded[...] = WhileStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param cond:Exp
       --@param iter?:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function WhileStmt.new(ln, col, cond, iter, body, catch, fin)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.WHILE, ln, col), WhileStmt)
    18   self.cond = cond
    18   self.iter = iter
    18   self.body = body
    18   self.catch = catch
    18   self.finally = fin

         --(2) return
    18   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/Trans.lua
==============================================================================
       --A transformer.
     1 local Trans = {}
     1 Trans.__index = Trans
     1 package.loaded[...] = Trans

       --Constructor.
     1 function Trans.new()
   458   return setmetatable({
   229     _ = {

   229     }
   458   }, Trans)
       end

       --Confirgue the transformer.
       --
       --@param parser:Parser  Parser to use.
     1 function Trans:transform(parser)
   228   self._.parser = parser
       end

       --Transform the next sentence or file from the parser configured previously.
       --
       --@abstract
       --@return string
     1 function Trans:next()
     1   error("abstract method.")
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/Trans.lua
==============================================================================
       --imports
     1 local Trans = require("dogma.trans.Trans")
     1 local DirectiveTrans = require("dogma.trans.js._.DirectiveTrans")
     1 local ExpTrans = require("dogma.trans.js._.ExpTrans")
     1 local StmtTrans = require("dogma.trans.js._.StmtTrans")
     1 local UnpackTrans = require("dogma.trans.js._.UnpackTrans")
     1 local SentType = require("dogma.syn.SentType")

       --A JavaScript transformer.
     1 local JsTrans = {}
     1 JsTrans.__index = JsTrans
     1 setmetatable(JsTrans, {__index = Trans})
     1 package.loaded[...] = JsTrans

       --Constructor.
     1 function JsTrans.new(opts)
         local self

         --(1) create
   228   self = setmetatable(Trans.new(opts), JsTrans)
   228   self._.directiveTrans = DirectiveTrans.new(self)
   228   self._.expTrans = ExpTrans.new(self)
   228   self._.stmtTrans = StmtTrans.new(self)
   228   self._.unpackTrans = UnpackTrans.new(self)

         --(2) return
   228   return self
       end

       --@override
     1 function JsTrans:next()
   227   local parser = self._.parser
         local out

         --(1) transform
   227   out = ""

         while true do
           local sent

   453     sent = parser:next()

   452     if sent == nil then
             break
           end

   226     out = out .. self:_trans(sent, ";") .. "\n"
         end

         --(2) return
   226   return out
       end

     1 function JsTrans:_trans(sent, eoe)
   401   if sent.type == SentType.DIRECTIVE then
     8     return self._.directiveTrans:transform(sent)
   393   elseif sent.type == SentType.EXP then
   257     return self._.expTrans:transform(sent) .. (eoe or "")
   136   elseif sent.type == SentType.STMT then
   113     return self._.stmtTrans:transform(sent)
    23   elseif sent.type == SentType.UNPACK then
    23     return self._.unpackTrans:transform(sent)
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/DirectiveTrans.lua
==============================================================================
       --imports
     1 local DirectiveType = require("dogma.syn.DirectiveType")
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --A directive transformer.
     1 local DirectiveTrans = {}
     1 DirectiveTrans.__index = DirectiveTrans
     1 setmetatable(DirectiveTrans, {__index = SubTrans})
     1 package.loaded[...] = DirectiveTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function DirectiveTrans.new(trans)
   228   return setmetatable(SubTrans.new(trans), DirectiveTrans)
       end

       --Transform a directive.
       --
       --@param dir:Directive  Directive to transform.
       --@return string
     1 function DirectiveTrans:transform(dir)
     8   if dir.subtype == DirectiveType.IF then
     8     return self:_transIf(dir)
         end
       end

       --Transform an if directive.
       --
       --@return string
     1 function DirectiveTrans:_transIf(dir)
         local function transform(sents)
     6     local trans = self._.trans
           local code

     6     code = ""
    12     for _, sent in ipairs(sents) do
     6       code = code .. trans:_trans(sent)
           end

     6     return code
         end

         --(1) transform if
         local code

     8   if dir.cond == "js" or (dir.cond:find("^not") and dir.cond ~= "not js") then
     4     code = transform(dir.body)
     4   elseif dir.el then
     2     code = transform(dir.el)
         else
     2     code = ""
         end

         --(2) return
     8   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/ExpTrans.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local NodeType = require("dogma.syn.NodeType")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")
     1 local transName = require("dogma.trans.js._.util").transName
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --An expression transformer to JavaScript.
     1 local ExpTrans = {}
     1 ExpTrans.__index = ExpTrans
     1 setmetatable(ExpTrans, {__index = SubTrans})
     1 package.loaded[...] = ExpTrans

       --Constructor.
     1 function ExpTrans.new(trans)
   228   return setmetatable(SubTrans.new(trans), ExpTrans)
       end

       --Transform an expression.
       --
       --@param exp:Exp      Expression to transform.
       --@return string
     1 function ExpTrans:transform(exp)
   275   return self:_transNode(exp.tree.root)
       end

       --Transform a node.
       --
       --@param node:Node
       --@return string
     1 function ExpTrans:_transNode(node)
   717   if node.type == NodeType.TERMINAL then
   488     return self:_transTerminal(node)
   229   elseif node.type == NodeType.NON_TERMINAL then
   229     return self:_transNonTerminal(node)
         end
       end

       --Transform a terminal node.
       --
       --@param node:Terminal
       --@return string
     1 function ExpTrans:_transTerminal(node)
   488   if node.subtype == TerminalType.NAME then
   255     return transName(node.data)
   233   elseif node.subtype == TerminalType.NUM then
   178     return tostring(node.data)
    55   elseif node.subtype == TerminalType.TEXT then
    14     return string.format([["%s"]], node.data)
    41   elseif node.subtype == TerminalType.TRUE then
    14     return "true"
    27   elseif node.subtype == TerminalType.FALSE then
     2     return "false"
    25   elseif node.subtype == TerminalType.NIL then
     1     return "null"
    24   elseif node.subtype == TerminalType.LIST then
     3     return self:_transLiteralList(node)
    21   elseif node.subtype == TerminalType.MAP then
     3     return self:_transLiteralMap(node)
    18   elseif node.subtype == TerminalType.SELF then
     1     return "this"
    17   elseif node.subtype == TerminalType.SUPER then
     1     return "super"
    16   elseif node.subtype == TerminalType.NOP then
     1     return "dogma.nop()"
    15   elseif node.subtype == TerminalType.FN then
     7     return self:_transLiteralFn(node)
     8   elseif node.subtype == TerminalType.SUBEXP then
     2     return self:transform(node.data)
     6   elseif node.subtype == TerminalType.NATIVE then
     1     return self:_transNativeFn(node)
     5   elseif node.subtype == TerminalType.PEVAL then
     1     return self:_transPevalFn(node)
     4   elseif node.subtype == TerminalType.THROW then
     3     return self:_transThrowFn(node)
     1   elseif node.subtype == TerminalType.IF then
     1     return self:_transIfSubExp(node)
         end
       end

       --Transform if Exp then Exp else Exp end
     1 function ExpTrans:_transIfSubExp(node)
     2   return string.format(
     1     "(%s ? %s : %s)",
     1     self:transform(node.cond),
     1     self:transform(node.trueCase),
     1     self:transform(node.falseCase)
     1   )
       end

       --Transform a native() function.
     1 function ExpTrans:_transNativeFn(fn)
     1   return string.format(fn.code)
       end

       --Transform a peval() function.
     1 function ExpTrans:_transPevalFn(fn)
     1   return string.format("dogma.peval(() => {return %s;})", self:transform(fn.exp))
       end

       --Transform a throw() function.
     1 function ExpTrans:_transThrowFn(fn)
         local code

         --(1) transform
     3   code = "dogma.raise("

     3   if #fn.args == 1 then
     1     code = code .. self:transform(fn.args[1])
         else
     7     for i, arg in ipairs(fn.args) do
     5       code = code .. (i == 1 and "" or ", ") .. self:transform(arg)
           end
         end

     3   code = code .. ")"

         --(2) return
     3   return code
       end

       --Transform a literal list.
     1 function ExpTrans:_transLiteralList(term)
         local code

         --(1) transform
     3   code = "["

     6   for ix, item in ipairs(term.data) do
     3     code = code .. (ix == 1 and "" or ", ") .. self:transform(item)
         end

     3   code = code .. "]"

         --(2) return
     3   return code
       end

       --Transform a literal map.
     1 function ExpTrans:_transLiteralMap(term)
         local code

         --(1) transform
     3   code = "{"

     6   for i, entry in ipairs(term.data) do
     6     code = code .. (i == 1 and "" or ", ") .. string.format(
     3       '["%s"]: %s',
     3       entry.name,
     3       self:transform(entry.value)
           )
         end

     3   code = code .. "}"

         --(2) return
     3   return code
       end

       --Transform a literal function.
     1 function ExpTrans:_transLiteralFn(term)
     7   local strans = self._.trans._.stmtTrans

    14   return string.format(
     7     "(%s) => { %s%s%s%s }",
     7     strans:_transParams(term.data.params),
     7     strans:_transReturnVar(term.data),
     7     strans:_transParamsCheck(term.data.params),
     7     strans:_transBody(term.data.body),
     7     term.data.rvar and string.format(" return %s;", term.data.rvar == "self" and "this" or term.data.rvar) or ""
    13   )
       end

       --Transform a non-terminal node.
       --
       --@param node:NonTerminal
       --@return string
     1 function ExpTrans:_transNonTerminal(node)
   229   if node.subtype == NonTerminalType.OP then
   229     return self:_transOp(node)
         -- elseif node.subtype == NonTerminalType.TREE then
         --   return self:_transTree(node)
         end
       end

       --Transform an operator node.
       --
       --@param node:Op
       --@return string
     1 function ExpTrans:_transOp(node)
   229   if node.arity == "u" then
    10     return self:_transUnaryOp(node)
   219   elseif node.arity == "b" then
   202     return self:_transBinOp(node)
    17   elseif node.arity == "t" then
     2     return self:_transTernaryOp(node)
    15   elseif node.arity == "n" then
    15     return self:_transNaryOp(node)
         end
       end

     1 function ExpTrans:_transUnaryOp(node)
    10   if node.op == "$" then
     3     return "this." .. node.child.data
     7   elseif node.op == ":" then
     1     return "this._" .. node.child.data
     6   elseif node.op == "not" or node.op == "!" then
     2     return string.format("!(%s)", self:_transNode(node.child))
     4   elseif node.op == "~" then
     1     return string.format("~(%s)", self:_transNode(node.child))
     3   elseif node.op == "+" then
     1     return string.format("+(%s)", self:_transNode(node.child))
     2   elseif node.op == "-" then
     1     return string.format("-(%s)", self:_transNode(node.child))
     1   elseif node.op == "..." then
     1     return string.format("...(%s)", self:_transNode(node.child))
         end
       end

     1 function ExpTrans:_transBinOp(node)
   202   local left, right = node.children[1], node.children[2]

   202   if tablex.find({"+", "-", "*", "**", "/", "%", "==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", "||", "&&"}, node.op) then
   145     return "(" .. self:_transNode(left) .. node.op .. self:_transNode(right) .. ")"
    57   elseif tablex.find({"=", "+=", "-=", "*=", "**=", "/=", "%=", "<<=", ">>=", "|=", "&=", "^="}, node.op) then
    27     return self:_transAssign(node)
    30   elseif node.op == ".=" then
     1     return self:_transAssignWithPubProp(node)
    29   elseif node.op == ":=" then
     5     return self:_transConstAssign(node)
    24   elseif node.op == "and" then
     1     return "(" .. self:_transNode(left) .. "&&" .. self:_transNode(right) .. ")"
    23   elseif node.op == "or" then
     1     return "(" .. self:_transNode(left) .. "||" .. self:_transNode(right) .. ")"
    22   elseif node.op == "." then
     9     return self:_transNode(left) .. "." .. self:_transNode(right)
    13   elseif node.op == ":" then
     4     return self:_transNode(left) .. "._" .. right.data
     9   elseif node.op == "is" then
     1     return string.format("dogma.is(%s, %s)", self:_transNode(left), self:_transNode(right))
     8   elseif node.op == "isnot" then
     1     return string.format("dogma.isNot(%s, %s)", self:_transNode(left), self:_transNode(right))
     7   elseif node.op == "in" then
     1     return string.format("(%s).includes(%s)", self:_transNode(right), self:_transNode(left))
     6   elseif node.op == "notin" then
     1     return string.format("!(%s).includes(%s)", self:_transNode(right), self:_transNode(left))
     5   elseif node.op == "like" then
     1     return string.format("dogma.like(%s, %s)", self:_transNode(left), self:_transNode(right))
     4   elseif node.op == "notlike" then
     1     return string.format("dogma.notLike(%s, %s)", self:_transNode(left), self:_transNode(right))
     3   elseif node.op == "[]" then
     3     return string.format("dogma.getItem(%s, %s)", self:_transNode(left), self:_transNode(right))
         end
       end

     1 function ExpTrans:_transAssign(op)
    27   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
    27   if left.op == "[]" then
     2     code = string.format(
     1       [[dogma.setItem("%s", %s, %s, %s)]],
     1       op.op,
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         else
    26     code = string.format("(%s%s%s)", self:_transNode(left), op.op, self:_transNode(right))
         end

         --(2) return
    27   return code
       end

     1 function ExpTrans:_transConstAssign(op)
     5   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     5   if left.op == "$" then
     2     code = string.format(
     1       [[Object.defineProperty(this, "%s", {value: %s, enum: true})]],
     1       self:_transNode(left.child),
     1       self:_transNode(right)
     1     )
     4   elseif left.op == "." then
     2     code = string.format(
     1       [[Object.defineProperty(%s, "%s", {value: %s, enum: true})]],
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
     3   elseif left.op == ":" then
     2     if left.arity == "u" then
     2       code = string.format(
     1         [[Object.defineProperty(this, "_%s", {value: %s})]],
     1         left.child.data,
     1         self:_transNode(right)
     1       )
           else
     2       code = string.format(
     1         [[Object.defineProperty(%s, "_%s", {value: %s})]],
     1         self:_transNode(left.children[1]),
     1         left.children[2].data,
     1         self:_transNode(right)
     1       )
           end
     1   elseif left.op == "[]" then
     2     code = string.format(
     1       [[dogma.setItem("=", %s, %s, %s)]],
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         end

         --(2) return
     5   return code
       end

     1 function ExpTrans:_transAssignWithPubProp(op)
     1   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     1   if left.arity == "u" then
     2     code = string.format(
     1       'Object.defineProperty(this, "_%s", {value: %s});',
     1       left.child.data,
     1       self:_transNode(right)
     1     )

     2     code = code .. string.format(
     1       'Object.defineProperty(this, "%s", {enum: true, get() { return this._%s; }})',
     1       left.child.data,
     1       left.child.data
     1     )
         end

         --(2) return
     1   return code
       end

     1 function ExpTrans:_transTernaryOp(op)
     2   if op.op == "[]" then
     4     return string.format(
     2       "dogma.getSlice(%s, %s, %s)",
     2       self:_transNode(op.children[1]),
     2       self:_transNode(op.children[2]),
     2       self:_transNode(op.children[3])
     2     )
         end
       end

     1 function ExpTrans:_transNaryOp(node)
    15   if node.op == "()" then
           local code

    15     code = self:_transNode(node.children[1]) .. "("
    44     for i, arg in ipairs(node.children) do
    29       if i > 1 then
    14         code = code .. (i == 2 and "" or ", ") .. self:_transNode(arg.tree.root)
             end
           end
    15     code = code .. ")"

    15     return code
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/StmtTrans.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local StmtType = require("dogma.syn.StmtType")
     1 local transName = require("dogma.trans.js._.util").transName
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --A statement transformer.
     1 local StmtTrans = {}
     1 StmtTrans.__index = StmtTrans
     1 setmetatable(StmtTrans, {__index = SubTrans})
     1 package.loaded[...] = StmtTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function StmtTrans.new(trans)
   228   return setmetatable(SubTrans.new(trans), StmtTrans)
       end

       --Transform a statement.
       --
       --@param stmt:Stmt  Statement to transform.
       --@return string
     1 function StmtTrans:transform(stmt)
   113   if stmt.subtype == StmtType.ASYNC then
     3     return self:_transAsync(stmt)
   110   elseif stmt.subtype == StmtType.BREAK then
     1     return self:_transBreak(stmt)
   109   elseif stmt.subtype == StmtType.CONST then
     5     return self:_transConst(stmt)
   104   elseif stmt.subtype == StmtType.DO then
     5     return self:_transDo(stmt)
    99   elseif stmt.subtype == StmtType.ENUM then
     4     return self:_transEnum(stmt)
    95   elseif stmt.subtype == StmtType.FN then
    34     return self:_transFn(stmt)
    61   elseif stmt.subtype == StmtType.FOR then
     7     return self:_transFor(stmt)
    54   elseif stmt.subtype == StmtType.FOR_EACH then
     5     return self:_transForEach(stmt)
    49   elseif stmt.subtype == StmtType.FROM then
     4     return self:_transFrom(stmt)
    45   elseif stmt.subtype == StmtType.IF then
     6     return self:_transIf(stmt)
    39   elseif stmt.subtype == StmtType.NEXT then
     1     return self:_transNext(stmt)
    38   elseif stmt.subtype == StmtType.RETURN then
    14     return self:_transReturn(stmt)
    24   elseif stmt.subtype == StmtType.TYPE then
     7     return self:_transType(stmt)
    17   elseif stmt.subtype == StmtType.USE then
     4     return self:_transUse(stmt)
    13   elseif stmt.subtype == StmtType.VAR then
     7     return self:_transVar(stmt)
     6   elseif stmt.subtype == StmtType.WHILE then
     6     return self:_transWhile(stmt)
         -- elseif stmt.subtype == StmtType.YIELD then
         --   return self:_transYield(stmt)
         end
       end

       --Transform a use statement.
       --
       --@return string
     1 function StmtTrans:_transUse(stmt)
         local code

         --(1) transform
     4   code = ""

    10   for _, mod in ipairs(stmt.modules) do
     6     code = code .. string.format([[import %s from "%s";]], mod.name, mod.path)
         end

         --(2) return
     4   return code
       end

       --Transform a from statement.
       --
       --@return string
     1 function StmtTrans:_transFrom(stmt)
         local code

         --(1) transform
     4   code = "import {"

    10   for i, mem in ipairs(stmt.members) do
     6     code = code .. (i == 1 and "" or ", ")

     6     if mem.name == mem.as then
     3       code = code .. mem.name
           else
     3       code = code .. string.format("%s as %s", mem.name, mem.as)
           end
         end

     4   code = code .. [[} from "]] .. stmt.module .. [[";]]

         --(2) return
     4   return code
       end

       --Transform a break statement.
       --
       --@return string
     1 function StmtTrans:_transBreak(stmt)
     1   return "break;"
       end

       --Transform a next statement.
       --
       --@return string
     1 function StmtTrans:_transNext(stmt)
     1   return "continue;"
       end

       --Transform an enum statement.
       --
       --@return string
     1 function StmtTrans:_transEnum(enum)
         local code

         --(1) transform
     8   code = string.format([[
       %sclass %s {
         constructor(name, val) {
           Object.defineProperty(this, "name", {value: name, enum: true});
           Object.defineProperty(this, "value", {value: val, enum: true});
         }
       }
     4 ]],
     4     self:_transVisib(enum.visib),
           enum.name
     8   )

    12   for _, item in ipairs(enum.items) do
    16     code = code .. string.format(
     8       [[Object.defineProperty(%s, "%s", {value: new %s("%s", %s), enum: true});]] .. "\n",
     8       enum.name,
     8       item.name,
     8       enum.name,
     8       item.name,
     8       (type(item.value) == "string" and string.format([["%s"]], item.value) or item.value)
           )
         end

         --(2) return
     4   return code
       end

     1 function StmtTrans:_transVisib(visib)
    29   if visib == "export" then
     4     return "export default "
    25   elseif visib == "pub" then
     4     return "export "
         else
    21     return ""
         end
       end

       --Transform an async statement.
       --
       --@param node
       --@return string
     1 function StmtTrans:_transAsync(node)
         local code

         --(1) get sentences to run
     3   if node.catch then
     2     code = "try "
         else
     1     code = ""
         end

     3   code = code .. self:_transBody(node.body)
     3   code = code .. self:_transCatch(node.catch)

         --(2) return
     3   return string.format("setImmediate(() => %s);", code)
       end

       --Transform a var statement.
       --
       --@return string
     1 function StmtTrans:_transVar(stmt)
         local code

         --(1) transform
     7   if #stmt.vars > 0 then
     6     if stmt.visib then
     2       code = "var "
           else
     4       code = "let "
           end

    14     for i, var in ipairs(stmt.vars) do
     8       code = code .. (i == 1 and "" or ", ") .. var.name

     8       if var.value then
     5         code = code .. " = " .. self._.trans:_trans(var.value)
             end
           end

     6     code = code .. ";"

     6     if stmt.visib then
     4       for _, var in ipairs(stmt.vars) do
     2         code = code .. self:_transVisib(stmt.visib) .. var.name .. ";"
             end
           end
         else
     1     code = ""
         end

         --(2) return
     7   return code
       end

       --Transform a const statement.
       --
       --@return string
     1 function StmtTrans:_transConst(stmt)
         local code

         --(1) transform
     5   if #stmt.vars > 0 then
     4     code = "const "

     9     for i, var in ipairs(stmt.vars) do
     5       code = code .. (i == 1 and "" or ", ") ..
     5              var.name .. " = " .. self._.trans:_trans(var.value)
           end

     4     code = code .. ";"

     4     if stmt.visib then
     4       for _, var in ipairs(stmt.vars) do
     2         code = code .. self:_transVisib(stmt.visib) .. var.name .. ";"
             end
           end
         else
     1     code = ""
         end

         --(2) return
     5   return code
       end

       --Transform an while statement.
       --
       --@return string
     1 function StmtTrans:_transWhile(node)
     6   local trans = self._.trans
         local code

         --(1) transform
     6   if node.iter then
     2     code = string.format(
     1       "for (; %s; %s) ",
     1       trans:_trans(node.cond),
     1       trans:_trans(node.iter)
     1     )
         else
     5     code = string.format("while (%s) ", trans:_trans(node.cond))
         end

     6   if node.catch or node.finally then
     3     code = code .. "try "
         end

     6   code = code .. self:_transBody(node.body)
     6   code = code .. self:_transCatch(node.catch)
     6   code = code .. self:_transFinally(node.finally)

         --(2) return
     6   return code
       end

       --Transform a statement body.
       --
       --2return string
     1 function StmtTrans:_transBody(body)
    84   local trans = self._.trans
         local code

         --(1) transform
    84   code = "{"

   143   for _, sent in ipairs(body) do
    59     code = code .. trans:_trans(sent, ";")
         end

    84   code = code .. "}"

         --(2) return
    84   return code
       end

       --Transform a catch clause.
       --
       --@return string
     1 function StmtTrans:_transCatch(catch)
    65   local trans = self._.trans
         local code

         --(1) transform
    65   if catch then
    10     code = string.format(" catch(%s) {", catch.var or "_")

    20     for _, sent in ipairs(catch.body) do
    10       code = code .. trans:_trans(sent, ";")
           end

    10     code = code .. "}"
         end

         --(2) return
    65   return code or ""
       end

       --Transform a finally clause.
       --
       --@return string
     1 function StmtTrans:_transFinally(fin)
    62   local trans = self._.trans
         local code

         --(1) transform
    62   if fin then
     7     code = " finally {"

    14     for _, sent in ipairs(fin.body) do
     7       code = code .. trans:_trans(sent, ";")
           end

     7     code = code .. "}"
         end

         --(2) return
    62   return code or ""
       end

       --Transform a do statement.
       --
       --@return string
     1 function StmtTrans:_transDo(node)
     5   local trans = self._.trans
         local code

         --(1) transform
     5   if node.catch or node.finally then
     4     if node.cond then
     1       code = "do try "
           else
     3       code = "try "
           end
         else
     1     code = "do "
         end

     5   code = code .. self:_transBody(node.body)
     5   code = code .. self:_transCatch(node.catch)
     5   code = code .. self:_transFinally(node.finally)

     5   if node.cond then
     2     code = code .. string.format(" while (%s);", trans:_trans(node.cond))
         end

         --(2) return
     5   return code
       end

       --Transfor a for statement.
       --
       --@return string
     1 function StmtTrans:_transFor(stmt)
     7   local trans = self._.trans
         local code

         --(1) transform
     7   code = "for (let "

    17   for i, var in ipairs(stmt.def) do
    10     code = code .. (i == 1 and "" or ", ") .. var.name

    10     if var.value then
     6       code = code .. " = " .. trans:_trans(var.value)
           end
         end

     7   code = code .. "; " .. trans:_trans(stmt.cond) .. "; "

     7   if stmt.iter then
     3     code = code .. trans:_trans(stmt.iter)
         end

     7   code = code .. ") "

     7   if stmt.catch or stmt.finally then
     1     code = code .. "try "
         end

     7   code = code .. self:_transBody(stmt.body)
     7   code = code .. self:_transCatch(stmt.catch)
     7   code = code .. self:_transFinally(stmt.finally)

         --(2) return
     7   return code
       end

       --Transform a for each statement.
       --
       --@return string
     1 function StmtTrans:_transForEach(node)
     5   local trans = self._.trans
         local code

         --(1) transform
     5   if node.key then
     1     local iter = self:_getRandomName()

     2     code = string.format(
     1       "const %s = %s; for (let %s in %s) { let %s = %s[%s]; ",
     1       iter,
     1       trans:_trans(node.iter),
     1       node.key,
     1       iter,
     1       node.value,
     1       iter,
             node.key
     2     )
         else
     8     code = string.format(
     4       "for (let %s of %s) ",
     4       node.value,
     4       trans:_trans(node.iter)
     4     )
         end

     5   if node.catch or node.finally then
     3     code = code .. "try "
         end

     5   code = code .. self:_transBody(node.body)
     5   code = code .. self:_transCatch(node.catch)
     5   code = code .. self:_transFinally(node.finally)

     5   if node.key then
     1     code = code .. " }"
         end

         --(2) return
     5   return code
       end

       --Transform a return statement.
       --
       --@return string
     1 function StmtTrans:_transReturn(node)
    14   local trans = self._.trans
         local code

         --(1) transform
    14   code = "return"

    14   if #node.values == 1 then
    13     code = code .. " " .. trans:_trans(node.values[1])
         end

    14   code = code .. ";"

         --(2) return
    14   return code
       end

       --Transform a type statement.
       --
       --@return string
     1 function StmtTrans:_transType(stmt)
         local code

         --(1) transform
         --$class
     7   code = string.format("const $%s = class %s", stmt.name, stmt.name)
     7   if stmt.base then
     3     code = code .. " extends " .. stmt.base
         end

     7   code = code .. " {\n"

     7   code = code .. string.format("  constructor(%s) { ", self:_transParams(stmt.params))
     7   code = code .. self:_transParamsCheck(stmt.params)
     7   code = code .. self:_transSuperConstructor(stmt.bargs)
     7   code = code .. self:_transSelfParams(stmt.params)
     7   if stmt.catch or stmt.finally then code = code .. " try " end
     7   code = code .. self:_transBody(stmt.body)
     7   code = code .. self:_transCatch(stmt.catch)
     7   code = code .. self:_transFinally(stmt.finally)
     7   code = code .. "  }\n"
     7   code = code .. "};\n"

         --class proxy
    14   code = code .. string.format(
     7     "const %s = new Proxy($%s, { apply(receiver, self, args) { return new $%s(...args); } });",
     7     stmt.name,
     7     stmt.name,
           stmt.name
     7   )

     7   if stmt.visib == "export" then
     1     code = code .. string.format("export default %s;", stmt.name)
         end

         --(2) return
     7   return code
       end

       --Transform function parameters.
       --
       --@return string
     1 function StmtTrans:_transParams(params)
    43   local trans = self._.trans
         local code

         --(1) transform
    43   if #params > 0 then
    28     code = ""

    66     for i, p in ipairs(params) do
    38       if i > 1 then
    10         code = code .. ", "
             end

    38       if p.modifier == "..." then
     1         code = code .. "..."
             end

    38       code = code .. transName(p.name)

    38       if p.value then
     2         code = code .. " = " .. trans:_trans(p.value)
             end
           end
         end

         --(2) return
    43   return code or ""
       end

       --Return the code for checking the function parameters.
       --
       --@return string
     1 function StmtTrans:_transParamsCheck(params)
         local function toJs(obj)
           local repr

     3     repr = "{"
     7     for ix, val in ipairs(obj) do
     4       repr = repr .. (ix == 1 and "" or ", ") .. val.name .. ": " .. val.type
           end
     3     repr = repr .. "}"

     3     return repr
         end

         local code

         --(1) transform
    43   if #params > 0 then
    28     code = ""

    66     for _, p in ipairs(params) do
    38       if not p.optional and p.modifier ~= "..." then  --mandatory parameter with(out) type check
    25         if type(p.type) == "table" then
     4           code = code .. string.format(
     2             [[dogma.paramExpectedToHave("%s", %s, %s);]],
     2             transName(p.name),
     2             transName(p.name),
     2             toJs(p.type)
     2           )
               else
    46           code = code .. string.format(
    23             [[dogma.paramExpected("%s", %s, %s);]],
    23             transName(p.name),
    23             transName(p.name),
    23             p.type or "null"
    21           )
               end
    13       elseif p.type then  --optional parameter with type check
     3         if type(p.type) == "table" then
     2           code = code .. string.format(
     1             [[dogma.paramExpectedToHave("%s", %s, %s);]],
     1             transName(p.name),
     1             transName(p.name),
     1             toJs(p.type)
     1           )
               else
     4           code = code .. string.format(
     2             [[dogma.paramExpectedToBe("%s", %s, %s);]],
     2             transName(p.name),
     2             transName(p.name),
                   p.type
     2           )
               end
             end
           end
         end

         --(2) return
    43   return code or ""
       end

       --Return the code for setting $ or : attributes from parameters.
       --
       --@return string
     1 function StmtTrans:_transSelfParams(params)
         local code

         --(1) transform
    36   if #params > 0 then
    22     code = ""

    53     for _, p in ipairs(params) do
    31       if p.modifier == "$" then
    16         code = code .. string.format(
     8           [[Object.defineProperty(this, "%s", {value: %s, enum: true, writable: %s});]],
     8           transName(p.name),
     8           transName(p.name),
     8           not p.const
     8         )
    23       elseif p.modifier == ":" then
     2         code = code .. string.format(
     1           [[Object.defineProperty(this, "_%s", {value: %s, writable: %s});]],
     1           p.name,
     1           p.name,
     1           not p.const
               )
             end
           end
         end

         --(2) return
    36   return code or ""
       end

       --Return a call to the super constructor.
       --
       --@return string
     1 function StmtTrans:_transSuperConstructor(bargs)
     7   local trans = self._.trans
         local code

         --(1) Transform
     7   if bargs then
     2     if #bargs == 0 then
     1       code = "super();"
           else
     1       code = "super("

     3       for i, a in ipairs(bargs) do
     2         code = code .. (i == 1 and "" or ", ") .. trans:_trans(a)
             end

     1       code =  code .. ");"
           end
         end

         --(2) return
     7   return code or ""
       end

       --Transform a fn statement.
       --
       --@return string
     1 function StmtTrans:_transFn(stmt)
    34   if stmt.itype then
    13     return self:_transTypeFn(stmt)
         else
    21     return self:_transStdFn(stmt)
         end
       end

     1 function StmtTrans:_transStdFn(fn)
         local code

         --(1) transform
    42   code = string.format(
    21     "%sfunction %s(%s) { ",
    21     self:_transVisib(fn.visib),
    21     fn.name,
    21     self:_transParams(fn.params)
    21   )

    21   code = code .. self:_transReturnVar(fn)
    21   code = code .. self:_transParamsCheck(fn.params)
    21   code = code .. self:_transSelfParams(fn.params)
    21   if fn.catch or fn.finally then code = code .. " try " end
    21   code = code .. self:_transBody(fn.body)
    21   code = code .. self:_transCatch(fn.catch)
    21   code = code .. self:_transFinally(fn.finally)
    21   if fn.rvar then
     4     code = code .. string.format(" return %s;", fn.rvar == "self" and "this" or fn.rvar)
         end
    21   code = code .. " }"

         --(2) return
    21   return code
       end

     1 function StmtTrans:_transTypeFn(stmt)
    13   if tablex.find(stmt.annots, "prop") then
     4     return self:_transProp(stmt)
         else
     9     return self:_transMethod(stmt)
         end
       end

     1 function StmtTrans:_transProp(stmt)
         local code

         --(1) transform
     8   code = string.format(
     4     [[Object.defineProperty(%s.prototype, "%s%s", {enum: %s, get: function() { ]],
     4     stmt.itype,
     4     stmt.visib == "pub" and "" or "_",
     4     stmt.name,
     4     stmt.visib == "pub"
     8   )

     4   if tablex.find(stmt.annots, "abstract") then
     1     code = code .. "abstract();"
         else
     3     code = code .. self:_transReturnVar(stmt)
     3     if stmt.catch or stmt.finally then code = code .. " try " end
     3     code = code .. self:_transBody(stmt.body)
     3     code = code .. self:_transCatch(stmt.catch)
     3     code = code .. self:_transFinally(stmt.finally)

     3     if stmt.rvar then
     1       code = code .. string.format(" return %s;", stmt.rvar == "self" and "this" or stmt.rvar)
           end
         end

     4   code = code .. " }});"

         --(2) return
     4   return code
       end

     1 function StmtTrans:_transMethod(stmt)
         local code

         --(1) transform
     9   if tablex.find(stmt.annots, "abstract") then
     2     code = string.format(
     1       "%s.prototype.%s%s = function() { abstract(); };",
     1       stmt.itype,
     1       stmt.visib == "pub" and "" or "_",
             stmt.name
     2     )
         else
     8     if tablex.find(stmt.annots, "static") then
     2       code = string.format(
     1         "%s.%s%s = function(%s) { ",
     1         stmt.itype,
     1         stmt.visib == "pub" and "" or "_",
     1         stmt.name,
     1         self:_transParams(stmt.params)
     1       )
           else
    14       code = string.format(
     7         "%s.prototype.%s%s = function(%s) { ",
     7         stmt.itype,
     7         stmt.visib == "pub" and "" or "_",
     7         stmt.name,
     7         self:_transParams(stmt.params)
     7       )
           end

     8     code = code .. self:_transReturnVar(stmt)
     8     code = code .. self:_transParamsCheck(stmt.params)
     8     code = code .. self:_transSelfParams(stmt.params)

     8     if stmt.catch or stmt.finally then code = code .. " try " end
     8     code = code .. self:_transBody(stmt.body)
     8     code = code .. self:_transCatch(stmt.catch)
     8     code = code .. self:_transFinally(stmt.finally)

     8     if stmt.rvar then
     2       code = code .. string.format(" return %s;", stmt.rvar == "self" and "this" or stmt.rvar)
           end

     8     code = code .. " };"
         end

         --(2) return
     9   return code
       end

     1 function StmtTrans:_transReturnVar(fn)
         local code

         --(1) transform
    39   code = ""

    39   if fn.rvar then
     8     if fn.rvar ~= "self" and not fn.params:has(fn.rvar) then
     4       code = string.format("let %s;", fn.rvar)
           end
         end

         --(2) return
    39   return code
       end

       --Transform an if statement.
       --
       --@return string
     1 function StmtTrans:_transIf(stmt)
     6   local trans = self._.trans
         local code

         --(1) transform
    12   code = string.format(
     6     "if (%s) %s",
     6     trans:_trans(stmt.cond),
     6     self:_transBody(stmt.body)
     6   )

     6   if stmt.elif then
     5     for _, cl in ipairs(stmt.elif) do
     6       code = code .. string.format(
     3         " else if (%s) %s",
     3         trans:_trans(cl.cond),
     3         self:_transBody(cl.body)
             )
           end
         end

     6   if stmt.el then
     3     code = code .. " else " .. self:_transBody(stmt.el)
         end

         --(2) return
     6   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/SubTrans.lua
==============================================================================
       --A sub transformer.
     1 local SubTrans = {}
     1 SubTrans.__index = SubTrans
     1 package.loaded[...] = SubTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function SubTrans.new(trans)
  1824   return setmetatable({
   912     _ = {
   912       trans = trans
   912     }
  1824   }, SubTrans)
       end

       --Return a random name.
       --
       --@return string
     1 function SubTrans._getRandomName()
     3   math.randomseed(os.time())
     3   return "$aux" .. os.time() .. math.random(1, 10000)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/UnpackTrans.lua
==============================================================================
       --imports
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --An unpack sentence transformer.
     1 local UnpackTrans = {}
     1 UnpackTrans.__index = UnpackTrans
     1 setmetatable(UnpackTrans, {__index = SubTrans})
     1 package.loaded[...] = UnpackTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function UnpackTrans.new(trans)
   228   return setmetatable(SubTrans.new(trans), UnpackTrans)
       end

       --Transform an unpack sentence.
       --
       --@param sent:Unpack  Sentence to transform.
       --@return string
     1 function UnpackTrans:transform(sent)
    23   if sent.subtype == "[]" then
    12     if sent.assign == "=" then
    11       return self:_transList(sent)
           else
     1       return self:_transReadOnlyFieldsList(sent)
           end
    11   elseif sent.subtype == "{}" then
    11     if sent.assign == "=" then
    10       return self:_transMap(sent)
           else
     1       return self:_transReadOnlyFieldsMap(sent)
           end
         end
       end

       --Transform [...] = Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transList(sent)
    11   local trans = self._.trans
         local code

         --(1) visibility?
    11   if sent.visib == nil then
     7     code = ""
     4   elseif sent.visib == "export" then
     2     code = "export default "
     2   elseif sent.visib == "pub" then
     2     code = "export "
         end

         --(2) var or const definition?
    11   if sent.def == "var" then
     3     code = code .. "let "
     8   elseif sent.def == "const" then
     3     code = code .. "const "
         end

         --(3) variables
    11   code = code .. "["

    33   for i, var in ipairs(sent.vars) do
    22     local name = var.name
           local prefix

    22     if name:find("^%$") then
     1       prefix = "this."
     1       name = name:sub(2)
    21     elseif name:find("^:") then
     1       prefix = "this._"
     1       name = name:sub(2)
           else
    20       prefix = ""
           end

    44     code = code .. (i == 1 and "" or ", ") .. string.format(
    22       "%s%s%s%s",
    22       var.rest and "..." or "",
    22       prefix,
    22       name,
    22       var.value and (" = " .. trans:_trans(var.value)) or ""
    20     )
         end

    11   code = code .. "]"

         --(4) expression
    11   code = code .. " = " .. trans:_trans(sent.exp) .. ";"

         --(5) return
    11   return code
       end

       --Transform [...] := Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transReadOnlyFieldsList(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     1   code = string.format("const %s = %s;", valVar, trans:_trans(sent.exp))

         --(2) unpack
     4   for ix, fld in ipairs(sent.vars) do
     3     local name = fld.name

     3     if fld.name:find("^%$") then
     1       name = fld.name:sub(2)

     2       code = code .. string.format(
     1         'Object.defineProperty(this, "%s", {value: %s[%s], enum: true});',
     1         name,
     1         valVar,
     1         ix - 1
     1       )
     2     elseif fld.name:find("^:") then
     1       name = fld.name:sub(2)

     2       code = code .. string.format(
     1         'Object.defineProperty(this, "_%s", {value: %s[%s]});',
     1         name,
     1         valVar,
     1         ix - 1
     1       )
           else
     1       code = code .. string.format('%s = %s[%s];', name, valVar, ix - 1)
           end
         end

         --(3) return
     1   return code
       end

       --Transform {...} = Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transMap(sent)
    10   local trans = self._.trans
         local code

         --(1) visibility?
    10   if sent.visib == nil then
     6     code = ""
     4   elseif sent.visib == "export" then
     2     code = "export default "
     2   elseif sent.visib == "pub" then
     2     code = "export "
         end

         --(2) var or const definition?
    10   if sent.def == "var" then
     3     code = code .. "let "
     7   elseif sent.def == "const" then
     3     code = code .. "const "
         end

         --(3) variables
    10   if not sent.def then
     4     code = "({"
         else
     6     code = code .. "{"
         end

    24   for i, var in ipairs(sent.vars) do
    14     if sent.def then
    12       code = code .. (i == 1 and "" or ", ") .. string.format(
     6         "%s%s",
     6         var.name,
     6         var.value and (" = " .. trans:_trans(var.value)) or ""
    12       )
           else
     8       local name = var.name
             local prefix

     8       if name:find("^%$") then
     1         prefix = "this."
     1         name = name:sub(2)
     7       elseif name:find("^:") then
     1         prefix = "this._"
     1         name = name:sub(2)
             else
     6         prefix = ""
             end

    16       code = code .. (i == 1 and "" or ", ") .. string.format(
     8         "%s: %s%s%s",
     8         name,
     8         prefix,
     8         name,
     8         var.value and (" = " .. trans:_trans(var.value)) or ""
     6       )
           end
         end

    10   code = code .. "}"

         --(4) expression
    10   code = code .. " = " .. trans:_trans(sent.exp)

    10   if not sent.def then
     4     code = code .. ")"
         end

    10   code = code .. ";"

         --(5) return
    10   return code
       end

       --Transform {...} := Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transReadOnlyFieldsMap(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     1   code = string.format("const %s = %s;", valVar, trans:_trans(sent.exp))

         --(2) unpack
     4   for _, fld in ipairs(sent.vars) do
     3     local name = fld.name

     3     if fld.name:find("^%$") then
     1       name = fld.name:sub(2)

     2       code = code .. string.format(
     1         'Object.defineProperty(this, "%s", {value: %s["%s"], enum: true});',
     1         name,
     1         valVar,
               name
     2       )
     2     elseif fld.name:find("^:") then
     1       name = fld.name:sub(2)

     2       code = code .. string.format(
     1         'Object.defineProperty(this, "_%s", {value: %s["%s"]});',
     1         name,
     1         valVar,
               name
     2       )
           else
     1       code = code .. string.format('%s = %s["%s"];', name, valVar, name)
           end
         end

         --(3) return
     1   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/util.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")

     1 package.loaded[...] = {
         transName = function(name)
   365     local KEYWORDS = {
   365       "abstract", "await",
   365       "break",
   365       "case", "catch", "char", "class", "const", "continue",
   365       "debugger", "default", "do",
   365       "else", "enum", "export", "extends",
   365       "final", "finally", "for", "function",
   365       "goto",
   365       "if", "implements", "import", "in", "instanceof", "interface",
   365       "let",
   365       "native", "new",
   365       "private", "protected", "public",
   365       "return",
   365       "static", "super", "switch",
   365       "this", "throw", "transient", "try", "typeof",
   365       "var", "volatile",
   365       "while", "with",
             "yield"
   365     }

   365     if tablex.find(KEYWORDS, name) then
     5       return name .. "_"
           else
   360       return name
           end
         end
     1 }

==============================================================================
Summary
==============================================================================

File                                                                 Hits Missed Coverage
-----------------------------------------------------------------------------------------
/home/me/.luarocks/share/lua/5.3/dogma/lex/Lexer.lua                 422  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/LiteralType.lua           4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/TokenType.lua             10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/AdvancedList.lua        21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Annotation.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Char.lua                9    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Comment.lua             10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Directive.lua           10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Eol.lua                 10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Id.lua                  7    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Keyword.lua             60   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Literal.lua             12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Name.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/ProcessedList.lua       21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Reader.lua              51   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Symbol.lua              10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Token.lua               10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveParser.lua       38   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveType.lua         3    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/ExpParser.lua             304  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/NodeType.lua              4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/NonTerminalType.lua       4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/Parser.lua                104  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/SentType.lua              6    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtParser.lua            538  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtType.lua              19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/TerminalType.lua          19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/UnpackParser.lua          58   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AsyncStmt.lua           11   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BinOp.lua               18   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BlockParser.lua         34   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BreakStmt.lua           8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CallOp.lua              27   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CatchCl.lua             8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ConstStmt.lua           13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Directive.lua           10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DoStmt.lua              13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/EnumStmt.lua            19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Exp.lua                 15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FinallyCl.lua           7    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FnStmt.lua              17   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForEachStmt.lua         15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForStmt.lua             15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FromStmt.lua            13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfDirective.lua         12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfStmt.lua              13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfSubExp.lua            19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralFn.lua           28   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralList.lua         14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralMap.lua          14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NativeFn.lua            12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NextStmt.lua            8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Node.lua                9    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NonTerminal.lua         14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ObjectStmt.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Op.lua                  73   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Param.lua               12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Params.lua              12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PevalFn.lua             12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ReturnStmt.lua          20   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Sent.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SliceOp.lua             15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Stmt.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubExp.lua              10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubParser.lua           11   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SyntaxTree.lua          75   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Terminal.lua            16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ThrowFn.lua             16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/TypeStmt.lua            16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UnaryOp.lua             29   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Unpack.lua              15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseStmt.lua             20   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmt.lua             13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WhileStmt.lua           14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/Trans.lua               12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/Trans.lua            33   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/DirectiveTrans.lua 23   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/ExpTrans.lua       235  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/StmtTrans.lua      417  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/SubTrans.lua       12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/UnpackTrans.lua    137  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/util.lua           24   0      100.00%
-----------------------------------------------------------------------------------------
Total                                                                3472 0      100.00%
