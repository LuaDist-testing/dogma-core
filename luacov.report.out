==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/Lexer.lua
==============================================================================
       --imports
     1 local stringx = require("pl.stringx")
     1 local Reader = require("dogma.lex._.Reader")
     1 local ProcessedList = require("dogma.lex._.ProcessedList")
     1 local AdvancedList = require("dogma.lex._.AdvancedList")
     1 local Eol = require("dogma.lex._.Eol")
     1 local Annotation = require("dogma.lex._.Annotation")
     1 local Comment = require("dogma.lex._.Comment")
     1 local Directive = require("dogma.lex._.Directive")
     1 local Name = require("dogma.lex._.Name")
     1 local Keyword = require("dogma.lex._.Keyword")
     1 local Literal = require("dogma.lex._.Literal")
     1 local LiteralType = require("dogma.lex.LiteralType")
     1 local Symbol = require("dogma.lex._.Symbol")
     1 local TokenType = require("dogma.lex.TokenType")

       --A lexer os scanner.
     1 local Lexer = {}
     1 Lexer.__index = Lexer
     1 package.loaded[...] = Lexer

       --Constructor.
       --
       --@param props:object Lexer properties.
     1 function Lexer.new(props)
         local self

         --(1) arguments
   780   if not props then props = {} end

         --(2) create
  1560   self = setmetatable({
   780     _ = {
   780       comments = not not props.comments
   780     }
  1560   }, Lexer)

         --(3) return
   780   return self
       end

       --Raises an error.
       --
       --@param msg:string
     1 function Lexer:throw(msg)
    36   error(string.format("%s: %s", self._.file, msg))
       end

       --Scan a text.
       --
       --@param text:string  Text to analyze.
       --@param file?:string File path.
       --
       --@return self
     1 function Lexer:scan(text, file)
         --(1) arguments
   782   if not text then self:throw("text expected.") end

         --(2) init
   781   self._.reader = Reader.new(text)
   781   self._.file = file or "anonymous code"
   781   self._.processed = ProcessedList.new(3)
   781   self._.token = nil
   781   self._.advanced = AdvancedList.new(3)

         --(3) return
   781   return self
       end

       --Return the last token that has been read.
       --
       --@return Token
     1 function Lexer:_getLastReadToken()
  2195   return self._.token
       end

       --Scan the next token.
       --
       --@overload
       --@return Token
       --
       --@overload
       --@param typ:TokenType  Token type to read.
       --@param val:string     Token value to read.
       --@return Token
     1 function Lexer:next(typ, val)
 11348   local reader = self._.reader
         local tok

         --(1) get token to return
 11348   if self:_hasTokenToShift() then
  4263     self:_shift()
         else
           local ch

           --get next char
  7085     ch = reader:next()

  9015     while ch ~= nil and (ch.char == " " or ch.char == "\t") do
  1930       ch = reader:next()
           end

  7085     if ch ~= nil then
  6005       ch = ch.char

             --analyze token
  6005       reader:unshift()

  6005       if ch == "\n" then
   956         tok = self:_scanEol()
  5049       elseif ch == "@" then
    29         tok = self:_scanAnnotation()
  5020       elseif ch == "_" or stringx.isalpha(ch) then
  2195         tok = self:_scanId()
  2825       elseif ch == "'" then
     1         tok = self:_scanName()
  2824       elseif stringx.isdigit(ch) then
   582         tok = self:_scanLiteralNumber()
  2242       elseif ch == '"' then
    93         tok = self:_scanLiteralString()
  2149       elseif ch == "#" then
    48         reader:next()
    48         ch = reader:next().char

    48         reader:unshift()
    48         reader:unshift()

    48         if ch == "!" then
    43           tok = self:_scanDirective()
               else
     5           tok = self:_scanComment()

     5           if not self._.comments then
     1             return self:next()
                 end
               end
             else
  2101         tok = self:_scanSymbol()
             end

  5995       self:_backUpToken()
  5995       self._.token = tok
           else
  1080       self:_backUpToken()
  1080       self._.token = nil
           end
         end

         --(2) check
 11338   if typ then
  2263     tok = self._.token

  2263     if tok == nil then
     2       self:throw(string.format("'%s' expected at the end of code.", val))
           end

  2261     if tok.type ~= typ or (val ~= nil and tok.value ~= val) then
    19       if typ == TokenType.EOL then
     4         self:throw(string.format(
     2           "end of line expected on (%s, %s).",
     2           tok.line,
                 tok.col
     2         ))
    17       elseif typ == TokenType.NAME then
     6         self:throw(string.format(
     3           "name expected on (%s, %s).",
     3           tok.line,
                 tok.col
     3         ))
    14       elseif typ == TokenType.LITERAL then
     2         self:throw(string.format(
     1           "literal expected on (%s, %s).",
     1           tok.line,
                 tok.col
     1         ))
             else
    26         self:throw(string.format(
    13           "'%s' expected on (%s, %s).",
    13           val,
    13           tok.line,
                 tok.col
    13         ))
             end
           end
         end

         --(3) return
 11317   return self._.token
       end

       --Return the next token that must be an end of line.
       --
       --@return Eol
     1 function Lexer:nextEol()
    11   return self:next(TokenType.EOL)
       end

       --Return the next token that must be an id: keyword or name.
       --
       --@return Id
     1 function Lexer:nextId()
   168   local tok = self:advance()

   168   if tok.type == TokenType.KEYWORD or tok.type == TokenType.NAME then
   165     return self:next()
         else
     3     self:throw(string.format("on (%s, %s), id expected.", tok.line, tok.col))
         end
       end

       --Return the next token that must be a name.
       --
       --@return Name
     1 function Lexer:nextName()
    91   return self:next(TokenType.NAME)
       end

       --Return the next token that must be a symbol.
       --
       --@return Symbol
     1 function Lexer:nextSymbol(val)
   204   return self:next(TokenType.SYMBOL, val)
       end

       --Return the next token that must be a keyword.
       --
       --@return Keyword
     1 function Lexer:nextKeyword(val)
    51   return self:next(TokenType.KEYWORD, val)
       end

       --Advance the next token.
       --
       --@return Token
     1 function Lexer:advance(i)
         local tok

         --(1) arguments
  8046   if i == nil then
  7936     i = 1
         end

         --(2) get token
  8046   if #self._.advanced >= i then
  3811     tok = self._.advanced._.items[i]
         else
  4235     if i == 1 then
  4127       tok = self:next()
  4127       self:unshift()
   108     elseif i == 2 then
   107       self:next()
   107       tok = self:next()
   107       self:unshift()
   107       self:unshift()
     1     elseif i == 3 then
     1       self:next()
     1       self:next()
     1       tok = self:next()
     1       self:unshift()
     1       self:unshift()
     1       self:unshift()
           end
         end

         --(3) return
  8046   return tok
       end

       --Check whether the lexer has some token to shift.
       --
       --@return bool
     1 function Lexer:_hasTokenToShift()
 11348   return #self._.advanced > 0
       end

       --Shift a token: <- processed <- current <- advanced
     1 function Lexer:_shift()
         --(1) pre
  4264   if #self._.advanced == 0 then
     1     self:throw("no advanced token to shift.")
         end

         --(2) current to processed
  4263   if self._.token then
  3470     self._.processed:insert(self._.token)
         end

         --(3) advanced to current
  4263   self._.token = self._.advanced:remove()
       end

       --Unshift a char: processed -> current -> advanced
     1 function Lexer:unshift()
         --(1) pre
  5514   if not self._.token and #self._.processed == 0 then
     1     self:throw("no current token to unshift.")
         end

         --(2) current to advanced
  5513   self._.advanced:insert(self._.token)

         --(3) last processed to current
  5513   if #self._.processed == 0 then
   797     self._.token = nil
         else
  4716     self._.token = self._.processed:remove()
         end
       end

       --Shift current token to processed tokens: processed <- token.
     1 function Lexer:_backUpToken()
  7075   if self._.token then
  6311     self._.processed:insert(self._.token)
         end
       end

       --Scan an end of line.
       --
       --@return Eol
     1 function Lexer:_scanEol()
   956   local reader = self._.reader
   956   local ch = reader:next()

   956   return Eol.new(ch.line, ch.col)
       end

       --Scan an annotation.
       --
       --@return Annotation
     1 function Lexer:_scanAnnotation()
    29   local rdr = self._.reader
         local state, ln, col, val
    29   local State = {
    29     START = 1,
    29     VALUE = 2,
    29     END = 3
         }

         --(1) state machine
    29   state = State.START

   233   while state ~= State.END do
   204     local ch = rdr:next()

   204     if state == State.START then
    29       ln, col, val = ch.line, ch.col, ""
    29       state = State.VALUE
   175     elseif state == State.VALUE then
   175       ch = ch.char

   175       if not (stringx.isalnum(ch) or ch == "_") then
    29         rdr:unshift()
    29         state = State.END
             else
   146         val = val .. ch
             end
           end
         end

         --(2) return
    29   return Annotation.new(ln, col, val)
       end

       --Scan a directive.
       --
       --@return Directive
     1 function Lexer:_scanDirective()
    43   local rdr = self._.reader
         local state, ln, col, val
    43   local State = {
    43     START1 = 1,
    43     START2 = 2,
    43     VALUE = 3,
    43     END = 4
         }

         --(1) state machine
    43   state = State.START1

   526   while state ~= State.END do
   483     local ch = rdr:next()

   483     if state == State.START1 then
    43       ln, col, val = ch.line, ch.col, ""
    43       state = State.START2
   440     elseif state == State.START2 then
    43       state = State.VALUE
   397     elseif state == State.VALUE then
   397       ch = ch.char

   397       if ch == "\n" then
    43         state = State.END
             else
   354         val = val .. ch
             end
           end
         end

    43   if not (val:find("^if [a-zA-Z]+ then$") or val:find("^if not [a-zA-Z]+ then$") or val:find("^/") or val == "end" or val == "else") then
     2     self:throw(string.format("on (%s,%s), invalid directive.", ln, col))
         end

         --(2) return
    41   return Directive.new(ln, col, val)
       end

       --Scan a comment.
       --
       --@return Comment
     1 function Lexer:_scanComment()
     5   local reader = self._.reader
         local state, ln, col, comm
     5   local State = {
     5     START = 1,
     5     TEXT = 2,
     5     POSSIBLE_END = 3,
     5     END = 4
         }

         --(1) state machine
     5   state = State.START

   120   while state ~= State.END do
   115     local ch = reader:next()

   115     if state == State.START then
     5       ln, col, comm = ch.line, ch.col, ""
     5       state = State.TEXT
   110     elseif state == State.TEXT then
   104       ch = ch.char

   104       if ch == "\n" then
     6         state = State.POSSIBLE_END
             else
    98         comm = comm .. ch
             end
           else  --POSSIBLE_END
     6       if ch == nil then
     4         reader:unshift()  --current: nil
     4         reader:unshift()  --end of line
     4         state = State.END
             else
     2         ch = ch.char

     2         if ch == "#" then
     1           comm = comm .. "\n"
     1           state = State.TEXT
               else
     1           reader:unshift()  --current char
     1           reader:unshift()  --eol
     1           state = State.END
               end
             end
           end
         end

         --(2) return
     5   return Comment.new(ln, col, comm)
       end

       --Scan an identifier.
       --
       --@return Id
     1 function Lexer:_scanId()
  2195   local reader = self._.reader
         local state, ln, col, id
  2195   local State = {
  2195     START = 1,
  2195     MIDDLE = 2,
  2195     END = 3
         }

         --(1) state machine
  2195   state = State.START

 10181   while state ~= State.END do
  7986     local ch = reader:next()

  7986     if state == State.START then
  2195       ln, col = ch.line, ch.col
  2195       id = ch.char
  2195       state = State.MIDDLE
           else
  5791       ch = ch.char

  5791       if ch == "_" or stringx.isalnum(ch) then
  3596         id = id .. ch
             else
  2195         state = State.END
  2195         reader:unshift()
             end
           end
         end

         --(2) return
  2195   local last = self:_getLastReadToken()

  2195   if (last and last.type == TokenType.SYMBOL and (last.value == "." or last.value == ":" or last.value == "?")) or
  2042      not Keyword.isKeyword(id) then
  1468     return Name.new(ln, col, id)
         else
   727     return Keyword.new(ln, col, id)
         end
       end

       --Scan a name.
       --
       --@return Name
     1 function Lexer:_scanName()
     1   local reader = self._.reader
         local state, ln, col, id, ch
     1   local State = {
     1     START = 1,
     1     ID = 2,
     1     END = 3
         }

         --(1) state machine
     1   state = State.START
     1   ch = reader:next()  --'
     1   ln, col = ch.line, ch.col

     9   while state ~= State.END do
     8     ch = reader:next()

     8     if state == State.START then
     1       id = ch.char
     1       state = State.ID
           else --State.ID
     7       ch = ch.char

     7       if ch == "'" then
     1         state = State.END
             else
     6         id = id .. ch
             end
           end
         end

         --(2) return
     1   return Name.new(ln, col, id)
       end

       --Scan a symbol.
       --
       --@return Symbol
     1 function Lexer:_scanSymbol()
  2101   local reader = self._.reader
         local state, ln, col, sym
  2101   local State = {
  2101     START = 1,
  2101     MIDDLE = 2,
  2101     END = 3
         }
  2101   local SYMBOLS = {
  2101     ["+"] = true,
  2101     ["+="] = true,
  2101     ["-"] = true,
  2101     ["-="] = true,
  2101     ["->"] = true,
  2101     ["*"] = true,
  2101     ["*="] = true,
  2101     ["**"] = true,
  2101     ["**="] = true,
  2101     ["/"] = true,
  2101     ["/="] = true,
  2101     ["%"] = true,
  2101     ["%="] = true,
  2101     ["="] = true,
  2101     ["=="] = true,
  2101     ["==="] = true,
  2101     ["=~"] = true,
  2101     ["!"] = true,
  2101     ["!="] = true,
  2101     ["!=="] = true,
  2101     ["!~"] = true,
  2101     ["<"] = true,
  2101     ["<<"] = true,
  2101     ["<<<"] = true,
  2101     ["<<="] = true,
  2101     ["<="] = true,
  2101     [">"] = true,
  2101     [">>"] = true,
  2101     [">>>"] = true,
  2101     [">>="] = true,
  2101     [">="] = true,
  2101     ["^"] = true,
  2101     ["^="] = true,
  2101     ["~"] = true,
  2101     ["~="] = true,
  2101     ["("] = true,
  2101     [")"] = true,
  2101     ["["] = true,
  2101     ["]"] = true,
  2101     ["{"] = true,
  2101     ["}"] = true,
  2101     [";"] = true,
  2101     [":"] = true,
  2101     [":="] = true,
  2101     [":=|"] = true,
  2101     ["."] = true,
  2101     [".."] = true,
  2101     ["..."] = true,
  2101     [".="] = true,
  2101     ["?"] = true,
  2101     ["?="] = true,
  2101     ["&"] = true,
  2101     ["&="] = true,
  2101     ["&&"] = true,
  2101     ["|"] = true,
  2101     ["|="] = true,
  2101     ["||"] = true,
  2101     [","] = true
         }

         --(1) state machine
  2101   state = State.START

  6503   while state ~= State.END do
  4402     local ch = reader:next()

  4402     if state == State.START then
  2101       if SYMBOLS[ch.char] then
  2099         ln, col, sym = ch.line, ch.col, ch.char
  2099         state = State.MIDDLE
             else
     2         reader:unshift()
     2         state = State.END
             end
           else
  2301       if SYMBOLS[sym .. ch.char] then
   202         sym = sym .. ch.char
             else
  2099         reader:unshift()
  2099         state = State.END
             end
           end
         end

         --(2) return
  2101   if sym == nil then
     2     self:throw(string.format("invalid symbol on (%s, %s).", reader._.line, reader._.col - 1))
         end

  2099   return Symbol.new(ln, col, sym)
       end

       --Scan a literal hnumber.
       --
       --@return Literal
     1 function Lexer:_scanLiteralNumber()
   582   local reader = self._.reader
         local state, ln, col, lit
   582   local State = {
   582     START = 1,
   582     INT = 2,
   582     DOT = 3,
   582     DECIMAL = 4,
   582     END = 5
         }

         --(1) state machine
   582   state = State.START

  2141   while state ~= State.END do
  1559     local ch = reader:next()

  1559     if state == State.START then
   582       ln, col, lit = ch.line, ch.col, ch.char
   582       state = State.INT
   977     elseif state == State.INT then
   967       ch = ch.char

   967       if stringx.isdigit(ch) then
   308         lit = lit .. ch
   659       elseif ch == " " then
    77         lit = lit --nothing to do
   582       elseif ch == "." then
     4         state = State.DOT
             else
   578         reader:unshift()
   578         state = State.END
             end
    10     elseif state == State.DOT then
     4       ch = ch.char

     4       if stringx.isdigit(ch) then
     2         lit = lit .. "." .. ch
     2         state = State.DECIMAL
             else
     2         reader:unshift() --current
     2         reader:unshift() --dot
     2         state = State.END
             end
           else  --DECIMAL
     6       ch = ch.char

     6       if stringx.isdigit(ch) then
     4         lit = lit .. ch
             else
     2         reader:unshift()
     2         state = State.END
             end
           end
         end

         --(2) return
   582   return Literal.new(ln, col, LiteralType.NUMBER, tonumber(lit))
       end

       --Scan a literal string.
       --
       --@return Literal
     1 function Lexer:_scanLiteralString()
    93   local reader = self._.reader
         local state, ln, col, lit
    93   local State = {
    93     START = 1,
    93     START1 = 2,
    93     START2 = 3,
    93     TEXT1 = 4,
    93     TEXT3 = 5,
    93     END1 = 6,
    93     END2 = 7,
    93     END = 8,
    93     TEXT3_START = 9
         }

         --(1) state machine
    93   state = State.START

   878   while state ~= State.END do
   790     local ch = reader:next()

   794     ::START::if state == State.START then
    93       ln, col, lit = ch.line, ch.col, ""
    93       state = State.START1
   701     elseif state == State.START1 then
    93       ch = ch.char

    93       if ch == '"' then
     8         state = State.START2
             else
    85         lit = lit .. ch
    85         state = State.TEXT1
             end
   608     elseif state == State.START2 then
     8       ch = ch.char

     8       if ch == '"' then
     7         state = State.TEXT3_START
             else
     1         reader:unshift()
     1         state = State.END
             end
   600     elseif state == State.TEXT1 then  --"literal"
   514       if ch == nil then
     2         self:throw(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

   512       ch = ch.char

   512       if ch == '"' then
    83         state = State.END
             else
   429         lit = lit .. ch
             end
    86     elseif state == State.TEXT3_START then
     7       state = State.TEXT3
     7       if ch.char ~= "\n" then goto START end
    79     elseif state == State.TEXT3 then  --"""literal"""
    67       if ch == nil then
     2         self:throw(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

    65       if ch.col >= col or ch.char ~= " " then
    50         ch = ch.char

    50         if ch == '"' then
     6           state = State.END1
               else
    44           lit = lit .. ch
               end
             end
    12     elseif state == State.END1 then
     6       ch = ch.char

     6       if ch == '"' then
     5         state = State.END2
             else
     1         lit = lit .. '"' .. ch
     1         state = State.TEXT3
             end
           else  --State.END2
     6       if ch == nil then
     1         self:throw(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

     5       ch = ch.char

     5       if ch == '"' then
     4         state = State.END

     4         if lit:sub(-1) == "\n" then
     1           lit = lit:sub(1, -2)
               end
             else
     1         lit = lit .. '""' .. ch
             end
           end
         end

         --(2) return
    88   return Literal.new(ln, col, LiteralType.STRING, lit)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/LiteralType.lua
==============================================================================
     1 return {
     1   STRING = 1,
     1   NUMBER = 2
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/TokenType.lua
==============================================================================
     1 return {
     1   COMMENT = 1,
     1   EOL = 2,
     1   NAME = 3,
     1   KEYWORD = 4,
     1   LITERAL = 5,
     1   SYMBOL = 6,
     1   DIRECTIVE = 7,
     1   ANNOTATION = 8
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/AdvancedList.lua
==============================================================================
     1 local AdvancedList = {}
     1 AdvancedList.__index = AdvancedList
     1 package.loaded[...] = AdvancedList

     1 function AdvancedList.new(max)
         --(1) arguments
  1587   if max == nil then error("max expected.") end

         --(2) return
  3172   return setmetatable({
  1586     _ = {
  1586       max = max,
  1586       items = {}
  1586     }
  3172   }, AdvancedList)
       end

     1 function AdvancedList:__len()
 91999   return #self._.items
       end

     1 function AdvancedList:insert(item)
 16553   if #self == self._.max then
     1     error("list already full.")
         end

 16552   table.insert(self._.items, 1, item)
       end

     1 function AdvancedList:remove()
 15176   if #self == 0 then
     1     error("empty list, nothing to remove.")
         end

 15175   return table.remove(self._.items, 1)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Annotation.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --An annotation.
     1 local Annotation = {}
     1 Annotation.__index = Annotation
     1 setmetatable(Annotation, {__index = Token})
     1 package.loaded[...] = Annotation

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param val:string
     1 function Annotation.new(ln, col, val)
    29   return setmetatable(Token.new(TokenType.ANNOTATION, ln, col, val), Annotation)
       end

       --@override
     1 function Annotation:__tostring()
     7   return string.format("<annotation>%s</annotation>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Char.lua
==============================================================================
       --A character.
     1 local Char = {}
     1 Char.__index = Char
     1 package.loaded[...] = Char

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param ch:char    Character.
     1 function Char.new(ln, col, ch)
 27370   return setmetatable({
 13685     line = ln,
 13685     col = col,
 13685     char = ch
 27370   }, Char)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Comment.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A comment.
     1 local Comment = {}
     1 Comment.__index = Comment
     1 setmetatable(Comment, {__index = Token})
     1 package.loaded[...] = Comment

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param text:string  Comment text.
     1 function Comment.new(ln, col, text)
     5   return setmetatable(Token.new(TokenType.COMMENT, ln, col, text), Comment)
       end

       --@override
     1 function Comment:__tostring()
    20   return string.format("<comment>%s</comment>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Directive.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A comilation directive.
     1 local Directive = {}
     1 Directive.__index = Directive
     1 setmetatable(Directive, {__index = Token})
     1 package.loaded[...] = Directive

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param val:string
     1 function Directive.new(ln, col, val)
    41   return setmetatable(Token.new(TokenType.DIRECTIVE, ln, col, val), Directive)
       end

       --@override
     1 function Directive:__tostring()
    35   return string.format("<directive>%s</directive>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Eol.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --An end of line.
     1 local Eol = {}
     1 Eol.__index = Eol
     1 setmetatable(Eol, {__index = Token})
     1 package.loaded[...] = Eol

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function Eol.new(ln, col)
   956   return setmetatable(Token.new(TokenType.EOL, ln, col, "\n"), Eol)
       end

     1 function Eol:__tostring()
    95   return string.format("<eol line=%s col=%s />", self.line, self.col)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Id.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")

       --An identifier.
     1 local Id = {}
     1 Id.__index = Id
     1 setmetatable(Id, {__index = Token})
     1 package.loaded[...] = Id

       --Constructor.
       --
       --@param t:string   Token type.
       --@param ln:number  Line number.
       --@param col:number Column number
       --@param id:string  Identifier.
     1 function Id.new(t, ln, col, id)
  2202   return setmetatable(Token.new(t, ln, col, id), Id)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Keyword.lua
==============================================================================
       --imports
     1 local Id = require("dogma.lex._.Id")
     1 local TokenType = require("dogma.lex.TokenType")

       --A keyword.
     1 local Keyword = {}
     1 Keyword.__index = Keyword
     1 setmetatable(Keyword, {__index = Id})
     1 package.loaded[...] = Keyword

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param id:string  Identifier.
     1 function Keyword.new(ln, col, id)
   733   return setmetatable(Id.new(TokenType.KEYWORD, ln, col, id), Keyword)
       end

       --Check whether an identifier is a keyword.
       --
       --@param id:string  Identifier to check.
       --@return bool
     1 function Keyword.isKeyword(id)
  2042   local KEYWORDS = {
  2042     ["and"] = true,
  2042     ["as"] = true,
  2042     ["async"] = true,
  2042     ["await"] = true,
  2042     ["break"] = true,
  2042     ["catch"] = true,
  2042     ["const"] = true,
  2042     ["do"] = true,
  2042     ["dogma"] = true,
  2042     ["each"] = true,
  2042     ["else"] = true,
  2042     ["end"] = true,
  2042     ["enum"] = true,
  2042     ["export"] = true,
  2042     ["extern"] = true,
  2042     ["false"] = true,
  2042     ["finally"] = true,
  2042     ["fn"] = true,
  2042     ["for"] = true,
  2042     ["from"] = true,
  2042     ["if"] = true,
  2042     ["iif"] = true,
  2042     ["impl"] = true,
  2042     ["in"] = true,
  2042     ["is"] = true,
  2042     ["like"] = true,
  2042     ["native"] = true,
  2042     ["next"] = true,
  2042     ["nil"] = true,
  2042     ["nop"] = true,
  2042     ["not"] = true,
  2042     ["op"] = true,
  2042     ["or"] = true,
  2042     ["pawait"] = true,
  2042     ["peval"] = true,
  2042     ["pub"] = true,
  2042     ["pvt"] = true, --private
  2042     ["return"] = true,
  2042     ["self"] = true,
  2042     ["Self"] = true,
  2042     ["super"] = true,
  2042     ["then"] = true,
  2042     ["throw"] = true,
  2042     ["true"] = true,
  2042     ["type"] = true,
  2042     ["use"] = true,
  2042     ["var"] = true,
  2042     ["while"] = true,
  2042     ["with"] = true,
  2042     ["yield"] = true
         }

  2042   return KEYWORDS[id] or false
       end

       --@override
     1 function Keyword:__tostring()
    14   return string.format("<keyword>%s</keyword>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Literal.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A literal.
     1 local Literal = {}
     1 Literal.__index = Literal
     1 setmetatable(Literal, {__index = Token})
     1 package.loaded[...] = Literal

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param t:string     Literal type: number, string...
       --@param val:any      Literal value.
     1 function Literal.new(ln, col, t, val)
         local self

         --(1) create
   670   self = setmetatable(Token.new(TokenType.LITERAL, ln, col, val), Literal)
   670   self.subtype = t

         --(2) return
   670   return self
       end

       --@override
     1 function Literal:__tostring()
   174   return string.format("<literal type='%s'>%s</literal>", self.type, self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Name.lua
==============================================================================
       --imports
     1 local Id = require("dogma.lex._.Id")
     1 local TokenType = require("dogma.lex.TokenType")

       --An identifier.
     1 local Name = {}
     1 Name.__index = Id
     1 setmetatable(Name, {__index = Id})
     1 package.loaded[...] = Name

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number
       --@param id:string  Identifier.
     1 function Name.new(ln, col, id)
  1469   return setmetatable(Id.new(TokenType.NAME, ln, col, id), Id)
       end

       --@override
     1 function Id:__tostring()
   126   return string.format("<name>%s</name>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/ProcessedList.lua
==============================================================================
     1 local List = {}
     1 List.__index = List
     1 package.loaded[...] = List

     1 function List.new(max)
         --(1) arguments
  1587   if max == nil then error("max expected.") end

         --(2) return
  3172   return setmetatable({
  1586     _ = {
  1586       max = max,
  1586       items = {}
  1586     }
  3172   }, List)
       end

     1 function List:__len()
 65816   return #self._.items
       end

     1 function List:insert(item)
 33238   if #self == self._.max then
 14764     table.remove(self._.items, 1)
         end

 33238   table.insert(self._.items, item)
       end

     1 function List:remove()
 14951   if #self == 0 then
     1     error("internal error: invalid remove from previous list.")
         end

 14950   return table.remove(self._.items)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Reader.lua
==============================================================================
       --imports
     1 local stringx = require("pl.stringx")
     1 local Char = require("dogma.lex._.Char")
     1 local ProcessedList = require("dogma.lex._.ProcessedList")
     1 local AdvancedList = require("dogma.lex._.AdvancedList")

       --A text reader.
     1 local Reader = {}
     1 Reader.__index = Reader
     1 package.loaded[...] = Reader

       --Constructor.
     1 function Reader.new(txt)
  1596   return setmetatable({
   798     _ = {
   798       text = stringx.split(txt, "\n"),
   798       line = 1,
   798       col = 1,
   798       processed = ProcessedList.new(3),
   798       char = nil,
   798       advanced = AdvancedList.new(3),
   798     }
  1596   }, Reader)
       end

       --Check whether the lexer has some char to shift.
       --
       --@return bool
     1 function Reader:_hasCharToShift()
 25680   return #self._.advanced > 0
       end

       --Read the next character.
       --
       --@return Char
     1 function Reader:next()
         --(1) read
 25680   if self:_hasCharToShift() then
 10904     self:_shift()
         else
 14776     local ln = self._.text[self._.line]

 14776     if ln then
 13685       if self._.col > #ln then
  1052         self:_backUp()
  1052         self._.char = Char.new(self._.line, self._.col, "\n")
  1052         self._.line = self._.line + 1
  1052         self._.col = 1
             else
 12633         self:_backUp()
 12633         self._.char = Char.new(self._.line, self._.col, ln:sub(self._.col, self._.col))
 12633         self._.col = self._.col + 1
             end
           else  --end of input
  1091       self:_backUp()
  1091       self._.char = nil
           end
         end

         --(2) return
 25680   return self._.char
       end

       --Shift a char: <- processed <- current <- advanced
     1 function Reader:_shift()
         --(1) pre
 10908   if #self._.advanced == 0 then
     1     error("no advanced char to shift.")
         end

         --(2) current to processed
 10907   if self._.char then
 10107     self._.processed:insert(self._.char)
         end

         --(3) advanced to current
 10907   self._.char = self._.advanced:remove()
       end

       --Unshift a char: processed -> current -> advanced
     1 function Reader:unshift()
         --(1) current to advanced
 11033   if self._.char then
 11028     self._.advanced:insert(self._.char)
         end

         --(2) last processed to current
 11033   if #self._.processed == 0 then
   804     self._.char = nil
         else
 10229     self._.char = self._.processed:remove()
         end
       end

       --Shift current char to processed chars: processed <- char.
     1 function Reader:_backUp()
 14776   if self._.char then
 13338     self._.processed:insert(self._.char)
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Symbol.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A symbol.
     1 local Symbol = {}
     1 Symbol.__index = Symbol
     1 setmetatable(Symbol, {__index = Token})
     1 package.loaded[...] = Symbol

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param sym:string   Symbol.
     1 function Symbol.new(ln, col, sym)
  2099   return setmetatable(Token.new(TokenType.SYMBOL, ln, col, sym), Symbol)
       end

       --@override
     1 function Symbol:__tostring()
   514   return string.format("<symbol>%s</symbol>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Token.lua
==============================================================================
       --A token.
     1 local Token = {}
     1 Token.__index = Token
     1 package.loaded[...] = Token

       --Constructor.
       --
       --@param t:TokenType  Token type.
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param val:any      Value.
     1 function Token.new(t, ln, col, val)
 12004   return setmetatable({
  6002     type = t,
  6002     line = ln,
  6002     col = col,
  6002     value = val
 12004   }, Token)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveParser.lua
==============================================================================
       --imports
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local IfDirective = require("dogma.syn._.IfDirective")
     1 local RunWithDirective = require("dogma.syn._.RunWithDirective")

       --A directive parser.
     1 local DirectiveParser = {}
     1 DirectiveParser.__index = DirectiveParser
     1 setmetatable(DirectiveParser, {__index = SubParser})
     1 package.loaded[...] = DirectiveParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function DirectiveParser.new(parser)
   663   return setmetatable(SubParser.new(parser), DirectiveParser)
       end

       --Read the next if directive.
       --
       --@return Directive
     1 function DirectiveParser:nextIf()
    14   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, el

         --(1) read if
    14   tok = lex:next(TokenType.DIRECTIVE)
    14   ln, col = tok.line, tok.col

    14   if tok.value:find("^if [a-zA-Z_0-9]+ then$") then
     9     cond = tok.value:match("^if ([a-zA-Z_0-9]+) then$")
         else
     5     cond = tok.value:match("^if (not [a-zA-Z_0-9]+) then$")
         end

    14   body = {}
         while true do
    55     tok = lex:advance()

    55     if tok == nil then
             break
    54     elseif tok.type == TokenType.EOL then
    21       lex:next()
           else
    33       if tok.type == TokenType.DIRECTIVE then
    13         if tok.value == "else" or tok.value == "end" then
                 break
               else
     1           error(string.format("on (%s,%s), if directive can't be nested.", tok.line, tok.col))
               end
             end

    20       table.insert(body, parser:next())
           end
         end

         --(2) read else
    13   tok = lex:advance()

    13   if tok and tok.type == TokenType.DIRECTIVE and tok.value == "else" then
     6     lex:next()

     6     el = {}
           while true do
    18       tok = lex:advance()

    18       if tok.type == TokenType.EOL then
     6         lex:next()
             else
    12         if tok.type == TokenType.DIRECTIVE then
     6           if tok.value == "end" then
                   break
                 else
     1             error(string.format("on (%s,%s), else directive can't be nested.", tok.line, tok.col))
                 end
               end

     6         table.insert(el, parser:next())
             end
           end
         end

         --(3) read end
    12   lex:next(TokenType.DIRECTIVE, "end")

         --(4) return
    11   return IfDirective.new(ln, col, cond, body, el)
       end

       --Read the next #!/... directive.
       --
       --@return RunWithDirective
     1 function DirectiveParser:nextRunWith()
     3   local lex = self._.lexer
         local tok

     3   tok = lex:next(TokenType.DIRECTIVE)
     3   return RunWithDirective.new(tok.line, tok.col, tok.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveType.lua
==============================================================================
     1 return {
     1   IF = "if",
     1   RUNWITH = "runWith"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/ExpParser.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local Keyword = require("dogma.lex._.Keyword")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local SubExp = require("dogma.syn._.SubExp")
     1 local IfSubExp = require("dogma.syn._.IfSubExp")
     1 local UnaryOp = require("dogma.syn._.UnaryOp")
     1 local BinOp = require("dogma.syn._.BinOp")
     1 local SliceOp = require("dogma.syn._.SliceOp")
     1 local CallOp = require("dogma.syn._.CallOp")
     1 local Exp = require("dogma.syn._.Exp")
     1 local LiteralList = require("dogma.syn._.LiteralList")
     1 local LiteralMap = require("dogma.syn._.LiteralMap")
     1 local LiteralFn = require("dogma.syn._.LiteralFn")
     1 local PevalFn = require("dogma.syn._.PevalFn")
     1 local NativeFn = require("dogma.syn._.NativeFn")
     1 local ThrowFn = require("dogma.syn._.ThrowFn")
     1 local ReturnStmt = require("dogma.syn._.ReturnStmt")
     1 local PackOp = require("dogma.syn._.PackOp")
     1 local AwaitFn = require("dogma.syn._.AwaitFn")
     1 local PawaitFn = require("dogma.syn._.PawaitFn")
     1 local UseFn = require("dogma.syn._.UseFn")
     1 local IifFn = require("dogma.syn._.IifFn")
     1 local UpdateOp = require("dogma.syn._.UpdateOp")
     1 local Params = require("dogma.syn._.Params")

       --An expression parser.
     1 local ExpParser = {}
     1 ExpParser.__index = ExpParser
     1 setmetatable(ExpParser, {__index = SubParser})
     1 package.loaded[...] = ExpParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function ExpParser.new(parser)
         local self

         --(1) create
   663   self = setmetatable(SubParser.new(parser), ExpParser)
   663   self._.stmtParser = parser._.stmtParser

         --(2) return
   663   return self
       end

       --Read an expression.
       --
       --@return Exp
     1 function ExpParser:next()
   710   return self:_readExp()
       end

     1 function ExpParser:_readExp()
   952   local lex = self._.lexer
         local tok, node, exp

         --(1) init expression
   952   tok = lex:advance()
   952   exp = Exp.new(tok.line, tok.col)

         --(2) read
         while true do
  3093     tok = lex:next()

  3093     if tok == nil then
     3       if exp.tree:isWellFormed() then
               break
             else
     6         error(string.format(
     3           "incomplete expression started on (%s, %s).",
     3           exp.line,
                 exp.col
     3         ))
             end
           end

  3090     if tok.type == TokenType.EOL then
   587       if exp.tree:isWellFormed() then
   582         lex:unshift()
               break
             end
  2503     elseif tok.type == TokenType.SYMBOL and tok.value == "(" then
   110       lex:unshift()

   110       if exp.tree:isWellFormed() then
    97         self:_readCallArgs(exp)
             else
    13         exp:insert(self:_readSubExp())
             end
  2393     elseif tok.type == TokenType.SYMBOL and tok.value == "[" then
    28       lex:unshift()

    28       if exp.tree:isWellFormed() then
    15         self:_readIndexOp(exp)
             else
    13         exp:insert(self:_readLiteralList())
             end
  2365     elseif tok.type == TokenType.SYMBOL and tok.value == "{" then
    34       lex:unshift()

    34       if exp.tree:isWellFormed() then
    18         self:_readPackOp(exp)
             else
    16         exp:insert(self:_readLiteralMap())
             end
  2331     elseif tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") and lex:advance().type == TokenType.SYMBOL and lex:advance().value == "{" then
    22       lex:unshift() --the dot

    22       if exp.tree:isWellFormed() then
    21         self:_readUpdateOp(exp)
             else
     1         error(string.format("on (%s,%s), '.{' and ':{' are not unary ops.", tok.line, tok.col))
             end
  2309     elseif tok.type == TokenType.KEYWORD and tok.value == "await" then
     2       lex:unshift()
     2       exp:insert(self:_readAwait())
  2307     elseif tok.type == TokenType.KEYWORD and tok.value == "fn" then
    13       lex:unshift()
    13       exp:insert(self:_readFn())
  2294     elseif tok.type == TokenType.KEYWORD and tok.value == "if" then
     7       lex:unshift()
     7       exp:insert(self:_readIfSubExp())
  2287     elseif tok.type == TokenType.KEYWORD and tok.value == "iif" then
     4       lex:unshift()
     4       exp:insert(self:_readIif())
  2283     elseif tok.type == TokenType.KEYWORD and tok.value == "native" then
     3       lex:unshift()
     3       exp:insert(self:_readNative())
  2280     elseif tok.type == TokenType.KEYWORD and tok.value == "pawait" then
     2       lex:unshift()
     2       exp:insert(self:_readPawait())
  2278     elseif tok.type == TokenType.KEYWORD and tok.value == "peval" then
     4       lex:unshift()
     4       exp:insert(self:_readPeval())
  2274     elseif tok.type == TokenType.KEYWORD and tok.value == "throw" then
     6       lex:unshift()
     6       exp:insert(self:_readThrow())
  2268     elseif tok.type == TokenType.KEYWORD and tok.value == "use" then
     2       lex:unshift()
     2       exp:insert(self:_readUse())
           else
  2266       if tok.type == TokenType.KEYWORD and tok.value == "not" then
     8         local aux = lex:advance()

     8         if aux.type == TokenType.KEYWORD and aux.value == "in" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "notin"))
     6         elseif aux.type == TokenType.KEYWORD and aux.value == "like" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "notlike"))
               else
     4           node = UnaryOp.new(tok)
               end
  2258       elseif tok.type == TokenType.KEYWORD and tok.value == "is" then
     4         local aux = lex:advance()

     4         if aux.type == TokenType.KEYWORD and aux.value == "not" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "isnot"))
               else
     2           node = self:_getNodeOf(tok)
               end
  2254       elseif tok.type == TokenType.SYMBOL and tablex.find({"+", "-", "<<<", ">>>"}, tok.value) then
   323         if exp.tree:isWellFormed() then
   311           node = BinOp.new(tok)
               else
    12           node = UnaryOp.new(tok)
               end
  1931       elseif tok.type == TokenType.SYMBOL and tok.value == ":" then
    16         if exp.tree:isWellFormed() then
    10           node = BinOp.new(tok)
               else
     6           node = UnaryOp.new(tok)
               end
  1915       elseif tok.type == TokenType.SYMBOL and tok.value == "." then
    27         if exp.tree:isWellFormed() then
    18           node = BinOp.new(tok)
               else
     9           node = UnaryOp.new(tok)
               end
             else
  1888         node = self:_getNodeOf(tok)
             end

  2266       if node == nil then
   348         if exp.tree:isWellFormed() then
   347           lex:unshift()
                 break
               else
     2           error(string.format(
     1             "invalid expression node on (%s, %s).",
     1             tok.line,
                   tok.col
     1           ))
               end
             else
  1918         exp:insert(node)
             end
           end
         end

         --(3) return
   929   return exp
       end

       --Return a node for a given token.
       --
       --@param tok:Token  The token.
       --@return Node
     1 function ExpParser:_getNodeOf(tok)
         local node

         --(1) create node
  1890   if tok.type == TokenType.NAME then
   758     node = Terminal.new(TerminalType.NAME, tok)
  1132   elseif tok.type == TokenType.LITERAL then
   576     if type(tok.value) == "string" then
    37       node = Terminal.new(TerminalType.TEXT, tok)
   539     elseif type(tok.value) == "number" then
   539       node = Terminal.new(TerminalType.NUM, tok)
           end
   556   elseif tok.type == TokenType.KEYWORD then
   148     local kw = tok.value

   148     if kw == "nop" then
     2       node = Terminal.new(TerminalType.NOP, tok)
   146     elseif kw == "false" then
     3       node = Terminal.new(TerminalType.FALSE, tok)
   143     elseif kw == "nil" then
     2       node = Terminal.new(TerminalType.NIL, tok)
   141     elseif kw == "self" then
     2       node = Terminal.new(TerminalType.SELF, tok)
   139     elseif kw == "super" then
     3       node = Terminal.new(TerminalType.SUPER, tok)
   136     elseif kw == "true" then
    27       node = Terminal.new(TerminalType.TRUE, tok)
   109     elseif tablex.find({"and", "in", "is", "like", "or"}, kw) then
    10       node = BinOp.new(tok)
           end
   408   elseif tok.type == TokenType.SYMBOL then
   408     local sym = tok.value

   408     if tablex.find({"!", "~", "..."}, sym) then
     5       node = UnaryOp.new(tok)
   806     elseif tablex.find({
   403                           "+=", "-=", "*", "*=", "**", "**=", "/", "/=", "%", "%=",
   403                           "=", ".=", ":=", "?=", "==", "===", "=~", "!=", "!==", "!~",
   403                           "<", "<<", "<<<", "<<=", "<=", ">", ">>", ">>>", ">>=", ">=",
   403                           "^", "^=", ".", "?", ":", "&", "&=", "&&", "|", "|=", "||"
   806                        }, sym) then
   154       node = BinOp.new(tok)
           end
         end

         --(2) return
  1890   return node
       end

       --Read (expr).
       --
       --@return Exp
     1 function ExpParser:_readSubExp()
    13   local lex = self._.lexer
         local term, tok, ln, col

         --(1) read
    13   tok = lex:next(TokenType.SYMBOL, "(")
    13   ln, col = tok.line, tok.col
    13   term = SubExp.new(ln, col, self:_readExp())
    12   lex:next(TokenType.SYMBOL, ")")

         --(2) return
    10   return term
       end

       --Read if then else end.
       --
       --@return IfSubExp
     1 function ExpParser:_readIfSubExp()
     7   local lex = self._.lexer
         local tok, ln, col, cond, tcase, fcase

         --(1) read
     7   tok = lex:next(TokenType.KEYWORD, "if")
     7   ln, col = tok.line, tok.col
     7   cond = self:_readExp()
     7   lex:next(TokenType.KEYWORD, "then")
     6   tcase = self:_readExp()

     6   tok = lex:advance()
     6   if tok.type == TokenType.KEYWORD and tok.value == "else" then
     4     lex:next(TokenType.KEYWORD, "else")
     4     fcase = self:_readExp()
         end

     6   lex:next(TokenType.KEYWORD, "end")

         --(2) return
     5   return IfSubExp.new(ln, col, cond, tcase, fcase)
       end

       --Read an iif() terminal.
       --
       --@return IifFn
     1 function ExpParser:_readIif()
     4   local lex = self._.lexer
         local tok, ln, col, cond, onTrue, onFalse

         --(1) read
     4   tok = lex:next(TokenType.KEYWORD, "iif")
     4   ln, col = tok.line, tok.col
     4   lex:next(TokenType.SYMBOL, "(")
     4   cond = self:_readExp()
     4   lex:next(TokenType.SYMBOL, ",")
     4   onTrue = self:_readExp()
     4   tok = lex:advance()
     4   if tok.type == TokenType.SYMBOL and tok.value == "," then
     2     lex:next(TokenType.SYMBOL, ",")
     2     onFalse = self:_readExp()
         end
     4   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     4   return IifFn.new(ln, col, cond, onTrue, onFalse)
       end

       --Read a native(code) terminal.
       --
       --@return NativeFn
     1 function ExpParser:_readNative()
     3   local lex = self._.lexer
         local tok, ln, col, code

         --(1) read
     3   tok = lex:next(TokenType.KEYWORD, "native")
     3   ln, col = tok.line, tok.col
     3   lex:next(TokenType.SYMBOL, "(")
     3   code = lex:next(TokenType.LITERAL).value
     2   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return NativeFn.new(ln, col, code)
       end

       --Read an await(Exp) terminal.
       --
       --@return AwaitFn
     1 function ExpParser:_readAwait()
     2   local lex = self._.lexer
         local tok, ln, col, exp

         --(1) read
     2   tok = lex:next(TokenType.KEYWORD, "await")
     2   ln, col = tok.line, tok.col
     2   lex:next(TokenType.SYMBOL, "(")
     2   exp = self:_readExp()
     2   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return AwaitFn.new(ln, col, exp)
       end

       --Read a pawait(Exp) terminal.
       --
       --@return PawaitFn
     1 function ExpParser:_readPawait()
     2   local lex = self._.lexer
         local tok, ln, col, exp

         --(1) read
     2   tok = lex:next(TokenType.KEYWORD, "pawait")
     2   ln, col = tok.line, tok.col
     2   lex:next(TokenType.SYMBOL, "(")
     2   self:_nextEols()
     2   exp = self:_readExp()
     2   self:_nextEols()
     2   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return PawaitFn.new(ln, col, exp)
       end

       --Read a use(Exp) terminal.
       --
       --@return UseFn
     1 function ExpParser:_readUse()
     2   local lex = self._.lexer
         local tok, ln, col, exp

         --(1) read
     2   tok = lex:next(TokenType.KEYWORD, "use")
     2   ln, col = tok.line, tok.col
     2   lex:next(TokenType.SYMBOL, "(")
     2   exp = self:_readExp()
     2   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return UseFn.new(ln, col, exp)
       end

       --Read a peval(Exp) terminal.
       --
       --@return PevalFn
     1 function ExpParser:_readPeval()
     4   local lex = self._.lexer
         local tok, ln, col, exp

         --(1) read
     4   tok = lex:next(TokenType.KEYWORD, "peval")
     4   ln, col = tok.line, tok.col
     4   lex:next(TokenType.SYMBOL, "(")
     4   exp = self:_readExp()
     3   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return PevalFn.new(ln, col, exp)
       end

       --Read a throw(Exp [, Exp]) terminal.
       --
       --@return ThrowFn
     1 function ExpParser:_readThrow()
     6   local lex = self._.lexer
         local tok, ln, col, args

         --(1) read
     6   tok = lex:next(TokenType.KEYWORD, "throw")
     6   ln, col = tok.line, tok.col
     6   lex:next(TokenType.SYMBOL, "(")

     6   args = {}
         while true do
    12     table.insert(args, self:_readExp())

    12     tok = lex:advance()
    12     if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
             break
           end

     6     lex:next(TokenType.SYMBOL, ",")
         end

     6   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     6   return ThrowFn.new(ln, col, args)
       end

       --Read a call arguments.
       --
       --@param exp:Exp  Current expression.
     1 function ExpParser:_readCallArgs(exp)
    97   local lex = self._.lexer
         local tok, call

         --(1) pre: read (
    97   tok = lex:next(TokenType.SYMBOL, "(")
    97   tok.value = "()"

         --(2) create operator
    97   call = CallOp.new(tok)
    97   exp:insert(call)

         --(3) read arguments
    97   tok = lex:advance()

    97   if tok.type == TokenType.SYMBOL and tok.value == ")" then
    14     lex:next()
    14     call.finished = true
         else
    83     local sep = ","

    83     if tok.type == TokenType.EOL then
     5       lex:next()
     5       sep = "\n"
           end

           while true do
    90       call:insert(self:_readExp())

    90       tok = lex:next()

    90       if tok.type == TokenType.SYMBOL and tok.value == ")" then
    79         call.finished = true
               break
             end

    11       if sep == "," then
     6         if tok.type ~= TokenType.SYMBOL and tok.value ~= "," then
     2           error(string.format(
     1             "on (%s, %s), comma expected for argument end or ) for call end.",
     1             tok.line,
                   tok.col
     1           ))
               end
     5       elseif sep == "\n" then
     5         if tok.type ~= TokenType.EOL then
     2           error(string.format(
     1             "on (%s, %s), end of line expected for argument end.",
     1             tok.line,
                   tok.col
     1           ))
               end

     4         tok = lex:advance()

     4         if tok.type == TokenType.SYMBOL and tok.value == ")" then
     2           lex:next()
     2           call.finished = true
                 break
               end
             end
           end
         end
       end

       --Read a literal list: [...].
       --
       --@return LiteralList
     1 function ExpParser:_readLiteralList()
    13   local lex = self._.lexer
         local tok, ln, col, items

         --(1) read [
    13   tok = lex:next(TokenType.SYMBOL, "[")
    13   ln, col = tok.line, tok.col

         --(2) read items]
    13   items = {}

    13   tok = lex:advance()
    13   if not (tok.type == TokenType.SYMBOL and tok.value == ']') then
           local sep

    10     if tok.type == TokenType.EOL then
     4       lex:next()
     4       sep = "\n"
           else
     6       sep = ","
           end

           while true do
             --skip ends of line
    22       if sep == "\n" then
    10         self:_nextEols()

    10         tok = lex:advance()
    10         if tok.type == TokenType.SYMBOL and tok.value == "]" then
                 break
               end
             end

    18       table.insert(items, self:_readExp())

    18       if sep == "," then
    12         tok = lex:advance()

    12         if tok.type == TokenType.SYMBOL and tok.value == "," then
     6           lex:next()
               else
                 break
               end
             end
           end
         end

    13   lex:next(TokenType.SYMBOL, "]")

         --(4) return
    13   return LiteralList.new(ln, col, items)
       end

       --Read a literal map: {...}.
       --
       --@return LiteralMap
     1 function ExpParser:_readLiteralMap()
    16   local lex = self._.lexer
         local tok, ln, col, entries

         --(1) read {
    16   tok = lex:next(TokenType.SYMBOL, "{")
    16   ln, col = tok.line, tok.col

         --(2) read entries}
    16   entries = {}

    16   tok = lex:advance()
    16   if not (tok.type == TokenType.SYMBOL and tok.value == '}') then
           local sep

    13     if tok.type == TokenType.EOL then
     5       lex:next()
     5       sep = "\n"
           else
     8       sep = ","
           end

           while true do
             local name, val, brackets

             --skip ends of line
    26       if sep == "\n" then
    13         self:_nextEols()

    13         tok = lex:advance()
    13         if tok.type == TokenType.SYMBOL and tok.value == "}" then
                 break
               end
             end

             --read item
    21       tok = lex:advance()

    21       if tok.type == TokenType.SYMBOL and tok.value == "{" then
     3         lex:next(TokenType.SYMBOL, "{")
     3         name = lex:nextId().value
     3         brackets = true
     3         lex:next(TokenType.SYMBOL, "}")
             else
    18         name = lex:nextId().value
    18         brackets = false
             end

    21       tok = lex:advance()
    21       if tok.type == TokenType.SYMBOL and tok.value == "=" then
    19         lex:next(TokenType.SYMBOL, "=")
    19         val = self:_readExp()
    19         if brackets then
     3           local op = BinOp.new({line = tok.line, col = tok.col, value = "."})
     3           val:insert(op)
     3           op:insert(Terminal.new(TerminalType.NAME, {line = tok.line, col = tok.col, value = name}))
               end
             else
     2         val = Exp.new(tok.line, tok.col)
     2         val:insert(Terminal.new(TerminalType.NAME, {line = tok.line, col = tok.col, value = name}))
             end

    21       table.insert(entries, {name = name, value = val})

             --read sep
    21       if sep == "," then
    13         tok = lex:advance()

    13         if tok.type == TokenType.SYMBOL and tok.value == "," then
     5           lex:next()
               else
                 break
               end
             end
           end
         end

    16   lex:next(TokenType.SYMBOL, "}")

         --(4) return
    16   return LiteralMap.new(ln, col, entries)
       end

       --Read a fn.
       --
       --@return LiteralFn
     1 function ExpParser:_readFn()
    13   local lex, stmt = self._.lexer, self._.stmtParser
         local tok, ln, col, params, rtype, rvar, body

         --(1) read
    13   tok = lex:next(TokenType.KEYWORD, "fn")
    13   ln, col = tok.line, tok.col

    13   tok = lex:advance()
    13   if tok.type == TokenType.SYMBOL and tok.value == "{" then
     2     lex:nextSymbol("{")
     2     params = Params.new()

     2     tok = lex:advance()
     2     if tok.type == TokenType.SYMBOL and tok.value == "}" then
     1       body = {}
           else
     1       body = {self:_readExp()}
           end
           
     2     lex:nextSymbol("}")
         else
    11     params = stmt:_readFnParams()
    11     rvar = stmt:_readFnReturnVar()
    11     rtype = stmt:_readFnType()

    11     tok = lex:advance()
    11     if tok.type == TokenType.SYMBOL and tok.value == "=" then
     2       lex:next()
     2       body = self:_readExp()
     2       body = {ReturnStmt.new(body.ln, body.col, body)}
     2       lex:next(TokenType.KEYWORD, "end")
           else
     9       body = stmt:_readBody(3)
           end
         end

         --(2) return
    13   return LiteralFn.new(ln, col, params, rtype, rvar, body)
       end

       --Read an indexing operator.
       --
       --@param exp:Exp  Expression to update.
     1 function ExpParser:_readIndexOp(exp)
    15   local lex = self._.lexer
         local tok, ln, col, init, fin

         --(1) read [Exp
    15   tok = lex:next(TokenType.SYMBOL, "[")
    15   ln, col = tok.line, tok.col
    15   init = self:next()

         --(2) read "", Exp" if existing
    15   tok = lex:advance()

    15   if tok.type == TokenType.SYMBOL and tok.value == "," then
     5     lex:next()
     5     fin = self:next()
         end

         --(3) read ]
    15   lex:next(TokenType.SYMBOL, "]")

         --(4) add
         local op

    15   if fin == nil then
    10     op = BinOp.new({line = ln, col = col, value = "[]"})
    10     exp:insert(op)
    10     op:insert(init.tree.root)
         else
     5     op = SliceOp.new({line = ln, col = col, value = "[]"})
     5     exp:insert(op)
     5     op:insert(init.tree.root)
     5     op:insert(fin.tree.root)
         end
       end

       --Read the next {name,name...} op.
       --
       --@param exp:Exp  Expression to update.
     1 function ExpParser:_readPackOp(exp)
    18   local lex = self._.lexer
         local tok, op

         --(1) read {
    18   tok = lex:next(TokenType.SYMBOL, "{")

         --(2) create op
    18   tok.value = "{}"
    18   op = PackOp.new(tok)
    18   exp:insert(op)

         --(3) read fields
    18   tok = lex:advance()
    18   if not (tok.type == TokenType.SYMBOL and tok.value == "}") then
    16     local all = false

           while true do
             local visib, name, value

             --read
    31       tok = lex:advance()

    31       if tok.type == TokenType.SYMBOL and tok.value == "*" then
     7         if #op.children > 1 then
     1           error(string.format("on (%s,%s), '*' only allowed as first item.", tok.line, tok.col))
               end

     6         lex:next()
     6         visib = "."
     6         name = "*"
     6         all = true
    24       elseif tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
     6         lex:next()
     6         visib = tok.value
     6         name = ""
             else
    18         visib = "."
    18         name = ""
             end

    30       value = nil

    30       if name ~= "*" then
    24         name = lex:nextId().value

    24         if all then
     6           lex:next(TokenType.SYMBOL, "=")
     5           value = self:_readExp()
               else
    18           tok = lex:advance()

    18           if tok.type == TokenType.SYMBOL and tok.value == "=" then
     4             lex:next()
     4             value = self:_readExp()
                 end
               end
             end

    29       table.insert(op.children, {visib = visib, name = name, value = value})

             --end?
    29       tok = lex:advance()

    29       if tok.type == TokenType.SYMBOL and tok.value == "}" then
               break
             end

    15       lex:next(TokenType.SYMBOL, ",")
           end
         end

         --(4) read }
    16   lex:next(TokenType.SYMBOL, "}")
    16   op.finished = true
       end

       --Read an update op: Exp.{} or Exp:{}.
     1 function ExpParser:_readUpdateOp(exp)
    21   local lex = self._.lexer
         local tok, op, sep

         --(1) read .{ or :{
    21   tok = lex:next()

    21   if tok.value == "." then
    16     tok.value = ".{}"
    16     op = UpdateOp.new(tok, ".")
         else
     5     tok.value = ".{}"
     5     op = UpdateOp.new(tok, ":")
         end

    21   lex:nextSymbol("{")

         --(2) insert op in exp
    21   exp:insert(op)

         --(3) read separator
    21   tok = lex:advance()

    21   if tok.type == TokenType.EOL then
     2     lex:next()
     2     sep = "\n"
         else
    19     sep = ","
         end

         --(4) read fields
         while true do
           local name, type, value, assign

           --id, {id...} or (id...)
    28     tok = lex:advance()

    28     if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "(") then
     7       type = (tok.value == "{" and "mapped" or "extended")
     7       lex:next()
     7       name = {}

             while true do
    11         table.insert(name, lex:nextId().value)

    11         tok = lex:advance()
    11         if tok.type == TokenType.SYMBOL and tok.value == "," then
     4           lex:next()
               else
                 break
               end
             end

     7       lex:nextSymbol(type == "mapped" and "}" or ")")
           else
    21       type = nil
    21       name = lex:nextId().value
           end

           --=, :=, .=, ?=
    26     tok = lex:advance()

    26     if tok.type == TokenType.SYMBOL and tablex.find({"=", ":=", ".=", "?="}, tok.value) then
    18       lex:next()
    18       assign = tok.value
    18       value = self:_readExp()
           else
     8       value, assign = nil, nil
           end

           --add field
    26     table.insert(op.children, {name = name, type = type, assign = assign, value = value})

           --end or next?
    26     if sep == "," then
    24       tok = lex:advance()

    24       if tok.type == TokenType.SYMBOL and tok.value == "," then
     6         lex:next()
    18       elseif tok.type == TokenType.SYMBOL and tok.value == "}" then
               break
             else
     1         error(string.format("on (%s,%s), ',' or '}' expected.", tok.line, tok.col))
             end
           else
     2       self:_nextEols()
     2       tok = lex:advance()
     2       if tok.type == TokenType.SYMBOL and tok.value == "}" then
               break
             end
           end
         end

         --(5) read }
    18   lex:nextSymbol("}")
    18   op.finished = true
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/NodeType.lua
==============================================================================
     1 return {
     1   TERMINAL = "terminal",
     1   NON_TERMINAL = "non-terminal"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/NonTerminalType.lua
==============================================================================
     1 return {
     1   OP = 1,
     1   TREE = 2
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/Parser.lua
==============================================================================
       --imports
     1 local Lexer = require("dogma.lex.Lexer")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local DirectiveParser = require("dogma.syn.DirectiveParser")
     1 local ExpParser = require("dogma.syn.ExpParser")
     1 local StmtParser = require("dogma.syn.StmtParser")
     1 local UnpackParser = require("dogma.syn.UnpackParser")

       --A parser.
     1 local Parser = {}
     1 Parser.__index = Parser
     1 package.loaded[...] = Parser

       --Constructor.
     1 function Parser.new()
         local self

         --(1) create
   663   self = setmetatable({_ = {}}, Parser)
   663   self._.lexer = Lexer.new()
   663   self._.directiveParser = DirectiveParser.new(self)
   663   self._.expParser = ExpParser.new(self)
   663   self._.stmtParser = StmtParser.new(self)
   663   self._.unpackParser = UnpackParser.new(self)
   663   self._.expParser._.stmtParser = self._.stmtParser

         --(2) return
   663   return self
       end

       --Parse a given text.
       --
       --@param txt:string   Text to parse.
       --@param file?:string File name..
     1 function Parser:parse(txt, file)
   663   self._.lexer:scan(txt, file)
       end

       --Parse the next sentence.
       --
       --@return Sentence
     1 function Parser:next()
  1151   local lex, stmter, direr = self._.lexer, self._.stmtParser, self._.directiveParser
         local sent, tok, annots

         --(1) remove white lines and read annotations
  1151   annots = {}
  1151   tok = lex:advance()
         while true do
  1405     if tok == nil then
             break
  1084     elseif tok.type == TokenType.EOL then
   226       lex:next()
   858     elseif tok.type == TokenType.ANNOTATION then
    28       lex:next()
    28       table.insert(annots, tok.value)
           else
             break
           end

   254     tok = lex:advance()
         end

          --(2) parse next sentence
  1151   tok = lex:advance()

  1151   if tok ~= nil then
   830     if tok.type == TokenType.DIRECTIVE then
    17       if tok.value:find("^if") then
    14         sent = direr:nextIf()
     3       elseif tok.value:find("^/") then
     3         sent = direr:nextRunWith()
             end
   813     elseif tok.type == TokenType.KEYWORD then
   381       if tok.value == "async" then
    12         local aux = lex:advance(2)

    12         if aux.type == TokenType.KEYWORD and aux.value == "fn" then
     4           sent = stmter:nextFn(annots)
               else
     8           sent = stmter:nextAsync()
               end
   369       elseif tok.value == "break" then
     3         sent = stmter:nextBreak()
   366       elseif tok.value == "const" then
    18         sent = stmter:nextConst()
   348       elseif tok.value == "do" then
    11         sent = stmter:nextDo()
   337       elseif tok.value == "enum" then
    22         sent = stmter:nextEnum(annots)
   315       elseif tok.value == "export" or tok.value == "pub" or tok.value == "pvt" then
    40         local toParse = tok.value

    40         tok = lex:advance(2)

    40         if tok.type == TokenType.KEYWORD then
    27           if tok.value == "const" then
     4             sent = stmter:nextConst()
    23           elseif tok.value == "enum" then
     7             sent = stmter:nextEnum(annots)
    16           elseif tok.value == "fn" or tok.value == "async" then
     5             sent = stmter:nextFn(annots)
    11           elseif tok.value == "type" then
     3             sent = stmter:nextType(annots)
     8           elseif tok.value == "var" then
     8             sent = stmter:nextVar()
                 end
               end

    40         if not sent then
    13           if toParse == "pub" then
    10             sent = stmter:nextPub()
     3           elseif toParse == "export" then
     3             sent = stmter:nextExport()
                 end
               end
   275       elseif tok.value == "fn" or tok.value == "async" then
    93         sent = stmter:nextFn(annots)
   182       elseif tok.value == "for" then
    22         tok = lex:advance(2)

    22         if tok.type == TokenType.KEYWORD and tok.value == "each" then
    10           sent = stmter:nextForEach()
               else
    12           sent = stmter:nextFor()
               end
   160       elseif tok.value == "from" then
     8         sent = stmter:nextFrom()
   152       elseif tok.value == "if" then
    21         sent = stmter:nextIf()
   131       elseif tok.value == "next" then
     3         sent = stmter:nextNext()
   128       elseif tok.value == "return" then
    11         sent = stmter:nextReturn()
   117       elseif tok.value == "type" then
    12         sent = stmter:nextType(annots)
   105       elseif tok.value == "use" then
    21         tok = lex:advance(2)

    21         if not (tok.type == TokenType.SYMBOL and tok.value == "(") then
    20           sent = stmter:nextUse()
               end
    84       elseif tok.value == "var" then
    21         sent = stmter:nextVar()
    63       elseif tok.value == "while" then
    18         sent = stmter:nextWhile()
    45       elseif tok.value == "with" then
     8         sent = stmter:nextWith()
    37       elseif tok.value == "yield" then
     7         sent = stmter:nextYield()
             end
           end

   806     if not sent and tok.type == TokenType.SYMBOL and (tok.value == "[" or tok.value == "{") then
    27       sent = self._.unpackParser:next()
           end

   802     if not sent then
   436       sent = self:nextExp()
           end
         end

         --(3) return
  1111   return sent
       end

       --Read the next expression.
       --
       --@return Exp
     1 function Parser:nextExp()
   626   return self._.expParser:next()
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/SentType.lua
==============================================================================
     1 return {
     1   EXP = "exp",
     1   STMT = "stmt",
     1   UNPACK = "unpack",
     1   DIRECTIVE = "directive"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SentType = require("dogma.syn.SentType")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local BlockParser = require("dogma.syn._.BlockParser")
     1 local BreakStmt = require("dogma.syn._.BreakStmt")
     1 local EnumStmt = require("dogma.syn._.EnumStmt")
     1 local NextStmt = require("dogma.syn._.NextStmt")
     1 local ReturnStmt = require("dogma.syn._.ReturnStmt")
     1 local UseStmt = require("dogma.syn._.UseStmt")
     1 local FromStmt = require("dogma.syn._.FromStmt")
     1 local WhileStmt = require("dogma.syn._.WhileStmt")
     1 local DoStmt = require("dogma.syn._.DoStmt")
     1 local ForEachStmt = require("dogma.syn._.ForEachStmt")
     1 local ForStmt = require("dogma.syn._.ForStmt")
     1 local CatchCl = require("dogma.syn._.CatchCl")
     1 local FinallyCl = require("dogma.syn._.FinallyCl")
     1 local FnStmt = require("dogma.syn._.FnStmt")
     1 local TypeStmt = require("dogma.syn._.TypeStmt")
     1 local Param = require("dogma.syn._.Param")
     1 local Params = require("dogma.syn._.Params")
     1 local AsyncStmt = require("dogma.syn._.AsyncStmt")
     1 local IfStmt = require("dogma.syn._.IfStmt")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local NodeType = require("dogma.syn.NodeType")
     1 local PubStmt = require("dogma.syn._.PubStmt")
     1 local ExportStmt = require("dogma.syn._.ExportStmt")
     1 local WithStmt = require("dogma.syn._.WithStmt")
     1 local YieldStmt = require("dogma.syn._.YieldStmt")
     1 local VarStmtParser = require("dogma.syn._.VarStmtParser")

       --Parser for the Dogma statements.
     1 local StmtParser = {}
     1 StmtParser.__index = StmtParser
     1 setmetatable(StmtParser, {__index = SubParser})
     1 package.loaded[...] = StmtParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function StmtParser.new(parser)
         local self

         --(1) create
   663   self = setmetatable(SubParser.new(parser), StmtParser)
   663   self._.expParser = parser._.expParser
   663   self._.varParser = VarStmtParser.new(parser)

         --(2) return
   663   return self
       end

       --Return the next var statement.
       --
       --@return VarStmt
     1 function StmtParser:nextVar()
    29   return self._.varParser:nextVar()
       end

       --Return the next const statement.
       --
       --@return ConstStmt
     1 function StmtParser:nextConst()
    22   return self._.varParser:nextConst()
       end

       --Read a break statement.
       --
       --@return BreakStmt
     1 function StmtParser:nextBreak()
     3   local lexer = self._.lexer
         local tok, stmt

         --(1) read
     3   tok = lexer:next(TokenType.KEYWORD, "break")
     3   stmt = BreakStmt.new(tok.line, tok.col)

         --(2) get end of line
     3   lexer:next(TokenType.EOL)

         --(3) return
     2   return stmt
       end

       --Read a next statement.
       --
       --@return NextStmt
     1 function StmtParser:nextNext()
     3   local lexer = self._.lexer
         local tok, stmt

         --(1) read
     3   tok = lexer:next(TokenType.KEYWORD, "next")
     3   stmt = NextStmt.new(tok.line, tok.col)

         --(2) get end of line
     3   lexer:next(TokenType.EOL)

         --(3) return
     2   return stmt
       end

       --Read a return statement.
       --
       --@return ReturnStmt
     1 function StmtParser:nextReturn()
    11   local lex, exper = self._.lexer, self._.expParser
         local tok, stmt

         --(1) read
    11   tok = lex:next(TokenType.KEYWORD, "return")
    11   stmt = ReturnStmt.new(tok.line, tok.col)

         --(2) get values
    11   tok = lex:advance()

    11   if tok.type ~= TokenType.EOL then
     9     stmt:insert(exper:next())
         end

    11   lex:next(TokenType.EOL)

         --(3) return
    11   return stmt
       end

       --Read a yield statement.
       --
       --@return YieldStmt
     1 function StmtParser:nextYield()
     7   local lex, exper = self._.lexer, self._.expParser
         local tok, ln, col, val

         --(1) read
     7   tok = lex:next(TokenType.KEYWORD, "yield")
     7   ln, col = tok.line, tok.col
     7   val = exper:next()
     7   lex:next(TokenType.EOL)

         --(3) return
     7   return YieldStmt.new(ln, col, val)
       end

       --Read a use stament.
       --
       --@return UseStmt
     1 function StmtParser:nextUse()
    20   local lex = self._.lexer
         local tok, stmt, sep

         --(1) read
    20   tok = lex:next(TokenType.KEYWORD, "use")
    20   stmt = UseStmt.new(tok.line, tok.col)

         --(2) get separator
    20   tok = lex:advance()

    20   if tok.type == TokenType.EOL then
     5     sep = "\n"
     5     lex:next()
         else
    15     sep = ","
         end

         --(3) get variables
         while true do
           local path, name

    31     tok = lex:advance()

    31     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

           --path
    26     tok = lex:next()

    26     if tok.type == TokenType.LITERAL and type(tok.value) == "string" then
    24       path = tok.value

             --as
    24       tok = lex:advance()

    24       if tok.type == TokenType.KEYWORD and tok.value == "as" then
     9         lex:next()  --as
     9         name = lex:next(TokenType.NAME).value
             end
     2     elseif tok.type == TokenType.NAME then
     1       path = "./" .. tok.value
     1       name = tok.value
           else
     1       error(string.format("on (%s,%s), literal string or name expected.", tok.line, tok.col))
           end

           --insert
    25     stmt:insert(path, name)

           --read separator
    24     if sep == "\n" then
     6       lex:next(TokenType.EOL)
           else  --using comma as separator
    18       tok = lex:next()

    18       if tok.type == TokenType.EOL then
               break
             end

     6       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating modules.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(4) return
    17   return stmt
       end

       --Read a from statement.
       --
       --@return FromStmt
     1 function StmtParser:nextFrom()
     8   local lex = self._.lexer
         local tok, ln, col, stmt

         --(1) read module
     8   tok = lex:next(TokenType.KEYWORD, "from")
     8   ln, col = tok.line, tok.col
     8   stmt = FromStmt.new(ln, col, lex:next(TokenType.LITERAL).value)

         --(2) items
     8   lex:next(TokenType.KEYWORD, "use")

         while true do
           local name, as

           --(1) item
    12     name = lex:next(TokenType.NAME).value

    12     tok = lex:advance()
    12     if tok.type == TokenType.KEYWORD and tok.value == "as" then
     6       lex:next()  --as
     6       as = lex:next(TokenType.NAME).value
           end

    12     stmt:insert(name, as)

           --(2) end?
    12     tok = lex:advance()
    12     if tok.type == TokenType.EOL then
     8       lex:next()
             break
           else
     4       lex:next(TokenType.SYMBOL, ",")
           end
         end

         --(3) return
     8   return stmt
       end

       --Read a next statement.
       --
       --@return EnumStmt
     1 function StmtParser:nextEnum(annots)
    29   local lexer = self._.lexer
         local tok, ln, col, visib, name, stmt, sep

         --(1) create stmt
    29   tok = lexer:advance()
    29   ln, col = tok.line, tok.col

         --visibility
    29   if tok.type == TokenType.KEYWORD then
    29     if tok.value == "export" or tok.value == "pub" then
     7       lexer:next()
     7       visib = tok.value
           end
         end

         --enum Name
    29   lexer:next(TokenType.KEYWORD, "enum")
    29   name = lexer:next(TokenType.NAME).value

         --create
    28   stmt = EnumStmt.new(ln, col, annots, visib, name)

         --(2) read items
    28   tok = lexer:next()

    28   if tok.type == TokenType.SYMBOL and tok.value == "{" then
    11     sep = ","
    17   elseif tok.type == TokenType.EOL then
    16     sep = "\n"
         else
     1     error(string.format("invalid token on (%s, %s).", tok.line, tok.col))
         end

         while true do
           local item, value

    57     tok = lexer:advance()

    57     if tok == nil then
             break
           end

    43     if sep == "\n" and tok.col <= stmt.col then
             break
           end

           --name
    41     item = lexer:next(TokenType.NAME).value

           --value
    40     tok = lexer:advance()

    40     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    21       lexer:next()  --=
    21       value = lexer:next(TokenType.LITERAL).value
           else
    19       value = nil
           end

           --insert
    40     stmt:insert(item, value)

           --separator
    40     if sep == "," then
    21       tok = lexer:advance()

    21       if tok.type == TokenType.SYMBOL and tok.value == "}" then
    10         lexer:next()
               break
             else
    11         lexer:next(TokenType.SYMBOL, ",")
             end
           else
    19       lexer:next(TokenType.EOL)
           end
         end

         --(3) return
    26   return stmt
       end

       --Read a while statement.
       --
       --@return WhileStmt
     1 function StmtParser:nextWhile()
    18   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, btype, cond, iter, body, catch, fin

         --(1) read while keyword
    18   tok = lex:next(TokenType.KEYWORD, "while")
    18   ln, col = tok.line, tok.col

         --(2) read condition and iter
         --condition
    18   cond = parser:nextExp()

         --iter
    18   tok = lex:advance()

    18   if tok.type == TokenType.SYMBOL and tok.value == ";" then
     3     lex:next()
     3     iter = parser:nextExp()
         end

         --do
    18   lex:next(TokenType.KEYWORD, "do")

    18   tok = lex:advance()
    18   if tok.type == TokenType.EOL then
    13     lex:next()
    13     btype = 2
         else
     5     btype = 1
         end

         --(4) read rest
    18   body = self:_readBody(btype, col)
    18   catch = self:_readCatch(col)
    18   fin = self:_readFinally(col)

         --(5) return
    18   return WhileStmt.new(ln, col, cond, iter, body, catch, fin)
       end

       --Read a do statement.
       --
       --@return Dotmt
     1 function StmtParser:nextDo()
    11   local lexer, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, catch, fin

         --(1) read while keyword
    11   tok = lexer:next(TokenType.KEYWORD, "do")
    11   ln, col = tok.line, tok.col

    11   lexer:next(TokenType.DO)

         --(2) read body
    11   body = self:_readBody(2, col)

         --(3) read condition if existing
    11   tok = lexer:advance()

    11   if tok and tok.type == TokenType.KEYWORD and tok.value == "while" then
     4     lexer:next()
     4     cond = parser:nextExp()
     4     lexer:next(TokenType.EOL)
         end

         --(4) read rest
    11   catch = self:_readCatch(col)
    11   fin = self:_readFinally(col)

         --(5) return
    11   return DoStmt.new(ln, col, body, cond, catch, fin)
       end

       --Read for statement.
       --
       --@return ForStmt
     1 function StmtParser:nextFor()
    12   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, def, cond, iter, btype, body, catch, fin

         --(1) read for keyword
    12   tok = lex:next(TokenType.KEYWORD, "for")
    12   ln, col = tok.line, tok.col

         --(2) variables
    12   def = {}

         while true do
           local name, val

           --name [= value]
    17     name = lex:next(TokenType.NAME).value

    17     tok = lex:advance()
    17     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    10       lex:next()
    10       val = parser:nextExp()
           else
     7       val = nil
           end

    17     table.insert(def, {name = name, value = val})

           --end?
    17     tok = lex:advance()

    17     if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
             break
           end

     5     lex:next(TokenType.SYMBOL, ",")
         end

    12   lex:next(TokenType.SYMBOL, ";")

         --(3) cond
    12   cond = parser:nextExp()

         --(4) iter
    12   tok = lex:advance()
    12   if tok.type == TokenType.SYMBOL and tok.value == ";" then
     4     lex:next()
     4     iter = parser:nextExp()
         end

         --(5) rest
    12   lex:next(TokenType.KEYWORD, "do")

    12   tok = lex:advance()
    12   if tok.type == TokenType.EOL then
     1     lex:next()
     1     btype = 2
         else
    11     btype = 1
         end

    12   body = self:_readBody(btype, col)
    12   catch = self:_readCatch(col)
    12   fin = self:_readFinally(col)

         --(5) return
    12   return ForStmt.new(ln, col, def, cond, iter, body, catch, fin)
       end

       --Read for each statement.
       --
       --@return ForEachStmt
     1 function StmtParser:nextForEach()
    10   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, key, val, iter, btype, body, catch, fin

         --(1) read for each keywords
    10   tok = lex:next(TokenType.KEYWORD, "for")
    10   lex:next(TokenType.KEYWORD, "each")
    10   ln, col = tok.line, tok.col

         --key
    10   key = lex:next(TokenType.NAME).value

         --value
    10   tok = lex:advance()

    10   if tok.type == TokenType.SYMBOL and tok.value == "," then
     3     lex:next()
     3     val = lex:next(TokenType.NAME).value
         else
     7     val, key = key, nil
         end

         --(3) read iter
    10   lex:next(TokenType.KEYWORD, "in")
    10   iter = parser:nextExp()

         --(4) read rest
    10   lex:next(TokenType.KEYWORD, "do")

    10   tok = lex:advance()
    10   if tok.type == TokenType.EOL then
     8     lex:next()
     8     btype = 2
         else
     2     btype = 1
         end

    10   body = self:_readBody(btype, col)
    10   catch = self:_readCatch(col)
    10   fin = self:_readFinally(col)

         --(5) return
    10   return ForEachStmt.new(ln, col, key, val, iter, body, catch, fin)
       end

       --Read a body statement as, fo example, while, for, if, etc.
       --
       --@param btype:number Body type: 1, one line; 2, block; 3, between {}.
       --@param col:number   Column line where it starts.
       --
       --@return Sent[]
     1 function StmtParser:_readBody(btype, col)
   194   local parser = self._.parser
         local body

         --(1) read body
   194   if btype == 1 then
    21     body = {parser:next()}
   173   elseif btype == 2 then
   164     body = BlockParser.new(parser, col):next()
     9   elseif btype == 3 then
     9     body = BlockParser.new(parser):next()
         end

         --(2) return
   194   return body
       end

       --Read a catch clause.
       --
       --@param col:number Column number where this must start.
       --@return CatchCl
     1 function StmtParser:_readCatch(col)
   168   local lexer, parser = self._.lexer, self._.parser
         local tok, var, body

         --(1) read catch keyword
   168   tok = lexer:advance()

   168   if tok == nil or not (tok.type == TokenType.KEYWORD and tok.value == "catch" and tok.col == col) then
   149     return
         end

    19   lexer:next()

         --(2) read error variable name
    19   tok = lexer:advance()

    19   if tok.type == TokenType.NAME then
     4     lexer:next()
     4     var = tok.value
         end

    19   lexer:next(TokenType.EOL)

         --(3) read body
    19   body = BlockParser.new(parser, col):next()

         --(4) return
    19   return CatchCl.new(var, body)
       end

       --Read a finally clause.
       --
       --@param col:number Column number where this must start.
       --@return FinallyCl
     1 function StmtParser:_readFinally(col)
   163   local lexer, parser = self._.lexer, self._.parser
         local tok, body

         --(1) read finally keyword
   163   tok = lexer:advance()

   163   if tok == nil or not (tok.type == TokenType.KEYWORD and tok.value == "finally" and tok.col == col) then
   150     return
         end

    13   lexer:next()
    13   lexer:next(TokenType.EOL)

         --(2) read body
    13   body = BlockParser.new(parser, col):next()

         --(4) return
    13   return FinallyCl.new(body)
       end

       --Read a fn statement.
       --
       --@return FnStmt
     1 function StmtParser:nextFn(annots)
   102   local lex = self._.lexer
         local tok, ln, col, visib, async, itype, name, params, rtype, rvar, body, catch, fin

         --(1) read visibility
   102   tok = lex:advance()
   102   ln, col = tok.line, tok.col

   102   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub" or tok.value == "pvt") then
     5     lex:next()
     5     visib = tok.value
         end

         --(2) read async
   102   tok = lex:advance()

   102   if tok.type == TokenType.KEYWORD and tok.value == "async" then
     4     lex:next()
     4     async = true
         else
    98     async = false
         end

         --(3) read fn type.name
   102   lex:next(TokenType.KEYWORD, "fn")
   102   name = lex:next(TokenType.NAME).value

   102   tok = lex:advance()
   102   if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
    27     lex:next()
    27     visib = (tok.value == "." and "pub" or "pvt")
    27     itype = name
    27     name = lex:next(TokenType.NAME).value
         end

         --(3) read parameters, return type and return variable
   102   params = self:_readFnParams()

    99   if not async then
    95     rvar = self:_readFnReturnVar()
    94     rtype = self:_readFnType()
         end

         --(4) read body
    97   tok = lex:advance()

    97   if tok.type == TokenType.SYMBOL and tok.value == "=" then
    16     lex:next()
    16     body = {self._.expParser:_readExp()}

    16     if #body > 0 and body[1].type == SentType.EXP then
    16       local exp = body[1]

    16       body[1] = ReturnStmt.new(exp.line, exp.col)
    16       body[1]:insert(exp)
           end
         else
    81     lex:next(TokenType.EOL)
    81     body = self:_readBody(2, col)
         end

         --(5) read rest
    97   catch = self:_readCatch(col)
    97   fin = self:_readFinally(col)

         --(6) return
    97   return FnStmt.new(ln, col, annots, visib, async, itype, name, params, rtype, rvar, body, catch, fin)
       end

       --Read the function parameters.
       --
       --@return Param[]
     1 function StmtParser:_readFnParams()
   128   local lex = self._.lexer
   128   local params = Params.new()
         local tok

         --(1) read (
   128   lex:next(TokenType.SYMBOL, "(")

         --(2) read params
   128   tok = lex:advance()

   128   if not (tok.type == TokenType.SYMBOL and tok.value == ")") then
           while true do
             local const, mod, name, opt, dtype, val

             --const
    97       tok = lex:advance()

    97       if tok.type == TokenType.KEYWORD and tok.value == "const" then
     3         lex:next()
     3         const = true
             else
    94         const = false
             end

             --. or : or ...
    97       tok = lex:advance()

    97       if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":" or tok.value == "...") then
    15         lex:next()
    15         mod = tok.value
             end

             --name
    97       name = lex:next(TokenType.NAME).value

             --optional?
    97       tok = lex:advance()

    97       if tok.type == TokenType.SYMBOL and tok.value == "?" then
    29         lex:next()
    29         opt = true
             end

             --type
    97       tok = lex:advance()

    97       if tok.type == TokenType.SYMBOL and tok.value == ":" then
    25         dtype = self:_readFnParamType()
             else
    72         dtype = nil
             end

             --default value
    97       if not opt then
    68         tok = lex:advance()

    68         if tok.type == TokenType.SYMBOL and tok.value == "=" then
     3           opt = true
     3           val = self:_readFnParamValue()
    65         elseif tok.type == TokenType.SYMBOL and tok.value == ":=" then
     7           opt = true
     7           val, dtype = self:_readFnParamValueWithInference()
               end
             end

             --insert param
    96       params:insert(Param.new(const, mod, name, opt, dtype, val))

             --,
    96       tok = lex:advance()

    96       if tok.type == TokenType.SYMBOL and tok.value == "," then
    23         lex:next()
             else
               break
             end
           end
         end

         --(3) read close
   127   lex:next(TokenType.SYMBOL, ")")

         --(4) return
   125   return params
       end

       --Read the parameter type.
       --
       --@return string
     1 function StmtParser:_readFnParamType()
    25   local lex = self._.lexer
         local tok, dtype

         --(1) read
    25   lex:next(TokenType.SYMBOL, ":")

    25   tok = lex:advance()
    25   if tok.type == TokenType.SYMBOL and tok.value == "(" then
     7     lex:nextSymbol("(")

     7     dtype = {}
           while true do
    11       table.insert(dtype, lex:nextName().value)

    11       tok = lex:advance()
    11       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
               break
             end

     4       lex:nextSymbol(",")
           end

     7     lex:nextSymbol(")")
    18   elseif not (tok.type == TokenType.SYMBOL and tok.value == "{") then
     8     dtype = lex:next(TokenType.NAME).value
         else
    10     lex:next()

    10     dtype = {}

    10     tok = lex:advance()
    10     if tok.type == TokenType.SYMBOL and tok.value == "}" then
     2       lex:next()
           else
             while true do
               --read field
               local pname, ptype, pman, readType

               --name
    14         pname = lex:next(TokenType.NAME).value

               --?:
    14         tok = lex:advance()

    14         if tok.type == TokenType.SYMBOL and tok.value == "?" then
     4           lex:nextSymbol("?")
     4           pman = false
     4           readType = true
               else
    10           pman = true
    10           tok = lex:advance()
    10           readType = (tok.type == TokenType.SYMBOL and tok.value == ":")
               end

               --type
    14         if readType then
    10           lex:nextSymbol(":")
    10           tok = lex:advance()
    10           if tok.type == TokenType.SYMBOL and tok.value == "(" then
     3             ptype = {}
     3             lex:nextSymbol("(")
                   while true do
     5               table.insert(ptype, lex:nextName().value)
     5               tok = lex:advance()
     5               if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
                       break
                     end
     2               lex:nextSymbol(",")
                   end
     3             lex:nextSymbol(")")
                 else
     7             ptype = lex:nextName().value
                 end
               else
     4           ptype = "any"
               end

    14         table.insert(dtype, {name = pname, type = ptype, mandatory = pman})

               --read next or end
    14         tok = lex:advance()
    14         if tok.type == TokenType.SYMBOL and tok.value == "}" then
     8           lex:next()
                 break
               end

     6         lex:next(TokenType.SYMBOL, ",")
             end --while
           end
         end

         --(2) return
    25   return dtype
       end

       --Read the parameter value wihtout inference.
       --
       --@return string
     1 function StmtParser:_readFnParamValue()
     3   self._.lexer:next(TokenType.SYMBOL, "=")
     3   return self._.parser:nextExp()
       end

       --Read the parameter value using inference.
       --
       --@return val, type
     1 function StmtParser:_readFnParamValueWithInference()
     7   local lex, exper = self._.lexer, self._.expParser
         local val, dtype

         --(1) read
     7   lex:nextSymbol(":=")
     7   val = exper:_readExp()

         --(2) infer data type
     7   local node = val.tree.root

     7   if node.type == NodeType.TERMINAL then
     7     if node.subtype == TerminalType.TEXT then
     1       dtype = "text"
     6     elseif node.subtype == TerminalType.NUM then
     1       dtype = "num"
     5     elseif node.subtype == TerminalType.TRUE or node.subtype == TerminalType.FALSE then
     2       dtype = "bool"
     3     elseif node.subtype == TerminalType.MAP then
     1       dtype = "map"
     2     elseif node.subtype == TerminalType.LIST then
     1       dtype = "list"
           end
         end

     7   if not dtype then
     2     error(string.format(
     1       "on (%s, %s), for infering type, the default value must be a literal: bool, list, map, num or text.",
     1       val.line, val.col
     1     ))
         end

         --(2) return
     6   return val, dtype
       end

       --Read the function return type.
       --
       --@return string
     1 function StmtParser:_readFnType()
   105   local lex = self._.lexer
         local tok, rtype

         --(1) read
   105   tok = lex:advance()

   105   if tok.type == TokenType.SYMBOL and tok.value == ":" then
     8     lex:next()  --:
     8     rtype = lex:next(TokenType.NAME).value
         end

         --(2) return
   104   return rtype
       end

       --Read the function return variable.
       --
       --@return string
     1 function StmtParser:_readFnReturnVar()
   106   local lex = self._.lexer
         local tok, rvar

         --(1) read
   106   tok = lex:advance()

   106   if tok.type == TokenType.SYMBOL and tok.value == "->" then
    18     lex:next()  -- ->
    18     tok = lex:next()

    18     if tok.type == TokenType.KEYWORD and tok.value == "self" then
     4       rvar = "self"
    14     elseif tok.type == TokenType.NAME then
    13       rvar = tok.value
           else
     2       error(string.format(
     1         "on (%s, %s), return value must be 'self' or a name.",
     1         tok.line,
               tok.col
     1       ))
           end
         end

         --(2) return
   105   return rvar
       end

       --Read a type statement.
       --
       --@return TypeStmt
     1 function StmtParser:nextType(annots)
    15   local lexer, parser = self._.lexer, self._.parser
         local tok, ln, col, visib, name, params, btype, bargs, body, catch, fin

         --(1) read visibility
    15   tok = lexer:advance()
    15   ln, col = tok.line, tok.col

    15   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     3     lexer:next()
     3     visib = tok.value
         end

         --(2) read type name
    15   lexer:next(TokenType.KEYWORD, "type")
    15   name = lexer:next(TokenType.NAME).value

         --(3) read parameters
    15   params = self:_readFnParams()

         --(4) read base type
    15   tok = lexer:advance()

    15   if tok.type == TokenType.SYMBOL and tok.value == ":" then
     5     lexer:next()
     5     btype = lexer:next(TokenType.NAME).value

     5     tok = lexer:advance()
     5     if tok.type == TokenType.SYMBOL and tok.value == "(" then
     3       lexer:next()
     3       bargs = {}

     3       tok = lexer:advance()
     3       if not (tok.type == TokenType.SYMBOL and tok.value == ")") then
               while true do
     4           table.insert(bargs, parser:nextExp())

     4           tok = lexer:advance()
     4           if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
                   break
                 end

     2           lexer:next(TokenType.SYMBOL, ",")
               end
             end

     3       lexer:next(TokenType.SYMBOL, ")")
           end
         end

         --(5) read body
    15   lexer:next(TokenType.EOL)
    15   body = self:_readBody(2, col)

         --(6) read rest
    15   catch = self:_readCatch(col)
    15   fin = self:_readFinally(col)

         --(6) return
    15   return TypeStmt.new(ln, col, annots, visib, name, params, btype, bargs, body, catch, fin)
       end

       --Read an async statement.
       --
       --@return AsyncStmt
     1 function StmtParser:nextAsync()
     8   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, opts, body, catch

         --(1) read async keyword
     8   tok = lex:next(TokenType.KEYWORD, "async")
     8   ln, col = tok.line, tok.col

         --(2) read options
     8   opts = {}
     8   tok = lex:advance()

     8   if tok.type == TokenType.KEYWORD and tok.value == "with" then
     2     lex:next()
     2     lex:next(TokenType.SYMBOL, "{")
     2     lex:next(TokenType.NAME, "delay")
     2     lex:next(TokenType.SYMBOL, "=")
     2     opts.delay = parser:nextExp()
     2     lex:next(TokenType.SYMBOL, "}")
         end

         --(2) read body
     8   tok = lex:advance()

     8   if tok.type == TokenType.EOL then
     5     lex:next()
     5     body = self:_readBody(2, col)
     5     catch = self:_readCatch(col)
         else
     3     body = self:_readBody(1, col)
         end

         --(3) return
     8   return AsyncStmt.new(ln, col, opts, body, catch)
       end

       --Read an if statement.
       --
       --@return IfStmt
     1 function StmtParser:nextIf()
    21   local lex, parser = self._.lexer, self._.parser
         local tok, ln, decl, val, col, cond, body, elif, el

         --(1) read if keyword
    21   tok = lex:next(TokenType.KEYWORD, "if")
    21   ln, col = tok.line, tok.col

         --(2) read 1st exp
    21   tok = lex:advance()

    21   if tok.type == TokenType.KEYWORD and (tok.value == "var" or tok.value == "const") then
     5     decl = tok.value
     5     lex:next()
         end

    21   cond = parser:nextExp()

         --.(3) read 2nd exp
    21   tok = lex:advance()

    21   if decl or (tok.type == TokenType.SYMBOL and tok.value == ";") then
     7     lex:next(TokenType.SYMBOL, ";")
     6     val = cond
     6     cond = parser:nextExp()
         end

         --(4) read body
    20   lex:next(TokenType.KEYWORD, "then")

    20   tok = lex:advance()

    20   if tok.type ~= TokenType.EOL then
    13     body = {parser:next()}

    13     tok = lex:advance()
    13     if tok and tok.type == TokenType.KEYWORD and tok.value == "else" then
     3       lex:next()
     3       el = {parser:next()}
           end
         else
     7     lex:next(TokenType.EOL)
     7     body = self:_readBody(2, col)

           while true do
    17       tok = lex:advance()

    17       if tok == nil or tok.col ~= col then
               break
             end

    10       if tok.type == TokenType.KEYWORD and tok.value == "else" then
    10         tok = lex:advance(2)

    10         if tok.type == TokenType.KEYWORD and tok.value == "if" then
                 local c, b

     7           lex:next()  --else
     7           lex:next()  --if
     7           c = parser:nextExp()
     7           lex:next(TokenType.KEYWORD, "then")
     7           lex:next(TokenType.EOL)
     7           b = self:_readBody(2, col)

     7           if elif == nil then
     5             elif = {}
                 end

     7           table.insert(elif, {cond = c, body = b})
               else
     3           lex:next()  --else
     3           el = self:_readBody(2, col)
               end
             else
               break
             end
           end
         end

         --(5) return
    20   return IfStmt.new(ln, col, decl, val, cond, body, elif, el)
       end

       --Read a pub statement.
       --
       --@return PubStmt
     1 function StmtParser:nextPub()
    10   local lex = self._.lexer
         local tok, ln, col, items, sep

         --(1) read pub keyword
    10   tok = lex:next(TokenType.KEYWORD, "pub")
    10   ln, col = tok.line, tok.col

         --(2) set seperator
    10   tok = lex:advance()

    10   if tok.type == TokenType.EOL then
     2     lex:next()
     2     sep = "\n"
         else
     8     sep = ","
         end

         --(3) read items
    10   items = {}

         while true do
           local item

           --item
    14     tok = lex:advance()

    14     if sep == "\n" and (not tok or tok.col <= col) then
             break
           end

    12     if tok and tok.type == TokenType.LITERAL and type(tok.value) == "string" then
     5       lex:next()
     5       item = {type = "use", value = tok.value}
     7     elseif tok and tok.type == TokenType.NAME then
     6       lex:next()
     6       item = {type = "pub", value = tok.value}
           else
     1       error(string.format("on (%s,%s), literal text or name expected.", tok.line, tok.col))
           end

    11     table.insert(items, item)

           --end or next?
    11     if sep == "\n" then
     2       lex:next(TokenType.EOL)
           else
     9       tok = lex:next()

     9       if tok.type == TokenType.EOL then
               break
             else
     3         if tok.type ~= TokenType.SYMBOL or tok.value ~= "," then
     1           error(string.format("on (%s,%s), comma expected.", tok.line, tok.col))
               end
             end
           end
         end

         --(4) return
     8   return PubStmt.new(ln, col, items)
       end

       --Read an export statement.
       --
       --@return ExportStmt
     1 function StmtParser:nextExport()
     3   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, exp

         --(1) read
     3   tok = lex:next(TokenType.KEYWORD, "export")
     3   ln, col = tok.line, tok.col

     3   exp = parser:nextExp()
     2   lex:next(TokenType.EOL)

         --(2) return
     2   return ExportStmt.new(ln, col, exp)
       end

       --Read a with statement.
       --
       --@return WithStmt
     1 function StmtParser:nextWith()
     8   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, val, ifs, els

         --(1) read with
     8   tok = lex:next(TokenType.KEYWORD, "with")
     8   ln, col = tok.line, tok.col

     8   val = parser:nextExp()
     7   lex:next(TokenType.EOL)

         --(2) read ifs
     7   ifs = {}

         while true do
           local cond, ifCol, body

    17     tok = lex:advance()
    17     if not (tok and tok.type == TokenType.KEYWORD and tok.value == "if" and tok.col > col) then
             break
           end

    10     lex:next()  --if
    10     ifCol = tok.col
    10     cond = parser:nextExp()
    10     lex:next(TokenType.KEYWORD, "then")
    10     body = self:_readBody(2, ifCol)

    10     table.insert(ifs, {cond = cond, body = body})
         end

         --(3) read else
     7   tok = lex:advance()

     7   if tok and tok.type == TokenType.KEYWORD and tok.value == "else" and tok.col > col then
     3     lex:next()
     3     els = self:_readBody(2, tok.col)
         end

         --(4) return
     7   return WithStmt.new(ln, col, val, ifs, els)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtType.lua
==============================================================================
     1 return {
     1   ASYNC = "async",
     1   BREAK = "break",
     1   CONST = "const",
     1   DO = "do",
     1   ENUM = "enum",
     1   EXPORT = "export",
     1   FN = "fn",
     1   FOR = "for",
     1   FOR_EACH = "for each",
     1   FROM = "from",
     1   IF = "if",
     1   NEXT = "next",
     1   PUB = "pub",
     1   RETURN = "return",
     1   TYPE = "type",
     1   USE = "use",
     1   VAR = "var",
     1   WHILE = "while",
     1   WITH = "with",
     1   YIELD = "yield"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/TerminalType.lua
==============================================================================
     1 return {
     1   NAME = 1,
     1   NUM = 2,
     1   TEXT = 3,
     1   TRUE = 4,
     1   FALSE = 5,
     1   NIL = 6,
     1   LIST = 7,
     1   MAP = 8,
     1   SELF = 9,
     1   SUPER = 10,
     1   FN = 11,
     1   SUBEXP = 12,
     1   IF = 13,
     1   PEVAL = 14,
     1   THROW = 15,
     1   NOP = 16,
     1   NATIVE = 17,
     1   AWAIT = 18,
     1   PAWAIT = 19,
     1   USE = 20,
     1   IIF = 21
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/UnpackParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local Unpack = require("dogma.syn._.Unpack")
     1 local DataAccess = require("dogma.syn._.DataAccess")

       --An unpack sentence parser.
     1 local UnpackParser = {}
     1 UnpackParser.__index = UnpackParser
     1 setmetatable(UnpackParser, {__index = SubParser})
     1 package.loaded[...] = UnpackParser

       --Constructor.
       --
       --@param parser:Parser  Parent parser.
     1 function UnpackParser.new(parser)
   663   return setmetatable(SubParser.new(parser), UnpackParser)
       end

       --Parse the next unpack sentence.
       --
       --@return Unpack
     1 function UnpackParser:next()
    27   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, typ, vars, assign, exp

         --(1) read type
    27   tok = lex:next()
    27   ln, col = tok.line, tok.col

    27   if tok.type == TokenType.SYMBOL and tok.value == "[" then
    19     typ = "[]"
         else
     8     typ = "{}"
         end

         --(2) get vars
    27   vars = {}

         while true do
           local mod, name, val

           --visib
    74     tok = lex:advance()

    74     if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
    20       lex:next()
    20       mod = tok.value
    54     elseif tok.type == TokenType.SYMBOL and tok.value == "..." then
     7       if typ == "{}" then
     1         error(string.format("on (%s,%s), '...' only allowed with list unpack.", tok.line, tok.col))
             else
     6         lex:next()
     6         mod = tok.value
             end
           end

           --name, name=val, name{...}
    73     name = lex:nextId().value

    73     tok = lex:advance()
    73     if tok.type == TokenType.SYMBOL and tok.value == "{" then
     4       if typ == "{}" then
     1         error(string.format("on (%s,%s), 'object{}' only allowed with list unpack.", tok.line, tok.col))
             else
     3         lex:next(TokenType.SYMBOL, "{")

               while true do
                 local fmod

     5           tok = lex:advance()
     5           if tok.type == TokenType.SYMBOL and tok.value == ":" then
     1             lex:next()
     1             fmod = ":"
                 else
     4             fmod = "."
                 end

     5           table.insert(vars, DataAccess.new(nil, name .. fmod .. lex:nextId().value))

     5           tok = lex:advance()
     5           if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
                   break
                 end

     2           lex:next(TokenType.SYMBOL, ",")
               end

     3         lex:next(TokenType.SYMBOL, "}")
             end
           else
             while true do
    79         tok = lex:advance()

    79         if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
    10           lex:next()
    10           name = name .. tok.value .. lex:nextId().value
               else
                 break
               end
             end

    69       tok = lex:advance()

    69       if tok.type == TokenType.SYMBOL and tok.value == "=" then
     6         lex:next()
     6         val = parser:nextExp()
             end

    69       table.insert(vars, DataAccess.new(mod, name, val))
           end

           --comma or end
    72     tok = lex:advance()

    72     if typ == "[]" then
    56       if tok.type == TokenType.SYMBOL and tok.value == "]" then
    19         lex:next()
               break
             end
    16     elseif typ == "{}" then
    16       if tok.type == TokenType.SYMBOL and tok.value == "}" then
     6         lex:next()
               break
             end
           end

    47     lex:next(TokenType.SYMBOL, ",")
         end

         --(3) expression
    25   tok = lex:advance()

    25   if typ == "[]" then
    19     if not (tok.type == TokenType.SYMBOL and (tok.value == "=" or tok.value == ".=" or tok.value == ":=" or tok.value == "?=")) then
     1       error(string.format("on (%s,%s), '=', '.=', ':=' or '?=' expected.", tok.line, tok.col))
           end
         else
     6     if not (tok.type == TokenType.SYMBOL and (tok.value == "=" or tok.value == ":=")) then
     1       error(string.format("on (%s,%s), '=' or ':=' expected.", tok.line, tok.col))
           end
         end

    23   lex:next()
    23   assign = tok.value
    23   exp = parser:nextExp()
    23   lex:next(TokenType.EOL)

         --(6) return
    23   return Unpack.new(ln, col, typ, vars, assign, exp)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AsyncStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An async statement.
     1 local AsyncStmt = {}
     1 AsyncStmt.__index = AsyncStmt
     1 setmetatable(AsyncStmt, {__index = Stmt})
     1 package.loaded[...] = AsyncStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param opts:object
       --@param body:Sent[]
       --@param catch:CatchCls
     1 function AsyncStmt.new(ln, col, opts, body, catch)
         local self

         --(1) create
     8   self = setmetatable(Stmt.new(StmtType.ASYNC, ln, col), AsyncStmt)
     8   self.opts = opts
     8   self.body = body
     8   self.catch = catch

         --(2) return
     8   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AwaitFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An await call.
     1 local AwaitFn = {}
     1 AwaitFn.__index = AwaitFn
     1 setmetatable(AwaitFn, {__index = Terminal})
     1 package.loaded[...] = AwaitFn

       --Constructor.
     1 function AwaitFn.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.AWAIT, {line = ln, col = col}), AwaitFn)
     2   self.exp = exp

         --(2) return
     2   return self
       end

       --@override
     1 function AwaitFn:__tostring()
     1   return string.format("(await %s)", tostring(self.exp))
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BinOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A binary operator.
     1 local BinOp = {}
     1 BinOp.__index = BinOp
     1 setmetatable(BinOp, {__index = Op})
     1 package.loaded[...] = BinOp

       --Constructor.
       --
       --@param tok:Token
     1 function BinOp.new(tok)
         local self

         --(1) create
   522   self = setmetatable(Op.new("b", tok), BinOp)
   522   self.children = {}

         --(2) return
   522   return self
       end

       --@override
     1 function BinOp:insert(node)
         -- if #self.children == 2 then
         --   error("children already set.")
         -- end

  1067   table.insert(self.children, node)
  1067   node.parent = self
       end

       --@override
     1 function BinOp:remove(node)
         -- if #self.children == 0 then
         --   error("no child to remove from the operator.")
         -- end

    26   return table.remove(self.children)
       end

       --@override
     1 function BinOp:isWellFormed()
  1096   return #self.children == 2
       end

       --@override
     1 function BinOp:__tostring()
   459   return string.format("(%s %s %s)", self.op, self.children[1], self.children[2])
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BlockParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SubParser = require("dogma.syn._.SubParser")

       --An expression parser.
     1 local BlockParser = {}
     1 BlockParser.__index = BlockParser
     1 setmetatable(BlockParser, {__index = SubParser})
     1 package.loaded[...] = BlockParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
       --@param col:number     Column number.
     1 function BlockParser.new(parser, col)
         local self

   205   self = setmetatable(SubParser.new(parser), BlockParser)
   205   if col == nil then
     9     self._.col = 0
     9     self._.type = "end"
         else
   196     self._.col = col
   196     self._.type = "\n"
         end

   205   return self
       end

       --Parse the next block.
       --
       --@return Sent[]
     1 function BlockParser:next()
   205   local lex, parser, btype = self._.lexer, self._.parser, self._.type
         local tok
   205   local col, block = self._.col, {}

         --(1) see if empty function
   205   if btype == "end" then
     9     tok = lex:advance()

     9     if tok.type == TokenType.KEYWORD and tok.value == "end" then
     7       lex:next()
     7       return block
           end
         end

         --(1) read
         while true do
           local sent

   329     tok = lex:advance()

           --remove white lines
   457     while tok and tok.type == TokenType.EOL do
   128       lex:next()
   128       tok = lex:advance()
           end

   329     if btype == "end" and tok and tok.type == TokenType.KEYWORD and tok.value == "end" then
             break
           end

   327     if tok == nil or tok.col <= col then
             break
           end

           --parse next sentence
   131     sent = parser:next()

   131     if sent then
   131       table.insert(block, sent)
           else
             break
           end
         end

         --(3) read } if needed
   198   if btype == "end" then
     2     lex:next(TokenType.KEYWORD, "end")
         end

         --(3) return
   198   return block
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BreakStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A break statement.
     1 local BreakStmt = {}
     1 BreakStmt.__index = BreakStmt
     1 setmetatable(BreakStmt, {__index = Stmt})
     1 package.loaded[...] = BreakStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function BreakStmt.new(ln, col)
     3   return setmetatable(Stmt.new(StmtType.BREAK, ln, col), BreakStmt)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CallOp.lua
==============================================================================
       --imports
     1 local NaryOp = require("dogma.syn._.NaryOp")

       --A call operator.
     1 local CallOp = {}
     1 CallOp.__index = CallOp
     1 setmetatable(CallOp, {__index = NaryOp})
     1 package.loaded[...] = CallOp

       --Constructor.
       --
       --@param tok:Token
     1 function CallOp.new(tok)
         local self

         --(1) create
    99   self = setmetatable(NaryOp.new(tok), CallOp)
    99   self.children = {}
    99   self.finished = false

         --(2) return
    99   return self
       end

       --@override
     1 function CallOp:__tostring()
         local ops

         --(1) get expressions
    64   ops = ""
   186   for _, op in ipairs(self.children) do
   122     ops = ops .. (ops == "" and "" or " ") .. op:__tostring()
         end

         --(2) return
    64   return string.format("(call %s)", ops)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CatchCl.lua
==============================================================================
       --A catch clause.
     1 local CatchCl = {}
     1 CatchCl.__index = CatchCl
     1 package.loaded[...] = CatchCl

       --Constructor.
       --
       --@param var:string Exception variable name.
       --@param body:Body  Body sentences.
     1 function CatchCl.new(var, body)
    38   return setmetatable({
    19     var = var,
    19     body = body
    38   }, CatchCl)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ConstStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A var statement.
     1 local ConstStmt = {}
     1 ConstStmt.__index = ConstStmt
     1 setmetatable(ConstStmt, {__index = Stmt})
     1 package.loaded[...] = ConstStmt

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param visib:string Visibility: export or pub.
       --@param decls:list   Declarations.
     1 function ConstStmt.new(ln, col, visib, decls)
         local self

         --(1) create
    20   self = setmetatable(Stmt.new(StmtType.CONST, ln, col), ConstStmt)
    20   self.decls = decls
    20   self.visib = visib

         --(2) return
    20   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DataAccess.lua
==============================================================================
       --Data access.
     1 local DataAccess = {}
     1 DataAccess.__index = DataAccess
     1 package.loaded[...] = DataAccess

       --Constructor.
     1 function DataAccess.new(mod, name, value)
    74   return setmetatable({mod = mod, name = name, value = value}, DataAccess)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Directive.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --A directive.
       --@abstract
     1 local Directive = {}
     1 Directive.__index = Directive
     1 setmetatable(Directive, {__index = Sent})
     1 package.loaded[...] = Directive

       --Constructor.
       --
       --@param subtype:DirectiveType  Directive type.
       --@param ln:number              Line number.
       --@param col:number             Column number.
     1 function Directive.new(subtype, ln, col)
         local self

         --(1) create
    14   self = setmetatable(Sent.new(SentType.DIRECTIVE, ln, col), Directive)
    14   self.subtype = subtype

         --(2) return
    14   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DoStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A while statement.
     1 local DoStmt = {}
     1 DoStmt.__index = DoStmt
     1 setmetatable(DoStmt, {__index = Stmt})
     1 package.loaded[...] = DoStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param body:Sent[]
       --@param cond?:Exp
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function DoStmt.new(ln, col, body, cond, catch, fin)
         local self

         --(1) create
    11   self = setmetatable(Stmt.new(StmtType.DO, ln, col), DoStmt)
    11   self.body = body
    11   self.cond = cond
    11   self.catch = catch
    11   self.finally = fin

         --(2) return
    11   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/EnumStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An enum statement.
     1 local EnumStmt = {}
     1 EnumStmt.__index = EnumStmt
     1 setmetatable(EnumStmt, {__index = ObjectStmt})
     1 package.loaded[...] = EnumStmt

       --Constructor.
     1 function EnumStmt.new(ln, col, annots, visib, name)
         local self

         --(1) create
    28   self = setmetatable(ObjectStmt.new(StmtType.ENUM, ln, col, name, visib), EnumStmt)
    28   self.items = {}
    28   self.annots = annots or {}
    28   self._.lastValue = nil

         --(2) return
    28   return self
       end

       --Insert an item.
       --
       --@param item:string    Item name.
       --@param value:any      Item value.
     1 function EnumStmt:insert(item, value)
         --(1) set value if needed
    40   if value == nil then
    19     if self._.lastValue == nil then
    11       self._.lastValue = 1
           else
     8       self._.lastValue = self._.lastValue + 1
           end

    19     value = self._.lastValue
         end

         --(2) insert
    40   table.insert(self.items, {name = item, value = value})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Exp.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")
     1 local SyntaxTree = require("dogma.syn._.SyntaxTree")

       --An expression.
     1 local Exp = {}
     1 Exp.__index = Exp
     1 setmetatable(Exp, {__index = Sent})
     1 package.loaded[...] = Exp

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function Exp.new(ln, col)
         local self

         --(1) create
   954   self = setmetatable(Sent.new(SentType.EXP, ln, col), Exp)
   954   self.tree = SyntaxTree.new()

         --(2) return
   954   return self
       end

       --Add a new node to the expression.
       --
       --@param node:Node  Node to add.
     1 function Exp:insert(node)
  2151   self.tree:insert(node)
       end

       --@override
     1 function Exp:__tostring()
   822   return self.tree:__tostring()
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ExportStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An export statement.
     1 local ExportStmt = {}
     1 ExportStmt.__index = ExportStmt
     1 setmetatable(ExportStmt, {__index = Stmt})
     1 package.loaded[...] = ExportStmt

       --Constructor.
     1 function ExportStmt.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Stmt.new(StmtType.EXPORT, ln, col), ExportStmt)
     2   self.exp = exp

         --(2) return
     2   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FinallyCl.lua
==============================================================================
       ----A finally clause.
     1 local FinallyCl = {}
     1 FinallyCl.__index = FinallyCl
     1 package.loaded[...] = FinallyCl

       --Constructor.
       --
       --@param body:Body  Body sentences.
     1 function FinallyCl.new(body)
    26   return setmetatable({
    13     body = body
    26   }, FinallyCl)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FnStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A fn statement.
     1 local FnStmt = {}
     1 FnStmt.__index = FnStmt
     1 setmetatable(FnStmt, {__index = ObjectStmt})
     1 package.loaded[...] = FnStmt

       --Constructor.
     1 function FnStmt.new(ln, col, annots, visib, async, itype, name, params, rtype, rvar, body, catch, fin)
         local self

         --(1) create
    97   self = setmetatable(ObjectStmt.new(StmtType.FN, ln, col, name, visib), FnStmt)
    97   self.async = async
    97   self.itype = itype
    97   self.params = params
    97   self.rtype = rtype
    97   self.rvar = rvar
    97   self.body = body
    97   self.catch = catch
    97   self.finally = fin
    97   self.annots = annots or {}

         --(2) return
    97   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForEachStmt.lua
==============================================================================
       --Imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A for each statement.
     1 local ForEachStmt = {}
     1 ForEachStmt.__index = ForEachStmt
     1 setmetatable(ForEachStmt, {__index = Stmt})
     1 package.loaded[...] = ForEachStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param key?:string
       --@param value:string
       --@param iter:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function ForEachStmt.new(ln, col, key, val, iter, body, catch, fin)
         local self

         --(1) create
    10   self = setmetatable(Stmt.new(StmtType.FOR_EACH, ln, col), ForEachStmt)
    10   self.key = key
    10   self.value = val
    10   self.iter = iter
    10   self.body = body
    10   self.catch = catch
    10   self.finally = fin

         --(2) return
    10   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForStmt.lua
==============================================================================
       --Imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A for statement.
     1 local ForStmt = {}
     1 ForStmt.__index = ForStmt
     1 setmetatable(ForStmt, {__index = Stmt})
     1 package.loaded[...] = ForStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param def:VarStmt
       --@param cond:Exp
       --@param iter:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function ForStmt.new(ln, col, def, cond, iter, body, catch, fin)
         local self

         --(1) create
    12   self = setmetatable(Stmt.new(StmtType.FOR, ln, col), ForStmt)
    12   self.def = def
    12   self.cond = cond
    12   self.iter = iter
    12   self.body = body
    12   self.catch = catch
    12   self.finally = fin

         --(2) return
    12   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FromStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A from statement.
     1 local FromStmt = {}
     1 FromStmt.__index = FromStmt
     1 setmetatable(FromStmt, {__index = Stmt})
     1 package.loaded[...] = FromStmt

       --Constructor.
     1 function FromStmt.new(ln, col, mod)
         local self

         --(1) create
     8   self = setmetatable(Stmt.new(StmtType.FROM, ln, col), FromStmt)
     8   self.module = mod
     8   self.members = {}

         --(2) return
     8   return self
       end

       --Insert an imported member.
       --
       --@param name:string  Member name to import.
       --@param as?:string   Name to use in the code.
     1 function FromStmt:insert(name, as)
    12   table.insert(self.members, {name = name, as = as or name})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfDirective.lua
==============================================================================
       --imports
     1 local Directive = require("dogma.syn._.Directive")
     1 local DirectiveType = require("dogma.syn.DirectiveType")

       --An if directive.
     1 local IfDirective = {}
     1 IfDirective.__index = IfDirective
     1 setmetatable(IfDirective, {__index = Directive})
     1 package.loaded[...] = IfDirective

       --Constructor.
     1 function IfDirective.new(ln, col, cond, body, el)
         local self

         --(1) create
    11   self = setmetatable(Directive.new(DirectiveType.IF, ln, col), IfDirective)
    11   self.cond = cond
    11   self.body = body
    11   self.el = el

         --(2) return
    11   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfStmt.lua
==============================================================================
       --importsa
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An if statement.
     1 local IfStmt = {}
     1 IfStmt.__index = IfStmt
     1 setmetatable(IfStmt, {__index = Stmt})
     1 package.loaded[...] = IfStmt

       --Constructor.
     1 function IfStmt.new(ln, col, decl, val, cond, body, elif, el)
         local self

         --(1) create
    20   self = setmetatable(Stmt.new(StmtType.IF, ln, col), IfStmt)
    20   self.decl = decl
    20   self.value = val
    20   self.cond = cond
    20   self.body = body
    20   self.elif = elif
    20   self.el = el

         --(2) return
    20   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfSubExp.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An (if Exp then Exp else Exp) subexpression.
     1 local IfSubExp = {}
     1 IfSubExp.__index = IfSubExp
     1 setmetatable(IfSubExp, {__index = Terminal})
     1 package.loaded[...] = IfSubExp

       --Constructor.
     1 function IfSubExp.new(ln, col, cond, ifTrue, ifFalse)
         local self

         --(1) create
     5   self = setmetatable(Terminal.new(TerminalType.IF, {line = ln, col = col}), IfSubExp)
     5   self.cond = cond
     5   self.trueCase = ifTrue
     5   self.falseCase = ifFalse

         --(2) return
     5   return self
       end

       --@override
     1 function IfSubExp:__tostring()
     6   return string.format(
     3     "(if %s %s %s)",
     3     tostring(self.cond),
     3     tostring(self.trueCase),
     3     tostring(self.falseCase)
     3   )
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IifFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An iif() call.
     1 local IifFn = {}
     1 IifFn.__index = IifFn
     1 setmetatable(IifFn, {__index = Terminal})
     1 package.loaded[...] = IifFn

       --Constructor.
     1 function IifFn.new(ln, col, cond, onTrue, onFalse)
         local self

         --(1) create
     4   self = setmetatable(Terminal.new(TerminalType.IIF, {line = ln, col = col}), IifFn)
     4   self.cond = cond
     4   self.onTrue = onTrue
     4   self.onFalse = onFalse

         --(2) return
     4   return self
       end

       --@override
     1 function IifFn:__tostring()
     4   return string.format(
     2     "(iif %s %s %s)",
     2     tostring(self.cond),
     2     tostring(self.onTrue),
     2     tostring(self.onFalse)
     2   )
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An array terminal node.
     1 local LiteralFn = {}
     1 LiteralFn.__index = LiteralFn
     1 setmetatable(LiteralFn, {__index = Terminal})
     1 package.loaded[...] = LiteralFn

       --Constructor.
     1 function LiteralFn.new(ln, col, params, rtype, rvar, body)
         local self

    39   self = setmetatable(Terminal.new(TerminalType.FN, {
    13     line = ln,
    13     col = col,
    13     value = {
    13       params = params,
    13       type = rtype,
    13       rvar = rvar,
    13       body = body
    13     }
    26   }), LiteralFn)

    13   return self
       end

       --@override
     1 function LiteralFn:__tostring()
         local desc

    36   desc = "fn("
    60   for i, p in ipairs(self.data.params) do
    24     desc = desc .. (i == 1 and "" or ", ") .. p.name
         end
    36   desc = desc .. ")"

    36   desc = desc .. "{"
    66   for i, s in ipairs(self.data.body) do
    30     desc = desc .. (i == 1 and "" or "; ") .. tostring(s)
         end
    36   desc = desc .. "}"

    36   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralList.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A literal list node.
     1 local LiteralList = {}
     1 LiteralList.__index = LiteralList
     1 setmetatable(LiteralList, {__index = Terminal})
     1 package.loaded[...] = LiteralList

       --Constructor.
     1 function LiteralList.new(ln, col, arr)
    13   return setmetatable(Terminal.new(TerminalType.LIST, {line = ln, col = col, value = arr}), LiteralList)
       end

       --@override
     1 function LiteralList:__tostring()
         local desc

    55   desc = "["
   145   for i, v in ipairs(self.data) do
    90     desc = desc .. (i == 1 and "" or ", ") .. tostring(v)
         end
    55   desc = desc .. "]"

    55   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralMap.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A map terminal node.
     1 local LiteralMap = {}
     1 LiteralMap.__index = LiteralMap
     1 setmetatable(LiteralMap, {__index = Terminal})
     1 package.loaded[...] = LiteralMap

       --Constructor.
     1 function LiteralMap.new(ln, col, map)
    16   return setmetatable(Terminal.new(TerminalType.MAP, {line = ln, col = col, value = map}), LiteralMap)
       end

       --@override
     1 function LiteralMap:__tostring()
         local desc

    73   desc = "{"
   175   for i, e in ipairs(self.data) do
   102     desc = desc .. (i == 1 and "" or ", ") .. e.name .. " = " .. tostring(e.value)
         end
    73   desc = desc .. "}"

    73   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NaryOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A n-ary operator.
     1 local NaryOp = {}
     1 NaryOp.__index = NaryOp
     1 setmetatable(NaryOp, {__index = Op})
     1 package.loaded[...] = NaryOp

       --Constructor.
       --
       --@param tok:Token
     1 function NaryOp.new(tok)
         local self

         --(1) create
   138   self = setmetatable(Op.new("n", tok), NaryOp)
   138   self.children = {}
   138   self.finished = false

         --(2) return
   138   return self
       end

       --@override
     1 function NaryOp:insert(node)
   227   if self.finished then
     2     error(string.format(
     1       "(%s,%s): node can't be inserted to full call.",
     1       node.tok.line,
     1       node.tok.col
     1     ))
         end

   226   table.insert(self.children, node)
       end

       --@override
     1 function NaryOp.remove()
     1   error("call operator can't remove children.")
       end

       --@override
     1 function NaryOp:isWellFormed()
   131   return self.finished
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NativeFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A native code.
     1 local NativeFn = {}
     1 NativeFn.__index = NativeFn
     1 setmetatable(NativeFn, {__index = Terminal})
     1 package.loaded[...] = NativeFn

       --Constructor.
     1 function NativeFn.new(ln, col, code)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.NATIVE, {line = ln, col = col}), NativeFn)
     2   self.code = code

         --(2) return
     2   return self
       end

       --@override
     1 function NativeFn:__tostring()
     1   return string.format('(native "%s")', self.code)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NextStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A next statement.
     1 local NextStmt = {}
     1 NextStmt.__index = NextStmt
     1 setmetatable(NextStmt, {__index = Stmt})
     1 package.loaded[...] = NextStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function NextStmt.new(ln, col)
     3   return setmetatable(Stmt.new(StmtType.NEXT, ln, col), NextStmt)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Node.lua
==============================================================================
       --A node.
     1 local Node = {}
     1 Node.__index = Node
     1 package.loaded[...] = Node

       --Constructor.
       --
       --@param t:string           Node type.
     1 function Node.new(t, tok)
  6228   return setmetatable({
  3114     type = t,
  3114     parent = nil,
  3114     token = tok
  6228   }, Node)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NonTerminal.lua
==============================================================================
       --imports
     1 local Node = require("dogma.syn._.Node")
     1 local NodeType = require("dogma.syn.NodeType")

       --A non-terminal node, that is, a branch.
     1 local NonTerminal = {}
     1 NonTerminal.__index = NonTerminal
     1 setmetatable(NonTerminal, {__index = Node})
     1 package.loaded[...] = NonTerminal

       --Constructor.
       --
       --@param sub:NonTerminalType
       --@param tok:Token
     1 function NonTerminal.new(sub, tok)
         local self

         --(1) create
  1657   self = setmetatable(Node.new(NodeType.NON_TERMINAL, tok), NonTerminal)
  1657   self.subtype = sub

         --(2) return
  1657   return self
       end

       --Add a node to the non-terminal.
       --
       --@param child:Node Node to add.
     1 function NonTerminal.insert()
     1   error("abstract node.")
       end

       --Remove and return last child for transfering to other node.
       --
       --@return Node
     1 function NonTerminal.remove()
     1   error("abstract node.")
       end

       --Is it well-formed?
       --
       --@return bool
       -- function NonTerminal:isWellFormed()
       --   error("abstract method.")
       -- end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ObjectStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")

       --A statement for defining an object.
     1 local ObjectStmt = {}
     1 ObjectStmt.__index = ObjectStmt
     1 setmetatable(ObjectStmt, {__index = Stmt})
     1 package.loaded[...] = ObjectStmt

       --Constructor.
       --
       --@param sub:StmtType   Statement type.
       --@param ln:number      Line number.
       --@param col:number     Column number.
       --@param name:string    Object name.
       --@param visib:string   export or pub if indicated?
     1 function ObjectStmt.new(sub, ln, col, name, visib)
         local self

         --(1) create
   140   self = setmetatable(Stmt.new(sub, ln, col), ObjectStmt)
   140   self.name = name
   140   self.visib = visib

         --(2) return
   140   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Op.lua
==============================================================================
       --imports
     1 local NonTerminal = require("dogma.syn._.NonTerminal")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")

       --An operator.
     1 local Op = {}
     1 Op.__index = Op
     1 setmetatable(Op, {__index = NonTerminal})
     1 package.loaded[...] = Op

       --Constructor.
       --
       --@param arity:string       Arity: u, b, t, n.
       --@param optor:string       The operator.
     1 function Op.new(arity, tok)
         local self

         --(1) create
   701   self = setmetatable(NonTerminal.new(NonTerminalType.OP, tok), Op)
   701   self.op = tok.value
   701   self.arity = arity
   701   local desc = self:getDesc()
   701   self.assoc = desc.assoc
   701   self.prec = desc.prec

         --(2) return
   701   return self
       end

       --Return the operator descriptor: assoc and prec.
     1 function Op:getDesc()
   701   local OPS = {
   701     ["u ."] = {assoc = "r", prec = 20},
   701     ["u :"] = {assoc = "r", prec = 20},
   701     ["u <<<"] = {assoc = "r", prec = 20},
   701     ["u >>>"] = {assoc = "r", prec = 20},

   701     ["b ."] = {assoc = "l", prec = 19},
   701     ["b :"] = {assoc = "l", prec = 19},
   701     ["n .{}"] = {assoc = "l", prec = 19},
   701     ["b ?"] = {assoc = "l", prec = 19},
   701     ["b []"] = {assoc = "l", prec = 19},  --index
   701     ["t []"] = {assoc = "l", prec = 19},  --index
   701     ["n ()"] = {assoc = "l", prec = 19},  --call
   701     ["n {}"] = {assoc = "l", prec = 19},  --exp{}

   701     ["u !"] = {assoc = "r", prec = 18},
   701     ["u not"] = {assoc = "r", prec = 18},
   701     ["u ~"] = {assoc = "r", prec = 18},
   701     ["u +"] = {assoc = "r", prec = 18},
   701     ["u -"] = {assoc = "r", prec = 18},

   701     ["b **"] = {assoc = "r", prec = 17},

   701     ["b *"] = {assoc = "l", prec = 16},
   701     ["b /"] = {assoc = "l", prec = 16},
   701     ["b %"] = {assoc = "l", prec = 16},

   701     ["b +"] = {assoc = "l", prec = 15},
   701     ["b -"] = {assoc = "l", prec = 15},

   701     ["b <<"] = {assoc = "l", prec = 14},
   701     ["b >>"] = {assoc = "l", prec = 14},
   701     ["b <<<"] = {assoc = "l", prec = 14},
   701     ["b >>>"] = {assoc = "l", prec = 14},

   701     ["b <"] = {assoc = "l", prec = 13},
   701     ["b <="] = {assoc = "l", prec = 13},
   701     ["b >"] = {assoc = "l", prec = 13},
   701     ["b >="] = {assoc = "l", prec = 13},
   701     ["b in"] = {assoc = "l", prec = 13},
   701     ["b notin"] = {assoc = "l", prec = 13},
   701     ["b is"] = {assoc = "l", prec = 13},
   701     ["b isnot"] = {assoc = "l", prec = 13},
   701     ["b like"] = {assoc = "l", prec = 13},
   701     ["b notlike"] = {assoc = "l", prec = 13},

   701     ["b =="] = {assoc = "l", prec = 12},
   701     ["b ==="] = {assoc = "l", prec = 12},
   701     ["b =~"] = {assoc = "l", prec = 12},
   701     ["b !="] = {assoc = "l", prec = 12},
   701     ["b !=="] = {assoc = "l", prec = 12},
   701     ["b !~"] = {assoc = "l", prec = 12},

   701     ["b &"] = {assoc = "l", prec = 11},
   701     ["b ^"] = {assoc = "l", prec = 10},
   701     ["b |"] = {assoc = "l", prec = 9},

   701     ["b &&"] = {assoc = "l", prec = 8},
   701     ["b and"] = {assoc = "l", prec = 8},

   701     ["b ||"] = {assoc = "l", prec = 7},
   701     ["b or"] = {assoc = "l", prec = 7},

   701     ["b ="] = {assoc = "r", prec = 6},
   701     ["b :="] = {assoc = "r", prec = 6},
   701     ["b .="] = {assoc = "r", prec = 6},
   701     ["b +="] = {assoc = "r", prec = 6},
   701     ["b -="] = {assoc = "r", prec = 6},
   701     ["b *="] = {assoc = "r", prec = 6},
   701     ["b **="] = {assoc = "r", prec = 6},
   701     ["b /="] = {assoc = "r", prec = 6},
   701     ["b %="] = {assoc = "r", prec = 6},
   701     ["b <<="] = {assoc = "r", prec = 6},
   701     ["b >>="] = {assoc = "r", prec = 6},
   701     ["b &="] = {assoc = "r", prec = 6},
   701     ["b |="] = {assoc = "r", prec = 6},
   701     ["b ^="] = {assoc = "r", prec = 6},
   701     ["b ?="] = {assoc = "r", prec = 6},

   701     ["u ..."] = {assoc = "r", prec = 5}
         }

   701   return OPS[self.arity .. " " .. self.op]
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PackOp.lua
==============================================================================
       --imports
     1 local NaryOp = require("dogma.syn._.NaryOp")

       --A
     1 local PackOp = {}
     1 PackOp.__index = PackOp
     1 setmetatable(PackOp, {__index = NaryOp})
     1 package.loaded[...] = PackOp

       --Constructor.
       --
       --@param tok:Token
       --@param
     1 function PackOp.new(tok)
         local self

         --(1) create
    18   self = setmetatable(NaryOp.new(tok), PackOp)
    18   self.children = {}
    18   self.finished = false

         --(2) return
    18   return self
       end

       --@override
     1 function PackOp:__tostring()
         local ops

         --(1) get expressions
    28   for ix, op in ipairs(self.children) do
    20     if ix == 1 then
     8       ops = op:__tostring()
           else
    12       ops = ops .. " " .. op.visib .. op.name

    12       if op.value then
     3         ops = ops .. "=" .. tostring(op.value)
             end
           end
         end

         --(2) return
     8   return string.format("(pack %s)", ops)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Param.lua
==============================================================================
       --A function parameter.
     1 local Param = {}
     1 Param.__index = Param
     1 package.loaded[...] = Param

       --Constructor.
       --
       --@param const:bool
       --@param mod?:string . or : or ....
       --@param name:string
       --@param opt:bool
       --@param dtype?:Exp
       --@param val?:Exp
     1 function Param.new(const, mod, name, opt, dtype, val)
         local self

         --(1) create
   192   self = setmetatable({
    96     const = const,
    96     modifier = mod,  --. or : or ...
    96     name = name,
    96     optional = not not opt,
    96     type = dtype,
    96     value = val
   192   }, Param)

         --(2) return
    96   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Params.lua
==============================================================================
       --A parameters list.
     1 local Params = {}
     1 Params.__index = Params
     1 setmetatable(Params, {__index = table})
     1 package.loaded[...] = Params

       --Constructor.
     1 function Params.new()
   130   return setmetatable({}, Params)
       end

       --Check whether a parameter exists.
       --
       --@param name:string  Parameter name.
       --@return bool
     1 function Params:has(name)
         local res

         --(1) check
    11   res = false

    25   for _, param in ipairs(self) do
    16     if param.name == name then
     2       res = true
             break
           end
         end

         --(2) return
    11   return res
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PawaitFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A pawait call.
     1 local PawaitFn = {}
     1 PawaitFn.__index = PawaitFn
     1 setmetatable(PawaitFn, {__index = Terminal})
     1 package.loaded[...] = PawaitFn

       --Constructor.
     1 function PawaitFn.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.PAWAIT, {line = ln, col = col}), PawaitFn)
     2   self.exp = exp

         --(2) return
     2   return self
       end

       --@override
     1 function PawaitFn:__tostring()
     1   return string.format("(pawait %s)", tostring(self.exp))
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PevalFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A protected call.
     1 local PevalFn = {}
     1 PevalFn.__index = PevalFn
     1 setmetatable(PevalFn, {__index = Terminal})
     1 package.loaded[...] = PevalFn

       --Constructor.
     1 function PevalFn.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.PEVAL, {line = ln, col = col}), PevalFn)
     2   self.exp = exp

         --(2) return
     2   return self
       end

       --@override
     1 function PevalFn:__tostring()
     1   return string.format("(peval %s)", tostring(self.exp))
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PubStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")
     1 local UseStmt = require("dogma.syn._.UseStmt")

       --A pub statement.
     1 local PubStmt = {}
     1 PubStmt.__index = PubStmt
     1 setmetatable(PubStmt, {__index = Stmt})
     1 package.loaded[...] = PubStmt

       --Constructor.
     1 function PubStmt.new(ln, col, items)
         local self

         --(1) create
     8   self = setmetatable(Stmt.new(StmtType.PUB, ln, col), PubStmt)
     8   self.items = items

    18   for _, item in ipairs(items) do
    10     if item.type == "use" then
     5       item.value = {
     5         path = item.value,
     5         name = UseStmt.getNameFor(item.value)
     5       }
           end
         end

         --(2) return
     8   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ReturnStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A return statement.
     1 local ReturnStmt = {}
     1 ReturnStmt.__index = ReturnStmt
     1 setmetatable(ReturnStmt, {__index = Stmt})
     1 package.loaded[...] = ReturnStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param val?:Exp   Value to return.
     1 function ReturnStmt.new(ln, col, val)
         local self

         --(1) create
    29   self = setmetatable(Stmt.new(StmtType.RETURN, ln, col), ReturnStmt)
    29   if val then
     2     self.values = {val}
         else
    27     self.values = {}
         end

         --(2) return
    29   return self
       end

       --@override
     1 function ReturnStmt:__len()
     2   return #self.values
       end

       --Add a value.
       --
       --@param val:Exp  Value to add.
     1 function ReturnStmt:insert(val)
    25   table.insert(self.values, val)
       end

     1 function ReturnStmt:__tostring()
    25   if #self.values == 0 then
     3     return "return"
         else
    22     return "return " .. tostring(self.values[1])
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/RunWithDirective.lua
==============================================================================
       --imports
     1 local Directive = require("dogma.syn._.Directive")
     1 local DirectiveType = require("dogma.syn.DirectiveType")

       --A runWith directive.
     1 local RunWithDirective = {}
     1 RunWithDirective.__index = RunWithDirective
     1 setmetatable(RunWithDirective, {__index = Directive})
     1 package.loaded[...] = RunWithDirective

       --Constructor.
     1 function RunWithDirective.new(ln, col, cmd)
         local self

         --(1) create
     3   self = setmetatable(Directive.new(DirectiveType.RUNWITH, ln, col), RunWithDirective)
     3   self.cmd = cmd

         --(2) return
     3   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Sent.lua
==============================================================================
       --A sentence.
     1 local Sent = {}
     1 Sent.__index = Sent
     1 package.loaded[...] = Sent

       --Constructor.
     1 function Sent.new(t, ln, col)
  2690   return setmetatable({
  1345     type = t,
  1345     line = ln,
  1345     col = col,
  1345     _ = {}
  2690   }, Sent)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SliceOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A slice operator: [,].
     1 local SliceOp = {}
     1 SliceOp.__index = SliceOp
     1 setmetatable(SliceOp, {__index = Op})
     1 package.loaded[...] = SliceOp

       --Constructor.
       --
       --@param tok:Token
     1 function SliceOp.new(tok)
         local self

     5   self = setmetatable(Op.new("t", tok), SliceOp)
     5   self.children = {}

     5   return self
       end

       --@override
     1 function SliceOp:insert(node)
         -- if #self.children == 3 then
         --   error("children already set.")
         -- end

    15   table.insert(self.children, node)
       end

       --@override
       -- function SliceOp.remove()
       --   error("slice operator can't remove children.")
       -- end

       --@override
     1 function SliceOp:isWellFormed()
     5   return #self.children == 3
       end

       --@override
     1 function SliceOp:__tostring()
    15   return string.format("(%s %s %s %s)", self.op, self.children[1], self.children[2], self.children[3])
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Stmt.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --A statement.
     1 local Stmt = {}
     1 Stmt.__index = Stmt
     1 setmetatable(Stmt, {__index = Sent})
     1 package.loaded[...] = Stmt

       --Constructor.
       --
       --@param sub:StmtType   Statement type.
       --@param ln:number      Line number.
       --@param col:number     Column number.
     1 function Stmt.new(sub, ln, col)
         local self

         --(1) create
   354   self = setmetatable(Sent.new(SentType.STMT, ln, col), Stmt)
   354   self.subtype = sub

         --(2) return
   354   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubExp.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A subexpression: (Exp).
     1 local SubExp = {}
     1 SubExp.__index = SubExp
     1 setmetatable(SubExp, {__index = Terminal})
     1 package.loaded[...] = SubExp

       --Constructor.
     1 function SubExp.new(ln, col, exp)
    12   return setmetatable(Terminal.new(TerminalType.SUBEXP, {line = ln, col = col, value = exp}), SubExp)
       end

       --@override
     1 function SubExp:__tostring()
     7   return tostring(self.data)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")

       --A subparser.
     1 local SubParser = {}
     1 SubParser.__index = SubParser
     1 package.loaded[...] = SubParser

       --Constructor.
       --
       --@param Parser:Parser  Parent parser.
     1 function SubParser.new(parser)
         --(1) arguments
  3520   if not parser then error("parser expected.") end

         --(2) create
  7040   return setmetatable({
  3520     _ = {
  3520       parser = parser,
  3520       lexer = parser._.lexer
  3520     }
  7040   }, SubParser)
       end

       --Read next end of lines.
     1 function SubParser:_nextEols()
    29   local lex = self._.lexer

         while true do
    45     local tok = lex:advance()
    45     if tok.type == TokenType.EOL then
    16       lex:next()
           else
             break
           end
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SyntaxTree.lua
==============================================================================
       --imports
     1 local NodeType = require("dogma.syn.NodeType")
     1 local NonTerminal = require("dogma.syn._.NonTerminal")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")

       --A syntax tree, for example, an expression.
     1 local SyntaxTree = {}
     1 SyntaxTree.__index = SyntaxTree
     1 setmetatable(SyntaxTree, {__index = NonTerminal})
     1 package.loaded[...] = SyntaxTree

       --Constructor.
     1 function SyntaxTree.new()
         local self

         --(1) create
   954   self = setmetatable(NonTerminal.new(NonTerminalType.TREE), SyntaxTree)
   954   self.root = nil
   954   self._ = {
   954     current = nil
   954   }

         --(2) return
   954   return self
       end

       --@override
     1 function SyntaxTree:insert(node)
         --(1) arguments
  2151   if not node then error("node expected.") end

         --(2) add
  2151   if self.root == nil then --1st node to add
   944     self:_init(node)
         else
  1207     self:_update(node)
         end
       end

     1 function SyntaxTree:_init(node)
   944   self.root = node

   944   if node.type == NodeType.NON_TERMINAL then
    30     self._.current = node
         end
       end

     1 function SyntaxTree:_update(node)
  1207   if self.root.type == NodeType.TERMINAL then
   595     self:_updateTerminalRoot(node)
         else
   612     self:_updateFromCurrent(node)
         end
       end

       --Update the tree when this is well-formed with one terminal.
     1 function SyntaxTree:_updateTerminalRoot(node)
   595   if node.type == NodeType.TERMINAL then
     2     error(string.format(
     1       "(%s,%s): terminal can't follow to other terminal.",
     1       node.token.line,
     1       node.token.col
     1     ))
         end

         --node is non-terminal, for example, an operator
   594   node:insert(self.root)
   594   self.root = node
   594   self._.current = node
       end

       --Update th tree from the current node.
       --For example, when a+b for adding a call operator.
       --We use the precedence and the associativity for determining.
     1 function SyntaxTree:_updateFromCurrent(new)
   620   local cur = self._.current

   620   if self:isWellFormed() then
    78     if new.type == NodeType.TERMINAL then
     2       error(string.format(
     1         "on (%s,%s), invalid terminal node for well-formed expression.",
     1         new.token.line,
     1         new.token.col
     1       ))
           else
    77       if cur.prec > new.prec then
    31         self:_updateUpNodeFromCurrent(new)
    46       elseif cur.prec < new.prec then
    27         self:_updateDownNodeFromCurrent(new)
             else
    19         if cur.assoc == "l" then
    18           self:_updateUpNodeFromCurrent(new)
               else
     1           self:_updateDownNodeFromCurrent(new)
               end
             end
           end
         else  --non well-formed
   542     cur:insert(new)

   541     if new.type == NodeType.NON_TERMINAL then
     6       self._.current = new
           end
         end
       end

     1 function SyntaxTree:_updateUpNodeFromCurrent(node)
    49   if self.root == self._.current then
    41     node:insert(self.root)
    41     self.root = node
    41     self._.current = node
         else
     8     self._.current = self._.current.parent
     8     self:_updateFromCurrent(node)
         end
       end

     1 function SyntaxTree:_updateDownNodeFromCurrent(node)
    28   node:insert(self._.current:remove())
    28   self._.current:insert(node)
    28   self._.current = node
       end

       --@override
     1 function SyntaxTree:__tostring()
   822   return self.root:__tostring()
       end

       --@override
     1 function SyntaxTree:isWellFormed()
  2118   if not self.root then
    41     return false
  2077   elseif self.root.type == NodeType.TERMINAL then
   768     return true
         else
  1309     return self._.current:isWellFormed()
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Terminal.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local Node = require("dogma.syn._.Node")
     1 local NodeType = require("dogma.syn.NodeType")

       --A terminal node.
     1 local Terminal = {}
     1 Terminal.__index = Terminal
     1 setmetatable(Terminal, {__index = Node})
     1 package.loaded[...] = Terminal

       --Constructor.
       --
       --@param sub:TerminalTtype
       --@param tok:Token
     1 function Terminal.new(sub, tok)
         local self

         --(1) create
  1457   self = setmetatable(Node.new(NodeType.TERMINAL, tok), Terminal)
  1457   self.subtype = sub
  1457   self.data = tok.value

         --(2) return
  1457   return self
       end

       --@override
     1 function Terminal:__tostring()
  1156   return string.format("%s", self.data)
       end

       --Is it an identifier?
       --
       --@return bool
     1 function Terminal:isId()
    15   return self.token.type == TokenType.NAME
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ThrowFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A throw function.
     1 local ThrowFn = {}
     1 ThrowFn.__index = ThrowFn
     1 setmetatable(ThrowFn, {__index = Terminal})
     1 package.loaded[...] = ThrowFn

       --Constructor.
     1 function ThrowFn.new(ln, col, args)
         local self

         --(1) create
     6   self = setmetatable(Terminal.new(TerminalType.THROW, {line = ln, col = col}), ThrowFn)
     6   self.args = args

         --(2) return
     6   return self
       end

       --@override
     1 function ThrowFn:__tostring()
         local repr

         --(1) build
     3   repr = "(throw "

     9   for i, arg in ipairs(self.args) do
     6     repr = repr .. (i == 1 and "" or " ") .. tostring(arg)
         end

     3   repr = repr .. ")"

         --(2) return
     3   return repr
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/TypeStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A type statement.
     1 local TypeStmt = {}
     1 TypeStmt.__index = TypeStmt
     1 setmetatable(TypeStmt, {__index = ObjectStmt})
     1 package.loaded[...] = TypeStmt

       --Constructor.
     1 function TypeStmt.new(ln, col, annots, visib, name, params, btype, bargs, body, catch, fin)
         local self

         --(1) create
    15   self = setmetatable(ObjectStmt.new(StmtType.TYPE, ln, col, name, visib), TypeStmt)
    15   self.params = params
    15   self.base = btype
    15   self.bargs = bargs
    15   self.body = body
    15   self.catch = catch
    15   self.finally = fin
    15   self.annots = annots or {}

         --(2) return
    15   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UnaryOp.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local Op = require("dogma.syn._.Op")
     1 local NodeType = require("dogma.syn.NodeType")

       --Unary operator.
     1 local UnaryOp = {}
     1 UnaryOp.__index = UnaryOp
     1 setmetatable(UnaryOp, {__index = Op})
     1 package.loaded[...] = UnaryOp

       --Constructor.
       --
       --@param tok:Token
     1 function UnaryOp.new(tok)
         local self

         --(1) create
    36   self = setmetatable(Op.new("u", tok), UnaryOp)
    36   self.child = nil

         --(2) return
    36   return self
       end

       --@override
     1 function UnaryOp:insert(node)
         --(1) pre
    38   if tablex.find({".", ":"}, self.op) then
    15     if not (node.type == NodeType.TERMINAL and node:isId()) then
     2       error(string.format(
     1         "on (%s, %s), '.' and ':' must be followed by identifier.",
     1         node.token.line,
     1         node.token.col
     1       ))
           end
         end

         --(2) add
    37   self.child = node
    37   node.parent = self
       end

       --@override
     1 function UnaryOp:remove()
     2   local c = self.child
     2   self.child = nil
     2   return c
       end

       --@override
     1 function UnaryOp:isWellFormed()
    77   return not not self.child
       end

       --@override
     1 function UnaryOp:__tostring()
    20   return string.format("(%s %s)", self.op, self.child)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Unpack.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --An unpack sentence.
     1 local Unpack = {}
     1 Unpack.__index = Unpack
     1 setmetatable(Unpack, {__index = Sent})
     1 package.loaded[...] = Unpack

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param sub:string     Unpack type: [] or {}.
       --@param vars:array
       --@param assign:string  =, := or ?=.
       --@param exp:Exp
     1 function Unpack.new(ln, col, sub, vars, assign, exp)
         local self

         --(1) create
    23   self = setmetatable(Sent.new(SentType.UNPACK, ln, col), Unpack)
    23   self.subtype = sub
    23   self.vars = vars
    23   self.assign = assign
    23   self.exp = exp

         --(2) return
    23   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UpdateOp.lua
==============================================================================
       --imports
     1 local NaryOp = require("dogma.syn._.NaryOp")

       --An update op: Exp.{...} or Exp:{...}.
     1 local UpdateOp = {}
     1 UpdateOp.__index = UpdateOp
     1 setmetatable(UpdateOp, {__index = NaryOp})
     1 package.loaded[...] = UpdateOp

       --Constructor.
       --
       --@param tok:Token
       --@param
     1 function UpdateOp.new(tok, visib)
         local self

         --(1) create
    21   self = setmetatable(NaryOp.new(tok), UpdateOp)
    21   self.visib = visib
    21   self.children = {}
    21   self.finished = false

         --(2) return
    21   return self
       end

       --@override
     1 function UpdateOp:__tostring()
         local ops

         --(1) get expressions
    40   for ix, op in ipairs(self.children) do
    28     if ix == 1 then
    12       ops = tostring(op)
           else
    34       for _, name in ipairs(type(op.name) == "string" and {op.name} or op.name) do
    36         ops = ops .. " " .. string.format(
    18           "%s%s%s%s",
    18           op.type == "mapped" and "{" or (op.type == "extended" and "(" or ""),
    18           self.visib,
    18           name,
    18           op.type == "mapped" and "}" or (op.type == "extended" and ")" or "")
    12         )

    18         if op.value then
    13           ops = ops .. op.assign .. tostring(op.value)
               end
             end
           end
         end

         --(2) return
    12   return string.format("(update %s)", ops)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A use call.
     1 local UseFn = {}
     1 UseFn.__index = UseFn
     1 setmetatable(UseFn, {__index = Terminal})
     1 package.loaded[...] = UseFn

       --Constructor.
     1 function UseFn.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.USE, {line = ln, col = col}), UseFn)
     2   self.exp = exp

         --(2) return
     2   return self
       end

       --@override
     1 function UseFn:__tostring()
     1   return string.format("(use %s)", tostring(self.exp))
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --use statement.
     1 local UseStmt = {}
     1 UseStmt.__index = UseStmt
     1 setmetatable(UseStmt, {__index = Stmt})
     1 package.loaded[...] = UseStmt

       --Constructor.
     1 function UseStmt.new(ln, col)
         local self

         --(1) create
    20   self = setmetatable(Stmt.new(StmtType.USE, ln, col), UseStmt)
    20   self.modules = {}

         --(2) return
    20   return self
       end

       --Add a module.
       --
       --@param mod:string   Module to use.
       --@param name?:string Variable module name.
     1 function UseStmt:insert(mod, name)
         --(1) set name if needed
    25   if not name then
    15     name = UseStmt.getNameFor(mod)
         end

         --(2) add module
    24   table.insert(self.modules, {name = name, path = mod})
       end

     1 function UseStmt.getNameFor(path)
    20   local NAME_PATTERN1 = "^[%a_][%w_]*$"
    20   local NAME_PATTERN2 = "^[%a_][%w_%-]*-([%a_][%w_]*)$"
    20   local Q_PATTERN1 = "^.*/([%a_][%w_]*)$"
    20   local Q_PATTERN2 = "^.*%.([%a_][%w_]*)$"
         local name

    20   if path:find(NAME_PATTERN1) then
    11     name = path
     9   elseif path:find(NAME_PATTERN2) then
     1     name = path:match(NAME_PATTERN2)
     8   elseif path:find(Q_PATTERN1) then
     6     name = path:match(Q_PATTERN1)
     2   elseif path:find(Q_PATTERN2) then
     1     name = path:match(Q_PATTERN2)
         else
     1     error(string.format("invalid module path format: '%s'.", path))
         end

    19   return name
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A var statement.
     1 local VarStmt = {}
     1 VarStmt.__index = VarStmt
     1 setmetatable(VarStmt, {__index = Stmt})
     1 package.loaded[...] = VarStmt

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param visib:string Visibility: export or pub.
       --@param decls:list   Declarations.
     1 function VarStmt.new(ln, col, visib, decls)
         local self

         --(1) create
    28   self = setmetatable(Stmt.new(StmtType.VAR, ln, col), VarStmt)
    28   self.decls = decls
    28   self.visib = visib

         --(2) return
    28   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmtParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local ConstStmt = require("dogma.syn._.ConstStmt")
     1 local VarStmt = require("dogma.syn._.VarStmt")

       --A var/const statement parser.
     1 local VarStmtParser = {}
     1 VarStmtParser.__index = VarStmtParser
     1 setmetatable(VarStmtParser, {__index = SubParser})
     1 package.loaded[...] = VarStmtParser

       --Constructor.
       --
       --@param parser:Parser  Parent parser.
     1 function VarStmtParser.new(parser)
         local self

         --(1) create
   663   self = setmetatable(SubParser.new(parser), VarStmtParser)
   663   self._.expParser = parser._.expParser

         --(2) return
   663   return self
       end

       --Read a const statement.
       --
       --@return ConstStmt
     1 function VarStmtParser:nextConst()
    22   local lex = self._.lexer
         local tok, ln, col, visib, sep, decls

         --(1) read visibility
    22   tok = lex:advance()
    22   ln, col = tok.line, tok.col

    22   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     4     lex:next()
     4     visib = tok.value
         end

         --(2) read const keyword
    22   lex:nextKeyword("const")

         --(3) get separator
    22   tok = lex:advance()

    22   if tok.type == TokenType.EOL then
     5     sep = "\n"
     5     lex:next()
         else
    17     sep = ","
         end

         --(4) get declarations
    22   decls = {}

         while true do
           --end?
    30     tok = lex:advance()

    30     if tok == nil or (sep == "\n" and tok.col <= col) then
             break
           end

           --read declaration
    25     table.insert(decls, self:nextConstDecl())

           --read separator
    24     if sep == "\n" then
     5       lex:nextEol()
           else  --using comma as separator
    19       tok = lex:advance()

    19       if tok.type == TokenType.EOL then
               break
             end

     4       lex:nextSymbol(",")
           end
         end

         --(5) return
    20   return ConstStmt.new(ln, col, visib, decls)
       end

     1 function VarStmtParser:nextConstDecl()
    25   local lex = self._.lexer
    25   local tok = lex:advance()

    25   if tok.type == TokenType.SYMBOL and tok.value == "{" then
     3     return self:nextMap()
    22   elseif tok.type == TokenType.SYMBOL and tok.value == "[" then
     4     return self:nextList()
         else
    18     return self:nextConstStd()
         end
       end

     1 function VarStmtParser:nextConstStd()
    18   local lex, exp = self._.lexer, self._.expParser
         local name, val

         --(1) name
    18   name = lex:nextName().value
    18   lex:nextSymbol("=")
    17   val = exp:next()

         --(2) return
    17   return {type = "std", name = name, value = val}
       end

       --Read a var statement.
       --
       --@return VarStmt
     1 function VarStmtParser:nextVar()
    29   local lex = self._.lexer
         local tok, ln, col, visib, sep, decls

         --(1) read visibility
    29   tok = lex:advance()
    29   ln, col = tok.line, tok.col

    29   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     8     lex:next()
     8     visib = tok.value
         end

         --(2) read var keyword
    29   lex:nextKeyword("var")

         --(3) get separator
    29   tok = lex:advance()

    29   if tok.type == TokenType.EOL then
     6     sep = "\n"
     6     lex:next()
         else
    23     sep = ","
         end

         --(4) get declarations
    29   decls = {}

         while true do
           --end?
    39     tok = lex:advance()

    39     if tok == nil or (sep == "\n" and tok.col <= col) then
             break
           end

           --read declaration
    33     table.insert(decls, self:nextVarDecl())

           --read separator
    33     if sep == "\n" then
     6       lex:nextEol()
           else  --using comma as separator
    27       tok = lex:advance()

    27       if tok.type == TokenType.EOL then
               break
             end

     5       lex:nextSymbol(",")
           end
         end

         --(5) return
    28   return VarStmt.new(ln, col, visib, decls)
       end

       --Return the next var declaration.
     1 function VarStmtParser:nextVarDecl()
    33   local lex = self._.lexer
    33   local tok = lex:advance()

    33   if tok.type == TokenType.SYMBOL and tok.value == "{" then
     4     return self:nextMap()
    29   elseif tok.type == TokenType.SYMBOL and tok.value == "[" then
     7     return self:nextList()
         else
    22     return self:nextVarStd()
         end
       end

     1 function VarStmtParser:nextVarStd()
    22   local lex, exp = self._.lexer, self._.expParser
         local tok, name, val

         --(1) name
    22   name = lex:nextName().value

    22   tok = lex:advance()
    22   if tok.type == TokenType.SYMBOL and tok.value == "=" then
    13     lex:nextSymbol("=")
    13     val = exp:next()
         end

         --(2) return
    22   return {type = "std", name = name, value = val}
       end

     1 function VarStmtParser:nextMap()
     7   local lex, exp = self._.lexer, self._.expParser
         local names, val

         --(1) names
     7   lex:nextSymbol("{")

     7   names = {}
         while true do
           local tok

    10     table.insert(names, lex:nextName().value)

    10     tok = lex:advance()
    10     if tok.type == TokenType.SYMBOL and tok.value == "}" then
             break
           end

     3     lex:nextSymbol(",")
         end

     7   lex:nextSymbol("}")
     7   lex:nextSymbol("=")
     7   val = exp:next()

         --(2) return
     7   return {type = "map", names = names, value = val}
       end

     1 function VarStmtParser:nextList()
    11   local lex, exp = self._.lexer, self._.expParser
         local names, val

         --(1) names
    11   lex:nextSymbol("[")

    11   names = {}
         while true do
           local tok

    18     tok = lex:advance()
    18     if tok.type == TokenType.SYMBOL and tok.value == "..." then
     3       lex:nextSymbol("...")
     3       table.insert(names, "..." .. lex:nextName().value)
           else
    15       table.insert(names, lex:nextName().value)
           end

    18     tok = lex:advance()
    18     if tok.type == TokenType.SYMBOL and tok.value == "]" then
             break
           end

     7     lex:nextSymbol(",")
         end

    11   lex:nextSymbol("]")
    11   lex:nextSymbol("=")
    11   val = exp:next()

         --(2) return
    11   return {type = "list", names = names, value = val}
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WhileStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A while statement.
     1 local WhileStmt = {}
     1 WhileStmt.__index = WhileStmt
     1 setmetatable(WhileStmt, {__index = Stmt})
     1 package.loaded[...] = WhileStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param cond:Exp
       --@param iter?:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function WhileStmt.new(ln, col, cond, iter, body, catch, fin)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.WHILE, ln, col), WhileStmt)
    18   self.cond = cond
    18   self.iter = iter
    18   self.body = body
    18   self.catch = catch
    18   self.finally = fin

         --(2) return
    18   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WithStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --with statement.
     1 local WithStmt = {}
     1 WithStmt.__index = WithStmt
     1 setmetatable(WithStmt, {__index = Stmt})
     1 package.loaded[...] = WithStmt

       --Constructor.
     1 function WithStmt.new(ln, col, val, ifs, els)
         local self

         --(1) create
     7   self = setmetatable(Stmt.new(StmtType.WITH, ln, col), WithStmt)
     7   self.value = val
     7   self.ifs = ifs
     7   self.els = els

         --(2) return
     7   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/YieldStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A yield statement.
     1 local YieldStmt = {}
     1 YieldStmt.__index = YieldStmt
     1 setmetatable(YieldStmt, {__index = Stmt})
     1 package.loaded[...] = YieldStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param val?:Exp   Value to return.
     1 function YieldStmt.new(ln, col, val)
         local self

         --(1) create
     7   self = setmetatable(Stmt.new(StmtType.YIELD, ln, col), YieldStmt)
     7   self.value = val

         --(2) return
     7   return self
       end

       --@override
     1 function YieldStmt:__tostring()
     3   return "yield " .. tostring(self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/Trans.lua
==============================================================================
       --A transformer.
     1 local Trans = {}
     1 Trans.__index = Trans
     1 package.loaded[...] = Trans

       --Constructor.
     1 function Trans.new()
   598   return setmetatable({
   299     _ = {

   299     }
   598   }, Trans)
       end

       --Confirgue the transformer.
       --
       --@param parser:Parser  Parser to use.
     1 function Trans:transform(parser)
   298   self._.parser = parser
       end

       --Transform the next sentence or file from the parser configured previously.
       --
       --@abstract
       --@return string
     1 function Trans:next()
     1   error("abstract method.")
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/Trans.lua
==============================================================================
       --imports
     1 local Trans = require("dogma.trans.Trans")
     1 local DirectiveTrans = require("dogma.trans.js._.DirectiveTrans")
     1 local ExpTrans = require("dogma.trans.js._.ExpTrans")
     1 local StmtTrans = require("dogma.trans.js._.StmtTrans")
     1 local UnpackTrans = require("dogma.trans.js._.UnpackTrans")
     1 local SentType = require("dogma.syn.SentType")

       --internal data
       local PRE = [[
       import {any, bool, datetime, func, list, map, num, promise, proxy, text, abstract, coalesce, dogma, echo, echof, exec, expect, fmt, keys, len, print, printf, todo, typename, values} from "dogmalang";
     1 ]]

       --A JavaScript transformer.
     1 local JsTrans = {}
     1 JsTrans.__index = JsTrans
     1 setmetatable(JsTrans, {__index = Trans})
     1 package.loaded[...] = JsTrans

       --Constructor.
     1 function JsTrans.new(opts)
         local self

         --(1) create
   298   self = setmetatable(Trans.new(opts), JsTrans)
   298   self._.directiveTrans = DirectiveTrans.new(self)
   298   self._.expTrans = ExpTrans.new(self)
   298   self._.stmtTrans = StmtTrans.new(self)
   298   self._.unpackTrans = UnpackTrans.new(self)

         --(2) return
   298   return self
       end

       --@override
     1 function JsTrans:next(opts)
   297   local parser = self._.parser
         local out

         --(1) arguments
   297   if not opts then
   295     opts = {}
         end

         --(2) transform
   297   local first = false

   297   out = ""
         while true do
           local sent

   595     sent = parser:next()

   595     if sent == nil then
             break
           end

   298     out = out .. self:_trans(sent, ";") .. "\n"

   298     if opts.importDogmalang then
     3       if not first then
     2         first = true

     2         if out:find("^#!/") then
     1           out = out .. PRE
               else
     1           out = PRE .. out
               end
             end
           end
         end

         --(2) return
   297   return out
       end

     1 function JsTrans:_trans(sent, eoe)
   509   if sent.type == SentType.DIRECTIVE then
    10     return self._.directiveTrans:transform(sent)
   499   elseif sent.type == SentType.EXP then
   320     return self._.expTrans:transform(sent) .. (eoe or "")
   179   elseif sent.type == SentType.STMT then
   164     return self._.stmtTrans:transform(sent)
    15   elseif sent.type == SentType.UNPACK then
    15     return self._.unpackTrans:transform(sent)
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/DirectiveTrans.lua
==============================================================================
       --imports
     1 local DirectiveType = require("dogma.syn.DirectiveType")
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --A directive transformer.
     1 local DirectiveTrans = {}
     1 DirectiveTrans.__index = DirectiveTrans
     1 setmetatable(DirectiveTrans, {__index = SubTrans})
     1 package.loaded[...] = DirectiveTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function DirectiveTrans.new(trans)
   298   return setmetatable(SubTrans.new(trans), DirectiveTrans)
       end

       --Transform a directive.
       --
       --@param dir:Directive  Directive to transform.
       --@return string
     1 function DirectiveTrans:transform(dir)
    10   if dir.subtype == DirectiveType.IF then
     8     return self:_transIf(dir)
     2   elseif dir.subtype == DirectiveType.RUNWITH then
     2     return self:_transRunWith(dir)
         end
       end

       --Transform an if directive.
       --
       --@return string
     1 function DirectiveTrans:_transIf(dir)
         local function transform(sents)
     6     local trans = self._.trans
           local code

     6     code = ""
    12     for _, sent in ipairs(sents) do
     6       code = code .. trans:_trans(sent)
           end

     6     return code
         end

         --(1) transform if
         local code

     8   if dir.cond == "js" or (dir.cond:find("^not") and dir.cond ~= "not js") then
     4     code = transform(dir.body)
     4   elseif dir.el then
     2     code = transform(dir.el)
         else
     2     code = ""
         end

         --(2) return
     8   return code
       end

       --Transform a runWith directive.
       --
       --@return string
     1 function DirectiveTrans:_transRunWith(dir)
     2   return "#!" .. dir.cmd
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/ExpTrans.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local NodeType = require("dogma.syn.NodeType")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")
     1 local transName = require("dogma.trans.js._.util").transName
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --An expression transformer to JavaScript.
     1 local ExpTrans = {}
     1 ExpTrans.__index = ExpTrans
     1 setmetatable(ExpTrans, {__index = SubTrans})
     1 package.loaded[...] = ExpTrans

       --Constructor.
     1 function ExpTrans.new(trans)
   298   return setmetatable(SubTrans.new(trans), ExpTrans)
       end

       --Transform an expression.
       --
       --@param exp:Exp      Expression to transform.
       --@return string
     1 function ExpTrans:transform(exp)
   363   return self:_transNode(exp.tree.root)
       end

       --Transform a node.
       --
       --@param node:Node
       --@return string
     1 function ExpTrans:_transNode(node)
   948   if node.type == NodeType.TERMINAL then
   644     return self:_transTerminal(node)
   304   elseif node.type == NodeType.NON_TERMINAL then
   304     return self:_transNonTerminal(node)
         end
       end

       --Transform a terminal node.
       --
       --@param node:Terminal
       --@return string
     1 function ExpTrans:_transTerminal(node)
   644   if node.subtype == TerminalType.NAME then
   348     return transName(node.data)
   296   elseif node.subtype == TerminalType.NUM then
   232     return tostring(node.data)
    64   elseif node.subtype == TerminalType.TEXT then
    16     return string.format([["%s"]], node.data:gsub('"', '\\"')):gsub("\n", "\\n")
    48   elseif node.subtype == TerminalType.TRUE then
    14     return "true"
    34   elseif node.subtype == TerminalType.FALSE then
     2     return "false"
    32   elseif node.subtype == TerminalType.NIL then
     1     return "null"
    31   elseif node.subtype == TerminalType.LIST then
     3     return self:_transLiteralList(node)
    28   elseif node.subtype == TerminalType.MAP then
     3     return self:_transLiteralMap(node)
    25   elseif node.subtype == TerminalType.SELF then
     1     return "this"
    24   elseif node.subtype == TerminalType.SUPER then
     1     return "super"
    23   elseif node.subtype == TerminalType.NOP then
     1     return "dogma.nop()"
    22   elseif node.subtype == TerminalType.FN then
     7     return self:_transLiteralFn(node)
    15   elseif node.subtype == TerminalType.IIF then
     2     return self:_transIifFn(node)
    13   elseif node.subtype == TerminalType.SUBEXP then
     3     return self:transform(node.data)
    10   elseif node.subtype == TerminalType.NATIVE then
     1     return self:_transNativeFn(node)
     9   elseif node.subtype == TerminalType.AWAIT then
     1     return self:_transAwaitFn(node)
     8   elseif node.subtype == TerminalType.PEVAL then
     1     return self:_transPevalFn(node)
     7   elseif node.subtype == TerminalType.PAWAIT then
     1     return self:_transPawaitFn(node)
     6   elseif node.subtype == TerminalType.THROW then
     3     return self:_transThrowFn(node)
     3   elseif node.subtype == TerminalType.USE then
     1     return self:_transUseFn(node)
     2   elseif node.subtype == TerminalType.IF then
     2     return self:_transIfSubExp(node)
         end
       end

       --Transform if Exp then Exp else Exp end
     1 function ExpTrans:_transIfSubExp(node)
     4   return string.format(
     2     "(%s ? %s : %s)",
     2     self:transform(node.cond),
     2     self:transform(node.trueCase),
     2     node.falseCase ~= nil and self:transform(node.falseCase) or "null"
     3   )
       end

       --Transform a native() function.
     1 function ExpTrans:_transNativeFn(fn)
     1   return string.format(fn.code)
       end

       --Transform an await() function.
     1 function ExpTrans:_transAwaitFn(fn)
     1   return string.format("await(%s)", self:transform(fn.exp))
       end

       --Transform a pawait() function.
     1 function ExpTrans:_transPawaitFn(fn)
     1   return string.format("dogma.pawait((done) => {%s;})", self:transform(fn.exp))
       end

       --Transform a use() function.
     1 function ExpTrans:_transUseFn(fn)
     1   return string.format("dogma.use(require(%s))", self:transform(fn.exp))
       end

       --Transform a peval() function.
     1 function ExpTrans:_transPevalFn(fn)
     1   return string.format("dogma.peval(() => {return %s;})", self:transform(fn.exp))
       end

       --Transform an iif() function.
     1 function ExpTrans:_transIifFn(fn)
     4   return string.format(
     2     "(%s ? %s : %s)",
     2     self:transform(fn.cond),
     2     self:transform(fn.onTrue),
     2     fn.onFalse and self:transform(fn.onFalse) or "null"
     3   )
       end

       --Transform a throw() function.
     1 function ExpTrans:_transThrowFn(fn)
         local code

         --(1) transform
     3   code = "dogma.raise("

     3   if #fn.args == 1 then
     1     code = code .. self:transform(fn.args[1])
         else
     7     for i, arg in ipairs(fn.args) do
     5       code = code .. (i == 1 and "" or ", ") .. self:transform(arg)
           end
         end

     3   code = code .. ")"

         --(2) return
     3   return code
       end

       --Transform a literal list.
     1 function ExpTrans:_transLiteralList(term)
         local code

         --(1) transform
     3   code = "["

     6   for ix, item in ipairs(term.data) do
     3     code = code .. (ix == 1 and "" or ", ") .. self:transform(item)
         end

     3   code = code .. "]"

         --(2) return
     3   return code
       end

       --Transform a literal map.
     1 function ExpTrans:_transLiteralMap(term)
         local code

         --(1) transform
     3   code = "{"

     7   for i, entry in ipairs(term.data) do
     8     code = code .. (i == 1 and "" or ", ") .. string.format(
     4       '["%s"]: %s',
     4       entry.name,
     4       self:transform(entry.value)
           )
         end

     3   code = code .. "}"

         --(2) return
     3   return code
       end

       --Transform a literal function.
     1 function ExpTrans:_transLiteralFn(term)
     7   local strans = self._.trans._.stmtTrans

    14   return string.format(
     7     "((%s) => { %s%s%s%s })",
     7     strans:_transParams(term.data.params),
     7     strans:_transReturnVar(term.data),
     7     strans:_transParamsCheck(term.data.params),
     7     strans:_transBody(term.data.body),
     7     term.data.rvar and string.format(" return %s;", term.data.rvar == "self" and "this" or term.data.rvar) or ""
    13   )
       end

       --Transform a non-terminal node.
       --
       --@param node:NonTerminal
       --@return string
     1 function ExpTrans:_transNonTerminal(node)
   304   if node.subtype == NonTerminalType.OP then
   304     return self:_transOp(node)
         end
       end

       --Transform an operator node.
       --
       --@param node:Op
       --@return string
     1 function ExpTrans:_transOp(node)
   304   if node.arity == "u" then
    12     return self:_transUnaryOp(node)
   292   elseif node.arity == "b" then
   257     return self:_transBinOp(node)
    35   elseif node.arity == "t" then
     2     return self:_transTernaryOp(node)
    33   elseif node.arity == "n" then
    33     return self:_transNaryOp(node)
         end
       end

     1 function ExpTrans:_transUnaryOp(node)
    12   if node.op == "." then
     3     return "this." .. node.child.data
     9   elseif node.op == ":" then
     1     return "this._" .. node.child.data
     8   elseif node.op == "not" or node.op == "!" then
     2     return string.format("!(%s)", self:_transNode(node.child))
     6   elseif node.op == "~" then
     1     return string.format("~(%s)", self:_transNode(node.child))
     5   elseif node.op == "+" then
     1     return string.format("+(%s)", self:_transNode(node.child))
     4   elseif node.op == "-" then
     1     return string.format("-(%s)", self:_transNode(node.child))
     3   elseif node.op == "..." then
     1     return string.format("...(%s)", self:_transNode(node.child))
     2   elseif node.op == "<<<" then
     1     return string.format("dogma.lshift(%s)", self:_transNode(node.child))
     1   elseif node.op == ">>>" then
     1     return string.format("dogma.rshift(%s)", self:_transNode(node.child))
         end
       end

     1 function ExpTrans:_transBinOp(node)
   257   local left, right = node.children[1], node.children[2]

   257   if tablex.find({"+", "-", "*", "**", "/", "%", "==", "!=", "===", "!==", "<", "<=", ">", ">=", "||", "&&", "<<", "<<"}, node.op) then
   175     return "(" .. self:_transNode(left) .. node.op .. self:_transNode(right) .. ")"
    82   elseif tablex.find({"=", "+=", "-=", "*=", "**=", "/=", "%=", "<<=", ">>=", "|=", "&=", "^="}, node.op) then
    34     return self:_transAssign(node)
    48   elseif node.op == "=~" then
     1     return self:_transEnumEq(node)
    47   elseif node.op == "!~" then
     1     return self:_transEnumNe(node)
    46   elseif node.op == "?=" then
     4     return self:_transCondAssign(node)
    42   elseif node.op == ".=" then
     1     return self:_transAssignWithPubProp(node)
    41   elseif node.op == ":=" then
     5     return self:_transConstAssign(node)
    36   elseif node.op == ">>>" then
     1     return string.format("dogma.rshift(%s, %s)", self:_transNode(left), self:_transNode(right))
    35   elseif node.op == "<<<" then
     1     return string.format("dogma.lshift(%s, %s)", self:_transNode(left), self:_transNode(right))
    34   elseif node.op == "and" then
     1     return "(" .. self:_transNode(left) .. "&&" .. self:_transNode(right) .. ")"
    33   elseif node.op == "or" then
     1     return "(" .. self:_transNode(left) .. "||" .. self:_transNode(right) .. ")"
    32   elseif node.op == "?" then
     1     return string.format("(%s != null ? %s.%s : null)", self:_transNode(left), self:_transNode(left), self:_transNode(right))
    31   elseif node.op == "." then
    15     if left.subtype == TerminalType.SUPER then
     1       return string.format('dogma.super(this, "%s")', self:_transNode(right))
           else
    14       return self:_transNode(left) .. "." .. self:_transNode(right)
           end
    16   elseif node.op == ":" then
     7     if left.subtype == TerminalType.SUPER then
     1       return string.format('dogma.super(this, "_%s")', self:_transNode(right))
           else
     6       return self:_transNode(left) .. "._" .. self:_transNode(right)
           end
     9   elseif node.op == "is" then
     1     return string.format("dogma.is(%s, %s)", self:_transNode(left), self:_transNode(right))
     8   elseif node.op == "isnot" then
     1     return string.format("dogma.isNot(%s, %s)", self:_transNode(left), self:_transNode(right))
     7   elseif node.op == "in" then
     1     return string.format("dogma.includes(%s, %s)", self:_transNode(right), self:_transNode(left))
     6   elseif node.op == "notin" then
     1     return string.format("!dogma.includes(%s, %s)", self:_transNode(right), self:_transNode(left))
     5   elseif node.op == "like" then
     1     return string.format("dogma.like(%s, %s)", self:_transNode(left), self:_transNode(right))
     4   elseif node.op == "notlike" then
     1     return string.format("dogma.notLike(%s, %s)", self:_transNode(left), self:_transNode(right))
     3   elseif node.op == "[]" then
     3     return string.format("dogma.getItem(%s, %s)", self:_transNode(left), self:_transNode(right))
         end
       end

     1 function ExpTrans:_transEnumEq(op)
     2   return string.format(
     1     'dogma.enumEq(%s, "%s")',
     1     self:_transNode(op.children[1]),
     1     self:_transNode(op.children[2])
     1   )
       end

     1 function ExpTrans:_transEnumNe(op)
     2   return string.format(
     1     '(!dogma.enumEq(%s, "%s"))',
     1     self:_transNode(op.children[1]),
     1     self:_transNode(op.children[2])
     1   )
       end

     1 function ExpTrans:_transCondAssign(op)
     4   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     4   if left.arity == "b" and left.op == "[]" then
     2     code = string.format(
     1       'dogma.setItem("=", %s, %s, coalesce(dogma.getItem(%s, %s), %s))',
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         else
     6     code = string.format(
     3       "(%s = coalesce(%s, %s))",
     3       self:_transNode(left),
     3       self:_transNode(left),
     3       self:_transNode(right)
     3     )
         end

         --(2) return
     4   return code
       end

     1 function ExpTrans:_transAssign(op)
    34   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
    34   if left.op == "[]" then
     2     code = string.format(
     1       [[dogma.setItem("%s", %s, %s, %s)]],
     1       op.op,
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         else
    33     code = string.format("(%s%s%s)", self:_transNode(left), op.op, self:_transNode(right))
         end

         --(2) return
    34   return code
       end

     1 function ExpTrans:_transConstAssign(op)
     5   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     5   if left.arity == "u" and left.op == "." then
     2     code = string.format(
     1       [[Object.defineProperty(this, "%s", {value: %s, enum: true})]],
     1       self:_transNode(left.child),
     1       self:_transNode(right)
     1     )
     4   elseif left.arity == "b" and left.op == "." then
     2     code = string.format(
     1       [[Object.defineProperty(%s, "%s", {value: %s, enum: true})]],
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
     3   elseif left.op == ":" then
     2     if left.arity == "u" then
     2       code = string.format(
     1         [[Object.defineProperty(this, "_%s", {value: %s})]],
     1         left.child.data,
     1         self:_transNode(right)
     1       )
           else
     2       code = string.format(
     1         [[Object.defineProperty(%s, "_%s", {value: %s})]],
     1         self:_transNode(left.children[1]),
     1         left.children[2].data,
     1         self:_transNode(right)
     1       )
           end
     1   elseif left.op == "[]" then
     2     code = string.format(
     1       [[dogma.setItem("=", %s, %s, %s)]],
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         end

         --(2) return
     5   return code
       end

     1 function ExpTrans:_transAssignWithPubProp(op)
     1   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     1   if left.arity == "u" then
     2     code = string.format(
     1       'Object.defineProperty(this, "_%s", {value: %s, writable: true});',
     1       left.child.data,
     1       self:_transNode(right)
     1     )

     2     code = code .. string.format(
     1       'Object.defineProperty(this, "%s", {enum: true, get() { return this._%s; }})',
     1       left.child.data,
     1       left.child.data
     1     )
         end

         --(2) return
     1   return code
       end

     1 function ExpTrans:_transTernaryOp(op)
     2   if op.op == "[]" then
     4     return string.format(
     2       "dogma.getSlice(%s, %s, %s)",
     2       self:_transNode(op.children[1]),
     2       self:_transNode(op.children[2]),
     2       self:_transNode(op.children[3])
     2     )
         end
       end

     1 function ExpTrans:_transNaryOp(node)
    33   if node.op == "()" then
    19     return self:_transCallOp(node)
    14   elseif node.op == "{}" then
     8     return self:_transPackOp(node)
     6   elseif node.op == ".{}" then
     6     return self:_transUpdateOp(node)
         end
       end

     1 function ExpTrans:_transCallOp(node)
         local code

    19   code = self:_transNode(node.children[1]) .. "("
    56   for i, arg in ipairs(node.children) do
    37     if i > 1 then
    18       code = code .. (i == 2 and "" or ", ") .. self:_transNode(arg.tree.root)
           end
         end
    19   code = code .. ")"

    19   return code
       end

     1 function ExpTrans:_transPackOp(node)
         local code

         --(1) transform
     8   if #node.children > 1 and node.children[2].name == "*" then
     3     code = string.format("dogma.clone(%s", self:_transNode(node.children[1]))

    12     for i, item in ipairs(node.children) do
     9       if i == 3 then
     2         code = code .. ", {"
     7       elseif i > 3 then
     1         code = code .. ", "
             end

     9       if i >= 3 then
     6         code = code .. string.format(
     3           '"%s%s": %s',
     3           item.visib == "." and "" or "_",
     3           item.name,
     3           self:transform(item.value)
               )
             end
           end

     3     if #node.children > 2 then
     2       code = code .. "})"
           else
     1       code = code .. ")"
           end
         else
     5     code = "dogma.pack("

    19     for i, item in ipairs(node.children) do
    14       if i == 1 then
     5         code = code .. self:_transNode(item)
             else
     9         if item.value == nil then
     6           code = code .. string.format(', "%s%s"', item.visib == "." and "" or "_", item.name)
               else
     6           code = code .. string.format(
     3             ', {name: "%s%s", value: %s}',
     3             item.visib == "." and "" or "_",
     3             item.name,
     3             self:transform(item.value)
                 )
               end
             end
           end

     5     code = code .. ")"
         end

         --(2) return
     8   return code
       end

     1 function ExpTrans:_transUpdateOp(op)
         local code

         --(1) transform
     6   code = "dogma.update(" .. self:_transNode(op.children[1])

    15   for _, fld in ipairs(table.pack(table.unpack(op.children, 2))) do
     9     if fld.type then
     6       code = code .. string.format(
     3         ', {name: [%s], visib: "%s", assign: "%s", value: %s, type: "%s"}',
     8         table.concat(tablex.map(function(name) return string.format('"%s"', name) end, fld.name), ", "),
     3         op.visib,
     3         fld.assign or "=",
     3         fld.value and self:transform(fld.value) or fld.name,
               fld.type
     6       )
           else
    12       code = code .. string.format(
     6         ', {name: "%s", visib: "%s", assign: "%s", value: %s}',
     6         fld.name,
     6         op.visib,
     6         fld.assign or "=",
     6         fld.value and self:transform(fld.value) or fld.name
             )
           end
         end

     6   code = code .. ")"

         --(2) return
     6   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/StmtTrans.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local StmtType = require("dogma.syn.StmtType")
     1 local transName = require("dogma.trans.js._.util").transName
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --A statement transformer.
     1 local StmtTrans = {}
     1 StmtTrans.__index = StmtTrans
     1 setmetatable(StmtTrans, {__index = SubTrans})
     1 package.loaded[...] = StmtTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function StmtTrans.new(trans)
   298   return setmetatable(SubTrans.new(trans), StmtTrans)
       end

       --Transform a statement.
       --
       --@param stmt:Stmt  Statement to transform.
       --@return string
     1 function StmtTrans:transform(stmt)
   164   if stmt.subtype == StmtType.ASYNC then
     4     return self:_transAsync(stmt)
   160   elseif stmt.subtype == StmtType.BREAK then
     1     return self:_transBreak(stmt)
   159   elseif stmt.subtype == StmtType.CONST then
     7     return self:_transConst(stmt)
   152   elseif stmt.subtype == StmtType.DO then
     5     return self:_transDo(stmt)
   147   elseif stmt.subtype == StmtType.ENUM then
     4     return self:_transEnum(stmt)
   143   elseif stmt.subtype == StmtType.EXPORT then
     1     return self:_transExport(stmt)
   142   elseif stmt.subtype == StmtType.FN then
    56     return self:_transFn(stmt)
    86   elseif stmt.subtype == StmtType.FOR then
     7     return self:_transFor(stmt)
    79   elseif stmt.subtype == StmtType.FOR_EACH then
     5     return self:_transForEach(stmt)
    74   elseif stmt.subtype == StmtType.FROM then
     4     return self:_transFrom(stmt)
    70   elseif stmt.subtype == StmtType.IF then
     9     return self:_transIf(stmt)
    61   elseif stmt.subtype == StmtType.NEXT then
     1     return self:_transNext(stmt)
    60   elseif stmt.subtype == StmtType.PUB then
     3     return self:_transPub(stmt)
    57   elseif stmt.subtype == StmtType.RETURN then
    16     return self:_transReturn(stmt)
    41   elseif stmt.subtype == StmtType.TYPE then
     8     return self:_transType(stmt)
    33   elseif stmt.subtype == StmtType.USE then
     4     return self:_transUse(stmt)
    29   elseif stmt.subtype == StmtType.VAR then
    18     return self:_transVar(stmt)
    11   elseif stmt.subtype == StmtType.WHILE then
     6     return self:_transWhile(stmt)
     5   elseif stmt.subtype == StmtType.WITH then
     1     return self:_transWith(stmt)
     4   elseif stmt.subtype == StmtType.YIELD then
     4     return self:_transYield(stmt)
         end
       end

       --Transform a use statement.
       --
       --@return string
     1 function StmtTrans:_transUse(stmt)
         local code

         --(1) transform
     6   code = ""

    14   for _, mod in ipairs(stmt.modules) do
     8     code = code .. string.format('const %s = dogma.use(require("%s"));', mod.name, mod.path, mod.path)
         end

         --(2) return
     6   return code
       end

       --Transform a from statement.
       --
       --@return string
     1 function StmtTrans:_transFrom(stmt)
         local code

         --(1) transform
     4   code = "import {"

    10   for i, mem in ipairs(stmt.members) do
     6     code = code .. (i == 1 and "" or ", ")

     6     if mem.name == mem.as then
     3       code = code .. mem.name
           else
     3       code = code .. string.format("%s as %s", mem.name, mem.as)
           end
         end

     4   code = code .. [[} from "]] .. stmt.module .. [[";]]

         --(2) return
     4   return code
       end

       --Transform a break statement.
       --
       --@return string
     1 function StmtTrans:_transBreak(stmt)
     1   return "break;"
       end

       --Transform a next statement.
       --
       --@return string
     1 function StmtTrans:_transNext(stmt)
     1   return "continue;"
       end

       --Transform an enum statement.
       --
       --@return string
     1 function StmtTrans:_transEnum(enum)
         local code

         --(1) transform
     8   code = string.format([[
       %sclass %s {
         constructor(name, val) {
           Object.defineProperty(this, "name", {value: name, enum: true});
           Object.defineProperty(this, "value", {value: val, enum: true});
         }

         toString() {
           return this.name;
         }
       }
     4 ]],
     4     self:_transVisib(enum.visib),
           enum.name
     8   )

    12   for _, item in ipairs(enum.items) do
    16     code = code .. string.format(
     8       [[Object.defineProperty(%s, "%s", {value: new %s("%s", %s), enum: true});]] .. "\n",
     8       enum.name,
     8       item.name,
     8       enum.name,
     8       item.name,
     8       (type(item.value) == "string" and string.format([["%s"]], item.value) or item.value)
           )
         end

         --(2) return
     4   return code
       end

     1 function StmtTrans:_transVisib(visib)
    44   if visib == "export" then
     4     return "export default "
    40   elseif visib == "pub" then
     8     return "export "
         else
    32     return ""
         end
       end

       --Transform an async statement.
       --
       --@param node
       --@return string
     1 function StmtTrans:_transAsync(node)
     4   local trans = self._.trans
         local code

         --(1) get sentences to run
     4   if node.catch then
     2     code = "try "
         else
     2     code = ""
         end

     4   code = code .. self:_transBody(node.body)
     4   code = code .. self:_transCatch(node.catch)

         --(2) return
     4   if node.opts.delay then
     1     return string.format("setTimeout(() => %s, %s);", code, trans:_trans(node.opts.delay))
         else
     3     return string.format("setImmediate(() => %s);", code)
         end
       end

       --Transform a var statement.
       --
       --@return string
     1 function StmtTrans:_transVar(stmt)
         local code

         --(1) transform
    18   code = ""

    18   if #stmt.decls > 0 then
    36     for _, decl in ipairs(stmt.decls) do
    19       if decl.type == "std" then
     8         code = code .. self:_transStdDecl(stmt.visib, true, decl)
    11       elseif decl.type == "map" then
     4         code = code .. self:_transMapDecl(stmt.visib, true, decl)
             else
     7         code = code .. self:_transListDecl(stmt.visib, true, decl)
             end
           end
         end

         --(2) return
    18   return code
       end

       --Transform a var statement.
       --
       --@return string
     1 function StmtTrans:_transConst(stmt)
         local code

         --(1) transform
     7   code = ""

     7   if #stmt.decls > 0 then
    13     for _, decl in ipairs(stmt.decls) do
     7       if decl.type == "std" then
     5         code = code .. self:_transStdDecl(stmt.visib, false, decl)
     2       elseif decl.type == "map" then
     1         code = code .. self:_transMapDecl(stmt.visib, false, decl)
             else
     1         code = code .. self:_transListDecl(stmt.visib, false, decl)
             end
           end
         end

         --(2) return
     7   return code
       end

     1 function StmtTrans:_transStdDecl(visib, var, decl)
         local code

         --(1) transform
    13   code = (var and (visib and "var " or "let ") or "const ")

    13   if decl.value then
    10     code = code .. string.format("%s = %s;", decl.name, self._.trans:_trans(decl.value))
         else
     3     code = code .. decl.name .. ";"
         end

    13   if visib then
     4     visib = self:_transVisib(visib)

     4     if visib == "export default " then
     2       code = code .. visib .. decl.name .. ";"
           else
     2       code = code .. visib .. "{" .. decl.name .. "};"
           end
         end

         --(2) return
    13   return code
       end

     1 function StmtTrans:_transMapDecl(visib, var, decl)
         local code

         --(1) transform
     5   code = var and (visib and "var {" or "let {") or "const {"

    12   for ix, name in ipairs(decl.names) do
     7     code = code .. (ix == 1 and "" or ", ") .. name
         end

     5   code = code .. string.format("} = %s;", self._.trans:_trans(decl.value))

     5   if visib then
     2     code = code .. self:_transVisib(visib) .. "{" .. table.concat(decl.names, ", ") .. "};"
         end

         --(2) return
     5   return code;
       end

     1 function StmtTrans:_transListDecl(visib, var, decl)
         local code

         --(1) transform
     8   code = var and (visib and "var [" or "let [") or "const ["

    21   for ix, name in ipairs(decl.names) do
    13     code = code .. (ix == 1 and "" or ", ") .. name
         end

    16   code = code .. string.format(
     8     "] = dogma.getArrayToUnpack(%s, %s);",
     8     self._.trans:_trans(decl.value),
     8     #decl.names
         )

     8   if visib then
     2     code = code .. self:_transVisib(visib) .. "{" .. table.concat(decl.names, ", "):gsub("%.%.%.", "") .. "};"
         end

         --(2) return
     8   return code;
       end

       --Transform an while statement.
       --
       --@return string
     1 function StmtTrans:_transWhile(node)
     6   local trans = self._.trans
         local code

         --(1) transform
     6   if node.iter then
     2     code = string.format(
     1       "for (; %s; %s) ",
     1       trans:_trans(node.cond),
     1       trans:_trans(node.iter)
     1     )
         else
     5     code = string.format("while (%s) ", trans:_trans(node.cond))
         end

     6   if node.catch or node.finally then
     3     code = code .. "try "
         end

     6   code = code .. self:_transBody(node.body)
     6   code = code .. self:_transCatch(node.catch)
     6   code = code .. self:_transFinally(node.finally)

         --(2) return
     6   return code
       end

       --Transform a statement body.
       --
       --2return string
     1 function StmtTrans:_transBody(body)
   107   local trans = self._.trans
         local code

         --(1) transform
   107   code = "{"

   181   for _, sent in ipairs(body) do
    74     code = code .. trans:_trans(sent, ";")
         end

   107   code = code .. "}"

         --(2) return
   107   return code
       end

       --Transform a catch clause.
       --
       --@return string
     1 function StmtTrans:_transCatch(catch)
    82   local trans = self._.trans
         local code

         --(1) transform
    82   if catch then
    10     code = string.format(" catch(%s) {", catch.var or "_")

    20     for _, sent in ipairs(catch.body) do
    10       code = code .. trans:_trans(sent, ";")
           end

    10     code = code .. "}"
         end

         --(2) return
    82   return code or ""
       end

       --Transform a finally clause.
       --
       --@return string
     1 function StmtTrans:_transFinally(fin)
    78   local trans = self._.trans
         local code

         --(1) transform
    78   if fin then
     7     code = " finally {"

    14     for _, sent in ipairs(fin.body) do
     7       code = code .. trans:_trans(sent, ";")
           end

     7     code = code .. "}"
         end

         --(2) return
    78   return code or ""
       end

       --Transform a do statement.
       --
       --@return string
     1 function StmtTrans:_transDo(node)
     5   local trans = self._.trans
         local code

         --(1) transform
     5   if node.catch or node.finally then
     4     if node.cond then
     1       code = "do try "
           else
     3       code = "try "
           end
         else
     1     code = "do "
         end

     5   code = code .. self:_transBody(node.body)
     5   code = code .. self:_transCatch(node.catch)
     5   code = code .. self:_transFinally(node.finally)

     5   if node.cond then
     2     code = code .. string.format(" while (%s);", trans:_trans(node.cond))
         end

         --(2) return
     5   return code
       end

       --Transfor a for statement.
       --
       --@return string
     1 function StmtTrans:_transFor(stmt)
     7   local trans = self._.trans
         local code

         --(1) transform
     7   code = "for (let "

    17   for i, var in ipairs(stmt.def) do
    10     code = code .. (i == 1 and "" or ", ") .. var.name

    10     if var.value then
     6       code = code .. " = " .. trans:_trans(var.value)
           end
         end

     7   code = code .. "; " .. trans:_trans(stmt.cond) .. "; "

     7   if stmt.iter then
     3     code = code .. trans:_trans(stmt.iter)
         end

     7   code = code .. ") "

     7   if stmt.catch or stmt.finally then
     1     code = code .. "try "
         end

     7   code = code .. self:_transBody(stmt.body)
     7   code = code .. self:_transCatch(stmt.catch)
     7   code = code .. self:_transFinally(stmt.finally)

         --(2) return
     7   return code
       end

       --Transform a for each statement.
       --
       --@return string
     1 function StmtTrans:_transForEach(node)
     5   local trans = self._.trans
         local code

         --(1) transform
     5   if node.key then
     2     code = string.format(
     1       "for (let [%s, %s] of Object.entries(%s)) { ",
     1       node.key,
     1       node.value,
     1       trans:_trans(node.iter)
     1     )
         else
     8     code = string.format(
     4       "for (let %s of %s) ",
     4       node.value,
     4       trans:_trans(node.iter)
     4     )
         end

     5   if node.catch or node.finally then
     3     code = code .. "try "
         end

     5   code = code .. self:_transBody(node.body)
     5   code = code .. self:_transCatch(node.catch)
     5   code = code .. self:_transFinally(node.finally)

     5   if node.key then
     1     code = code .. " }"
         end

         --(2) return
     5   return code
       end

       --Transform a return statement.
       --
       --@return string
     1 function StmtTrans:_transReturn(node)
    16   local trans = self._.trans
         local code

         --(1) transform
    16   code = "return"

    16   if #node.values == 1 then
    15     code = code .. " " .. trans:_trans(node.values[1])
         end

    16   code = code .. ";"

         --(2) return
    16   return code
       end

       --Transform a yield statement.
       --
       --@return string
     1 function StmtTrans:_transYield(node)
     4   return "yield" .. " " .. self._.trans:_trans(node.value) .. ";"
       end

       --Transform a type statement.
       --
       --@return string
     1 function StmtTrans:_transType(stmt)
         local code

         --(1) transform
         --$class
     8   code = string.format("const $%s = class %s", stmt.name, stmt.name)
     8   if stmt.base then
     3     code = code .. " extends " .. stmt.base
         end

     8   code = code .. " {\n"

     8   if tablex.find(stmt.annots, "todo") then
     1     code = code .. string.format("  constructor() { todo(); }\n")
         else
     7     code = code .. string.format("  constructor(%s) { ", self:_transParams(stmt.params))
     7     code = code .. self:_transParamsCheck(stmt.params)
     7     code = code .. self:_transSuperConstructor(stmt.bargs)
     7     code = code .. self:_transSelfParams(stmt.params)
     7     if stmt.catch or stmt.finally then code = code .. " try " end
     7     code = code .. self:_transBody(stmt.body)
     7     code = code .. self:_transCatch(stmt.catch)
     7     code = code .. self:_transFinally(stmt.finally)
     7     code = code .. "  }\n"
         end

     8   code = code .. "};\n"

         --class proxy
    16   code = code .. string.format(
     8     "const %s = new Proxy($%s, { apply(receiver, self, args) { return new $%s(...args); } });",
     8     stmt.name,
     8     stmt.name,
           stmt.name
     8   )

     8   if stmt.visib == "export" then
     1     code = code .. string.format("export default %s;", stmt.name)
         end

         --(2) return
     8   return code
       end

       --Transform function parameters.
       --
       --@return string
     1 function StmtTrans:_transParams(params)
    57   local trans = self._.trans
         local code

         --(1) transform
    57   if #params > 0 then
    38     code = ""

    92     for i, p in ipairs(params) do
    54       if i > 1 then
    16         code = code .. ", "
             end

    54       if p.modifier == "..." then
     1         code = code .. "..."
             end

    54       code = code .. transName(p.name)

    54       if p.value then
     1         code = code .. " = " .. trans:_trans(p.value)
             end
           end
         end

         --(2) return
    57   return code or ""
       end

       --Return the code for checking the function parameters.
       --
       --@return string
     1 function StmtTrans:_transParamsCheck(params)
         local function transType(obj)
           local repr

     3     repr = "{"
    10     for ix, val in ipairs(obj) do
    14       repr = repr .. (ix == 1 and "" or ", ") .. string.format(
     7         "%s: {type: %s, mandatory: %s}",
     7         val.name,
     7         type(val.type) == "string" and val.type or string.format("[%s]", table.concat(val.type, ", ")),
               val.mandatory
     7       )
           end
     3     repr = repr .. "}"

     3     return repr
         end

         local code

         --(1) transform
    57   if #params > 0 then
    38     code = ""

    92     for _, p in ipairs(params) do
    54       if not p.optional and p.modifier ~= "..." then  --mandatory parameter with(out) type check
    29         if type(p.type) == "table" then
     4           if type(p.type[1]) == "string" then
     4             code = code .. string.format(
     2               [[dogma.paramExpected("%s", %s, [%s]);]],
     2               transName(p.name),
     2               transName(p.name),
     2               table.concat(p.type, ", ")
     2             )
                 else
     4             code = code .. string.format(
     2               [[dogma.paramExpectedToHave("%s", %s, %s);]],
     2               transName(p.name),
     2               transName(p.name),
     2               transType(p.type)
                   )
                 end
               else
    50           code = code .. string.format(
    25             [[dogma.paramExpected("%s", %s, %s);]],
    25             transName(p.name),
    25             transName(p.name),
    25             p.type or "null"
    23           )
               end
    25       elseif p.type then  --optional parameter with type check
     5         if type(p.type) == "table" then
     3           if type(p.type[1]) == "string" then
     4             code = code .. string.format(
     2               [[dogma.paramExpectedToBe("%s", %s, [%s]);]],
     2               transName(p.name),
     2               transName(p.name),
     2               table.concat(p.type, ", ")
     2             )
                 else
     2             code = code .. string.format(
     1               [[dogma.paramExpectedToHave("%s", %s, %s);]],
     1               transName(p.name),
     1               transName(p.name),
     1               transType(p.type)
                   )
                 end
               else
     4           code = code .. string.format(
     2             [[dogma.paramExpectedToBe("%s", %s, %s);]],
     2             transName(p.name),
     2             transName(p.name),
                   p.type
     2           )
               end
             end
           end
         end

         --(2) return
    57   return code or ""
       end

       --Return the code for setting . or : attributes from parameters.
       --
       --@return string
     1 function StmtTrans:_transSelfParams(params)
         local code

         --(1) transform
    50   if #params > 0 then
    32     code = ""

    79     for _, p in ipairs(params) do
    47       if p.modifier == "." then
    18         code = code .. string.format(
     9           [[Object.defineProperty(this, "%s", {value: %s, enum: true, writable: %s});]],
     9           transName(p.name),
     9           transName(p.name),
     9           not p.const
     9         )
    38       elseif p.modifier == ":" then
     2         code = code .. string.format(
     1           [[Object.defineProperty(this, "_%s", {value: %s, writable: %s});]],
     1           p.name,
     1           p.name,
     1           not p.const
               )
             end
           end
         end

         --(2) return
    50   return code or ""
       end

       --Return a call to the super constructor.
       --
       --@return string
     1 function StmtTrans:_transSuperConstructor(bargs)
     7   local trans = self._.trans
         local code

         --(1) Transform
     7   if bargs then
     2     if #bargs == 0 then
     1       code = "super();"
           else
     1       code = "super("

     3       for i, a in ipairs(bargs) do
     2         code = code .. (i == 1 and "" or ", ") .. trans:_trans(a)
             end

     1       code =  code .. ");"
           end
         end

         --(2) return
     7   return code or ""
       end

       --Transform a fn statement.
       --
       --@return string
     1 function StmtTrans:_transFn(stmt)
    56   if stmt.itype then
    24     return self:_transTypeFn(stmt)
         else
    32     return self:_transStdFn(stmt)
         end
       end

     1 function StmtTrans:_transStdFn(fn)
         local code

         --(1) transform
    32   if tablex.find(fn.annots, "todo") then
     2     code = string.format(
     1       "%s%sfunction%s %s() { todo(); }",
     1       self:_transVisib(fn.visib),
     1       fn.async and "async " or "",
     1       tablex.find(fn.annots, "iter") and "*" or "",
             fn.name
     2     )
         else
    62     code = string.format(
    31       "%s%sfunction%s %s(%s) { ",
    31       self:_transVisib(fn.visib),
    31       fn.async and "async " or "",
    31       tablex.find(fn.annots, "iter") and "*" or "",
    31       fn.name,
    31       self:_transParams(fn.params)
    31     )

    31     code = code .. self:_transReturnVar(fn)
    31     code = code .. self:_transParamsCheck(fn.params)
    31     code = code .. self:_transSelfParams(fn.params)
    31     if fn.catch or fn.finally then code = code .. " try " end
    31     code = code .. self:_transBody(fn.body)
    31     code = code .. self:_transCatch(fn.catch)
    31     code = code .. self:_transFinally(fn.finally)
    31     if fn.rvar then
     9       code = code .. string.format(" return %s;", fn.rvar == "self" and "this" or fn.rvar)
           end
    31     code = code .. " }"
         end

         --(2) return
    32   return code
       end

     1 function StmtTrans:_transTypeFn(stmt)
    24   if tablex.find(stmt.annots, "prop") then
     5     return self:_transProp(stmt)
    19   elseif tablex.find(stmt.annots, "iter") then
     4     return self:_transIterMethod(stmt)
         else
    15     return self:_transMethod(stmt)
         end
       end

     1 function StmtTrans:_transIterMethod(stmt)
         local code

         --(1) transform
     4   if tablex.find(stmt.annots, "todo") then
     2     if stmt.name == "iter" then
     2       code = string.format(
     1         "%s.prototype[Symbol.iterator] = function*() { todo(); };",
               stmt.itype
     2       )
           else
     2       code = string.format(
     1         '%s.prototype.%s%s = function*() { todo(); };',
     1         stmt.itype,
     1         stmt.visib == "pub" and "" or "_",
               stmt.name
     2       )
           end
         else
     2     if stmt.name == "iter" then
     2       code = string.format(
     1         "%s.prototype[Symbol.iterator] = function*() ",
               stmt.itype
     2       )
           else
     2       code = string.format(
     1         '%s.prototype.%s%s = function*() ',
     1         stmt.itype,
     1         stmt.visib == "pub" and "" or "_",
               stmt.name
     2       )
           end

     2     code = code .. self:_transReturnVar(stmt)
     2     if stmt.catch or stmt.finally then code = code .. " try " end
     2     code = code .. self:_transBody(stmt.body)
     2     code = code .. self:_transCatch(stmt.catch)
     2     code = code .. self:_transFinally(stmt.finally)


           -- if stmt.rvar then
           --   code = code .. string.format(" return %s;", stmt.rvar == "self" and "this" or stmt.rvar)
           -- end

     2     code = code .. ";"
         end

         --(2) return
     4   return code
       end

     1 function StmtTrans:_transProp(stmt)
         local code

         --(1) transform
    10   code = string.format(
     5     [[Object.defineProperty(%s.prototype, "%s%s", {enum: %s, get: function() { ]],
     5     stmt.itype,
     5     stmt.visib == "pub" and "" or "_",
     5     stmt.name,
     5     stmt.visib == "pub"
    10   )

     5   if tablex.find(stmt.annots, "abstract") then
     1     code = code .. "abstract();"
     4   elseif tablex.find(stmt.annots, "todo") then
     1     code = code .. "todo();"
         else
     3     code = code .. self:_transReturnVar(stmt)
     3     if stmt.catch or stmt.finally then code = code .. " try " end
     3     code = code .. self:_transBody(stmt.body)
     3     code = code .. self:_transCatch(stmt.catch)
     3     code = code .. self:_transFinally(stmt.finally)

     3     if stmt.rvar then
     1       code = code .. string.format(" return %s;", stmt.rvar == "self" and "this" or stmt.rvar)
           end
         end

     5   code = code .. " }});"

         --(2) return
     5   return code
       end

     1 function StmtTrans:_transMethod(stmt)
         local code

         --(1) transform
    15   if tablex.find(stmt.annots, "abstract") then
     2     code = string.format(
     1       "%s.prototype.%s%s = function() { abstract(); };",
     1       stmt.itype,
     1       stmt.visib == "pub" and "" or "_",
             stmt.name
     2     )
         else
    14     if tablex.find(stmt.annots, "static") then
     3       if tablex.find(stmt.annots, "todo") then
     2         code = string.format(
     1           "%s.%s%s = %sfunction() { todo(); };",
     1           stmt.itype,
     1           stmt.visib == "pub" and "" or "_",
     1           stmt.name,
     1           stmt.async and "async " or ""
     2         )
             else
     4         code = string.format(
     2           "%s.%s%s = %sfunction(%s) { ",
     2           stmt.itype,
     2           stmt.visib == "pub" and "" or "_",
     2           stmt.name,
     2           stmt.async and "async " or "",
     2           self:_transParams(stmt.params)
     2         )
             end
           else
    11       if tablex.find(stmt.annots, "todo") then
     2         code = string.format(
     1           "%s.prototype.%s%s = function() { todo(); };",
     1           stmt.itype,
     1           stmt.visib == "pub" and "" or "_",
                 stmt.name
     2         )
             else
    20         code = string.format(
    10           "%s.prototype.%s%s = %sfunction(%s) { ",
    10           stmt.itype,
    10           stmt.visib == "pub" and "" or "_",
    10           stmt.name,
    10           stmt.async and "async " or "",
    10           self:_transParams(stmt.params)
    10         )
             end
           end

    14     if not tablex.find(stmt.annots, "todo") then
    12       code = code .. self:_transReturnVar(stmt)
    12       code = code .. self:_transParamsCheck(stmt.params)
    12       code = code .. self:_transSelfParams(stmt.params)

    12       if stmt.catch or stmt.finally then code = code .. " try " end
    12       code = code .. self:_transBody(stmt.body)
    12       code = code .. self:_transCatch(stmt.catch)
    12       code = code .. self:_transFinally(stmt.finally)

    12       if stmt.rvar then
     3         code = code .. string.format(" return %s;", stmt.rvar == "self" and "this" or stmt.rvar)
             end

    12       code = code .. " };"
           end
         end

         --(2) return
    15   return code
       end

     1 function StmtTrans:_transReturnVar(fn)
         local code

         --(1) transform
    55   code = ""

    55   if fn.rvar then
    14     if fn.rvar ~= "self" and not fn.params:has(fn.rvar) then
     9       if fn.rtype == "map" then
     1         code = string.format("let %s = {};", fn.rvar)
     8       elseif fn.rtype == "list" then
     1         code = string.format("let %s = [];", fn.rvar)
     7       elseif fn.rtype == "bool" then
     1         code = string.format("let %s = false;", fn.rvar)
     6       elseif fn.rtype == "text" then
     1         code = string.format('let %s = "";', fn.rvar)
     5       elseif fn.rtype == "num" then
     1         code = string.format('let %s = 0;', fn.rvar)
             else
     4         code = string.format("let %s;", fn.rvar)
             end
           end
         end

         --(2) return
    55   return code
       end

       --Transform an if statement.
       --
       --@return string
     1 function StmtTrans:_transIf(stmt)
     9   local trans = self._.trans
         local code

         --(1) transform
     9   code = ""

     9   if stmt.value then
     3     if stmt.decl then
     2       code = "{" .. (stmt.decl == "var" and "let " or "const ")
     2       code = code .. trans:_trans(stmt.value):sub(2, -2) .. "; "
           else
     1       code = code .. trans:_trans(stmt.value) .. "; "
           end
         end

    18   code = code .. string.format(
     9     "if (%s) %s",
     9     trans:_trans(stmt.cond),
     9     self:_transBody(stmt.body)
         )

     9   if stmt.elif then
     5     for _, cl in ipairs(stmt.elif) do
     6       code = code .. string.format(
     3         " else if (%s) %s",
     3         trans:_trans(cl.cond),
     3         self:_transBody(cl.body)
             )
           end
         end

     9   if stmt.el then
     3     code = code .. " else " .. self:_transBody(stmt.el)
         end

     9   if stmt.decl then
     2     code = code .. "}"
         end

         --(2) return
     9   return code
       end

       --Transform a pub statement.
       --
       --@return string
     1 function StmtTrans:_transPub(stmt)
         local code

         --(1) transform
     3   code = ""

     7   for _, item in ipairs(stmt.items) do
     4     if item.type == "pub" then
     2       code = code .. string.format("export {%s};", item.value)
           else
     2       code = code .. self:_transUse({modules = {item.value}})
     2       code = code .. string.format("export {%s};", item.value.name)
           end
         end

         --(2) return
     3   return code
       end

       --Transform an export statement.
       --
       --@return string
     1 function StmtTrans:_transExport(stmt)
     1   local trans = self._.trans
         local code

         --(1) transform
     1   code = "export default " .. trans:_trans(stmt.exp) .. ";"

         --(2) return
     1   return code
       end

       --Transform a with statement.
       --
       --@return string
     1 function StmtTrans:_transWith(stmt)
     1   local trans = self._.trans
         local var, code

         --(1) transform
     1   var = self:_getRandomName()

     1   code = string.format("const %s = %s;", var, trans:_trans(stmt.value))

     3   for ix, cls in ipairs(stmt.ifs) do
     4     code = code .. string.format(
     2       "%sif (%s == %s) %s",
     2       ix == 1 and "" or " else ",
     2       var,
     2       trans:_trans(cls.cond),
     2       self:_transBody(cls.body)
           )
         end

     1   if stmt.els then
     1     code = code .. " else " .. self:_transBody(stmt.els)
         end

         --(2) return
     1   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/SubTrans.lua
==============================================================================
       --A sub transformer.
     1 local SubTrans = {}
     1 SubTrans.__index = SubTrans
     1 package.loaded[...] = SubTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function SubTrans.new(trans)
  2384   return setmetatable({
  1192     _ = {
  1192       trans = trans
  1192     }
  2384   }, SubTrans)
       end

       --Last seed used.
     1 local lastSeed = os.time()

       --Return a random name.
       --
       --@return string
     1 function SubTrans._getRandomName()
     7   lastSeed = math.random(1, lastSeed)
     7   math.randomseed(lastSeed)
     7   return "$aux" .. os.time() .. math.random(1, 10000)
       end

       --Transform a data access.
       --
       --@param def:DataAccess
       --@return string, string
     1 function SubTrans:_transDataAccess(def)
         local prefix

    27   if def.mod == "." then
     3     prefix = "this."
    24   elseif def.mod == ":" then
     3     prefix = "this._"
         else
    21     prefix = ""
         end

    27   return prefix .. def.name:gsub(":", "._")
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/UnpackTrans.lua
==============================================================================
       --imports
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --An unpack sentence transformer.
     1 local UnpackTrans = {}
     1 UnpackTrans.__index = UnpackTrans
     1 setmetatable(UnpackTrans, {__index = SubTrans})
     1 package.loaded[...] = UnpackTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function UnpackTrans.new(trans)
   298   return setmetatable(SubTrans.new(trans), UnpackTrans)
       end

       --Transform an unpack sentence.
       --
       --@param sent:Unpack  Sentence to transform.
       --@return string
     1 function UnpackTrans:transform(sent)
    15   if sent.subtype == "[]" then
    10     if sent.assign == "=" then
     5       return self:_transList(sent)
     5     elseif sent.assign == ":=" then
     1       return self:_transReadOnlyFieldsList(sent)
     4     elseif sent.assign == ".=" then
     3       return self:_transPropList(sent)
           else
     1       return self:_transOptionalList(sent)
           end
     5   elseif sent.subtype == "{}" then
     5     if sent.assign == "=" then
     4       return self:_transMap(sent)
           else
     1       return self:_transReadOnlyFieldsMap(sent)
           end
         end
       end

       --Transform [...] = Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transList(sent)
     5   local trans = self._.trans
         local code

         --(1) variables
     5   code = "["

    18   for i, def in ipairs(sent.vars) do
    13     local var = self:_transDataAccess(def)

    26     code = code .. (i == 1 and "" or ", ") .. string.format(
    13       "%s%s%s",
    13       def.mod == "..." and "..." or "",
    13       var,
    13       def.value and (" = " .. trans:_trans(def.value)) or ""
    11     )
         end

     5   code = code .. "]"

         --(4) expression
    10   code = code .. string.format(
     5     " = dogma.getArrayToUnpack(%s, %s);",
     5     trans:_trans(sent.exp),
     5     #sent.vars
         )

         --(5) return
     5   return code
       end

       --Transform [...] := Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transReadOnlyFieldsList(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     2   code = string.format(
     1     "const %s = dogma.getArrayToUnpack(%s, %s);",
     1     valVar,
     1     trans:_trans(sent.exp),
     1     #sent.vars
     1   )

         --(2) unpack
     6   for ix, fld in ipairs(sent.vars) do
     5     local name = fld.name:gsub(":", "._")

     5     if fld.mod == "." then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "%s", {value: %s[%s], enum: true});',
     1         name,
     1         valVar,
     1         ix - 1
     1       )
     4     elseif fld.mod == ":" then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "_%s", {value: %s[%s]});',
     1         name,
     1         valVar,
     1         ix - 1
     1       )
           else
     3       code = code .. string.format('%s = %s[%s];', name, valVar, ix - 1)
           end
         end

         --(3) return
     1   return code
       end

       --Transform [...] ?= Exp
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transOptionalList(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     2   code = string.format(
     1     "const %s = dogma.getArrayToUnpack(%s, %s);",
     1     valVar,
     1     trans:_trans(sent.exp),
     1     #sent.vars
     1   )

         --(2) unpack
     1   local left, right = "", ""

     6   for ix, def in ipairs(sent.vars) do
     5     local js = self:_transDataAccess(def)

     5     if ix > 1 then
     4       left = left .. ", "
     4       right = right .. ", "
           end

     5     left = left .. js
    10     right = right .. string.format(
     5       "%s != null ? %s : %s[%s]",
     5       js,
     5       js,
     5       valVar,
     5       ix - 1
           )
         end

     1   code = code .. string.format("[%s] = [%s];", left, right)

         --(3) return
     1   return code
       end

       --Transform [...] .= Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transPropList(sent)
     3   local trans = self._.trans
         local code, valVar

         --(1) list value
     3   valVar = self:_getRandomName()
     6   code = string.format(
     3     "const %s = dogma.getArrayToUnpack(%s, %s);",
     3     valVar,
     3     trans:_trans(sent.exp),
     3     #sent.vars
     3   )

         --(2) unpack
     9   for ix, def in ipairs(sent.vars) do
     6     if def.name:find("[:.]") then
     2       local obj = def.name:match("(.+)[:.][^:.]+$")
     2       local fld = def.name:match(".+[:.]([^:.]+)$")

     4       code = code .. string.format(
     2         'Object.defineProperty(%s, "_%s", {value: %s[%s], writable: true});',
     2         obj,
     2         fld,
     2         valVar,
     2         ix - 1
             )

     4       code = code .. string.format(
     2         'Object.defineProperty(%s, "%s", {enum: true, get() { return %s._%s; }});',
     2         obj,
     2         fld,
     2         obj,
               fld
     4       )
           else
     8       code = code .. string.format(
     4         'Object.defineProperty(this, "_%s", {value: %s[%s], writable: true});',
     4         def.name,
     4         valVar,
     4         ix - 1
             )

     8       code = code .. string.format(
     4         'Object.defineProperty(this, "%s", {enum: true, get() { return this._%s; }});',
     4         def.name,
               def.name
     4       )
           end
         end

         --(3) return
     3   return code
       end

       --Transform {...} = Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transMap(sent)
     4   local trans = self._.trans
         local code

         --(1) variables
     4   code = "({"

    13   for i, var in ipairs(sent.vars) do
    18     code = code .. (i == 1 and "" or ", ") .. string.format(
     9       "%s: %s%s",
     9       var.name,
     9       self:_transDataAccess(var),
     9       var.value and (" = " .. trans:_trans(var.value)) or ""
     7     )
         end

     4   code = code .. "}"

         --(2) expression
     4   code = code .. " = " .. trans:_trans(sent.exp) .. ");"

         --(3) return
     4   return code
       end

       --Transform {...} := Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transReadOnlyFieldsMap(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     1   code = string.format("const %s = %s;", valVar, trans:_trans(sent.exp))

         --(2) unpack
     4   for _, fld in ipairs(sent.vars) do
     3     local name = fld.name

     3     if fld.mod == "." then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "%s", {value: %s["%s"], enum: true});',
     1         name,
     1         valVar,
               name
     2       )
     2     elseif fld.mod == ":" then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "_%s", {value: %s["%s"]});',
     1         name,
     1         valVar,
               name
     2       )
           else
     1       code = code .. string.format('%s = %s["%s"];', name, valVar, name)
           end
         end

         --(3) return
     1   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/util.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")

     1 package.loaded[...] = {
         transName = function(name)
   488     local KEYWORDS = {
   488       "abstract", "await",
   488       "break",
   488       "case", "char", "class", "const", "continue",
   488       "debugger", "do",
   488       "else", "enum", "export", "extends",
   488       "final", "finally", "for", "function",
   488       "goto",
   488       "if", "implements", "import", "in", "instanceof", "interface",
   488       "let",
   488       "native", "new",
   488       "private", "protected", "public",
   488       "return",
   488       "static", "super", "switch",
   488       "this", "throw", "transient", "try", "typeof",
   488       "var", "volatile",
   488       "while", "with",
             "yield"
   488     }

   488     if tablex.find(KEYWORDS, name) then
     5       return name .. "_"
           else
   483       return name
           end
         end
     1 }

==============================================================================
Summary
==============================================================================

File                                                                 Hits Missed Coverage
-----------------------------------------------------------------------------------------
/home/me/.luarocks/share/lua/5.3/dogma/lex/Lexer.lua                 452  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/LiteralType.lua           4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/TokenType.lua             10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/AdvancedList.lua        21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Annotation.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Char.lua                9    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Comment.lua             10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Directive.lua           10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Eol.lua                 10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Id.lua                  7    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Keyword.lua             63   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Literal.lua             12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Name.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/ProcessedList.lua       21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Reader.lua              51   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Symbol.lua              10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Token.lua               10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveParser.lua       43   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveType.lua         4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/ExpParser.lua             481  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/NodeType.lua              4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/NonTerminalType.lua       4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/Parser.lua                107  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/SentType.lua              6    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtParser.lua            586  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtType.lua              22   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/TerminalType.lua          23   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/UnpackParser.lua          71   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AsyncStmt.lua           12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AwaitFn.lua             12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BinOp.lua               18   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BlockParser.lua         34   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BreakStmt.lua           8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CallOp.lua              15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CatchCl.lua             8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ConstStmt.lua           11   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DataAccess.lua          5    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Directive.lua           10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DoStmt.lua              13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/EnumStmt.lua            19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Exp.lua                 15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ExportStmt.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FinallyCl.lua           7    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FnStmt.lua              18   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForEachStmt.lua         15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForStmt.lua             15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FromStmt.lua            13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfDirective.lua         12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfStmt.lua              15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfSubExp.lua            19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IifFn.lua               19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralFn.lua           28   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralList.lua         14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralMap.lua          14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NaryOp.lua              22   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NativeFn.lua            12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NextStmt.lua            8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Node.lua                9    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NonTerminal.lua         14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ObjectStmt.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Op.lua                  83   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PackOp.lua              18   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Param.lua               13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Params.lua              12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PawaitFn.lua            12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PevalFn.lua             12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PubStmt.lua             17   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ReturnStmt.lua          20   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/RunWithDirective.lua    10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Sent.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SliceOp.lua             15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Stmt.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubExp.lua              10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubParser.lua           17   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SyntaxTree.lua          75   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Terminal.lua            16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ThrowFn.lua             16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/TypeStmt.lua            16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UnaryOp.lua             29   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Unpack.lua              13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UpdateOp.lua            26   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseFn.lua               12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseStmt.lua             29   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmt.lua             11   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmtParser.lua       116  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WhileStmt.lua           14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WithStmt.lua            12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/YieldStmt.lua           12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/Trans.lua               12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/Trans.lua            43   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/DirectiveTrans.lua 27   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/ExpTrans.lua       361  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/StmtTrans.lua      567  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/SubTrans.lua       21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/UnpackTrans.lua    156  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/util.lua           24   0      100.00%
-----------------------------------------------------------------------------------------
Total                                                                4392 0      100.00%
