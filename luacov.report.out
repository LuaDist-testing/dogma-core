==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/Lexer.lua
==============================================================================
       --imports
     1 local stringx = require("pl.stringx")
     1 local Reader = require("dogma.lex._.Reader")
     1 local ProcessedList = require("dogma.lex._.ProcessedList")
     1 local AdvancedList = require("dogma.lex._.AdvancedList")
     1 local Eol = require("dogma.lex._.Eol")
     1 local Annotation = require("dogma.lex._.Annotation")
     1 local Comment = require("dogma.lex._.Comment")
     1 local Directive = require("dogma.lex._.Directive")
     1 local Name = require("dogma.lex._.Name")
     1 local Keyword = require("dogma.lex._.Keyword")
     1 local Literal = require("dogma.lex._.Literal")
     1 local LiteralType = require("dogma.lex.LiteralType")
     1 local Symbol = require("dogma.lex._.Symbol")
     1 local TokenType = require("dogma.lex.TokenType")

       --A lexer os scanner.
     1 local Lexer = {}
     1 Lexer.__index = Lexer
     1 package.loaded[...] = Lexer

       --Constructor.
       --
       --@param props:object Lexer properties.
     1 function Lexer.new(props)
         local self

         --(1) arguments
   663   if not props then props = {} end

         --(2) create
  1326   self = setmetatable({
   663     _ = {
   663       comments = not not props.comments
   663     }
  1326   }, Lexer)

         --(3) return
   663   return self
       end

       --Scan a text.
       --
       --@param text:string  Text to analyze.
       --@param file?:string File path.
       --
       --@return self
     1 function Lexer:scan(text, file)
         --(1) arguments
   664   if not text then error("text expected.") end

         --(2) init
   663   self._.reader = Reader.new(text)
   663   self._.file = file or "anonymous code"
   663   self._.processed = ProcessedList.new(3)
   663   self._.token = nil
   663   self._.advanced = AdvancedList.new(3)

         --(3) return
   663   return self
       end

       --Return the last token that has been read.
       --
       --@return Token
     1 function Lexer:_getLastReadToken()
  1852   return self._.token
       end

       --Scan the next token.
       --
       --@overload
       --@return Token
       --
       --@overload
       --@param typ:TokenType  Token type to read.
       --@param val:string     Token value to read.
       --@return Token
     1 function Lexer:next(typ, val)
  9298   local reader = self._.reader
         local tok

         --(1) get token to return
  9298   if self:_hasTokenToShift() then
  3483     self:_shift()
         else
           local ch

           --get next char
  5815     ch = reader:next()

  7531     while ch ~= nil and (ch.char == " " or ch.char == "\t") do
  1716       ch = reader:next()
           end

  5815     if ch ~= nil then
  4930       ch = ch.char

             --analyze token
  4930       reader:unshift()

  4930       if ch == "\n" then
   828         tok = self:_scanEol()
  4102       elseif ch == "@" then
    14         tok = self:_scanAnnotation()
  4088       elseif ch == "_" or stringx.isalpha(ch) then
  1852         tok = self:_scanId()
  2236       elseif ch == "'" then
     1         tok = self:_scanName()
  2235       elseif stringx.isdigit(ch) then
   475         tok = self:_scanLiteralNumber()
  1760       elseif ch == '"' then
    86         tok = self:_scanLiteralString()
  1674       elseif ch == "#" then
    48         reader:next()
    48         ch = reader:next().char

    48         reader:unshift()
    48         reader:unshift()

    48         if ch == "!" then
    43           tok = self:_scanDirective()
               else
     5           tok = self:_scanComment()

     5           if not self._.comments then
     1             return self:next()
                 end
               end
             else
  1626         tok = self:_scanSymbol()
             end

  4920       self:_backUpToken()
  4920       self._.token = tok
           else
   885       self:_backUpToken()
   885       self._.token = nil
           end
         end

         --(2) check
  9288   if typ then
  1876     tok = self._.token

  1876     if tok == nil then
     2       error(string.format("'%s' expected at the end of code.", val))
           end

  1874     if tok.type ~= typ or (val ~= nil and tok.value ~= val) then
    16       if typ == TokenType.EOL then
     4         error(string.format(
     2           "end of line expected on (%s, %s).",
     2           tok.line,
                 tok.col
     2         ))
    14       elseif typ == TokenType.NAME then
     6         error(string.format(
     3           "name expected on (%s, %s).",
     3           tok.line,
                 tok.col
     3         ))
    11       elseif typ == TokenType.LITERAL then
     2         error(string.format(
     1           "literal expected on (%s, %s).",
     1           tok.line,
                 tok.col
     1         ))
             else
    20         error(string.format(
    10           "'%s' expected on (%s, %s).",
    10           val,
    10           tok.line,
                 tok.col
    10         ))
             end
           end
         end

         --(3) return
  9270   return self._.token
       end

       --Advance the next token.
       --
       --@return Token
     1 function Lexer:advance(i)
         local tok

         --(1) arguments
  6346   if i == nil then
  6207     i = 1
         end

         --(2) get token
  6346   if #self._.advanced >= i then
  2990     tok = self._.advanced._.items[i]
         else
  3356     if i == 1 then
  3219       tok = self:next()
  3219       self:unshift()
   137     elseif i == 2 then
   115       self:next()
   115       tok = self:next()
   115       self:unshift()
   115       self:unshift()
    22     elseif i == 3 then
    22       self:next()
    22       self:next()
    22       tok = self:next()
    22       self:unshift()
    22       self:unshift()
    22       self:unshift()
           end
         end

         --(3) return
  6346   return tok
       end

       --Check whether the lexer has some token to shift.
       --
       --@return bool
     1 function Lexer:_hasTokenToShift()
  9298   return #self._.advanced > 0
       end

       --Shift a token: <- processed <- current <- advanced
     1 function Lexer:_shift()
         --(1) pre
  3484   if #self._.advanced == 0 then
     1     error("no advanced token to shift.")
         end

         --(2) current to processed
  3483   if self._.token then
  2779     self._.processed:insert(self._.token)
         end

         --(3) advanced to current
  3483   self._.token = self._.advanced:remove()
       end

       --Unshift a char: processed -> current -> advanced
     1 function Lexer:unshift()
         --(1) pre
  4482   if not self._.token and #self._.processed == 0 then
     1     error("no current token to unshift.")
         end

         --(2) current to advanced
  4481   self._.advanced:insert(self._.token)

         --(3) last processed to current
  4481   if #self._.processed == 0 then
   706     self._.token = nil
         else
  3775     self._.token = self._.processed:remove()
         end
       end

       --Shift current token to processed tokens: processed <- token.
     1 function Lexer:_backUpToken()
  5805   if self._.token then
  5158     self._.processed:insert(self._.token)
         end
       end

       --Scan an end of line.
       --
       --@return Eol
     1 function Lexer:_scanEol()
   828   local reader = self._.reader
   828   local ch = reader:next()

   828   return Eol.new(ch.line, ch.col)
       end

       --Scan an annotation.
       --
       --@return Annotation
     1 function Lexer:_scanAnnotation()
    14   local rdr = self._.reader
         local state, ln, col, val
    14   local State = {
    14     START = 1,
    14     VALUE = 2,
    14     END = 3
         }

         --(1) state machine
    14   state = State.START

   124   while state ~= State.END do
   110     local ch = rdr:next()

   110     if state == State.START then
    14       ln, col, val = ch.line, ch.col, ""
    14       state = State.VALUE
    96     elseif state == State.VALUE then
    96       ch = ch.char

    96       if not (stringx.isalnum(ch) or ch == "_") then
    14         rdr:unshift()
    14         state = State.END
             else
    82         val = val .. ch
             end
           end
         end

         --(2) return
    14   return Annotation.new(ln, col, val)
       end

       --Scan a directive.
       --
       --@return Directive
     1 function Lexer:_scanDirective()
    43   local rdr = self._.reader
         local state, ln, col, val
    43   local State = {
    43     START1 = 1,
    43     START2 = 2,
    43     VALUE = 3,
    43     END = 4
         }

         --(1) state machine
    43   state = State.START1

   526   while state ~= State.END do
   483     local ch = rdr:next()

   483     if state == State.START1 then
    43       ln, col, val = ch.line, ch.col, ""
    43       state = State.START2
   440     elseif state == State.START2 then
    43       state = State.VALUE
   397     elseif state == State.VALUE then
   397       ch = ch.char

   397       if ch == "\n" then
    43         state = State.END
             else
   354         val = val .. ch
             end
           end
         end

    43   if not (val:find("^if [a-zA-Z]+ then$") or val:find("^if not [a-zA-Z]+ then$") or val:find("^/") or val == "end" or val == "else") then
     2     error(string.format("on (%s,%s), invalid directive.", ln, col))
         end

         --(2) return
    41   return Directive.new(ln, col, val)
       end

       --Scan a comment.
       --
       --@return Comment
     1 function Lexer:_scanComment()
     5   local reader = self._.reader
         local state, ln, col, comm
     5   local State = {
     5     START = 1,
     5     TEXT = 2,
     5     POSSIBLE_END = 3,
     5     END = 4
         }

         --(1) state machine
     5   state = State.START

   120   while state ~= State.END do
   115     local ch = reader:next()

   115     if state == State.START then
     5       ln, col, comm = ch.line, ch.col, ""
     5       state = State.TEXT
   110     elseif state == State.TEXT then
   104       ch = ch.char

   104       if ch == "\n" then
     6         state = State.POSSIBLE_END
             else
    98         comm = comm .. ch
             end
           else  --POSSIBLE_END
     6       if ch == nil then
     4         reader:unshift()  --current: nil
     4         reader:unshift()  --end of line
     4         state = State.END
             else
     2         ch = ch.char

     2         if ch == "#" then
     1           comm = comm .. "\n"
     1           state = State.TEXT
               else
     1           reader:unshift()  --current char
     1           reader:unshift()  --eol
     1           state = State.END
               end
             end
           end
         end

         --(2) return
     5   return Comment.new(ln, col, comm)
       end

       --Scan an identifier.
       --
       --@return Id
     1 function Lexer:_scanId()
  1852   local reader = self._.reader
         local state, ln, col, id
  1852   local State = {
  1852     START = 1,
  1852     MIDDLE = 2,
  1852     END = 3
         }

         --(1) state machine
  1852   state = State.START

  8558   while state ~= State.END do
  6706     local ch = reader:next()

  6706     if state == State.START then
  1852       ln, col = ch.line, ch.col
  1852       id = ch.char
  1852       state = State.MIDDLE
           else
  4854       ch = ch.char

  4854       if ch == "_" or stringx.isalnum(ch) then
  3002         id = id .. ch
             else
  1852         state = State.END
  1852         reader:unshift()
             end
           end
         end

         --(2) return
  1852   local last = self:_getLastReadToken()

  1852   if (last and last.type == TokenType.SYMBOL and (last.value == "." or last.value == ":")) or
  1730      not Keyword.isKeyword(id) then
  1206     return Name.new(ln, col, id)
         else
   646     return Keyword.new(ln, col, id)
         end
       end

       --Scan a name.
       --
       --@return Name
     1 function Lexer:_scanName()
     1   local reader = self._.reader
         local state, ln, col, id, ch
     1   local State = {
     1     START = 1,
     1     ID = 2,
     1     END = 3
         }

         --(1) state machine
     1   state = State.START
     1   ch = reader:next()  --'
     1   ln, col = ch.line, ch.col

     9   while state ~= State.END do
     8     ch = reader:next()

     8     if state == State.START then
     1       id = ch.char
     1       state = State.ID
           else --State.ID
     7       ch = ch.char

     7       if ch == "'" then
     1         state = State.END
             else
     6         id = id .. ch
             end
           end
         end

         --(2) return
     1   return Name.new(ln, col, id)
       end

       --Scan a symbol.
       --
       --@return Symbol
     1 function Lexer:_scanSymbol()
  1626   local reader = self._.reader
         local state, ln, col, sym
  1626   local State = {
  1626     START = 1,
  1626     MIDDLE = 2,
  1626     END = 3
         }
  1626   local SYMBOLS = {
  1626     ["+"] = true,
  1626     ["+="] = true,
  1626     ["-"] = true,
  1626     ["-="] = true,
  1626     ["->"] = true,
  1626     ["*"] = true,
  1626     ["*="] = true,
  1626     ["**"] = true,
  1626     ["**="] = true,
  1626     ["/"] = true,
  1626     ["/="] = true,
  1626     ["%"] = true,
  1626     ["%="] = true,
  1626     ["="] = true,
  1626     ["=="] = true,
  1626     ["==="] = true,
  1626     ["!"] = true,
  1626     ["!="] = true,
  1626     ["!=="] = true,
  1626     ["<"] = true,
  1626     ["<<"] = true,
  1626     ["<<="] = true,
  1626     ["<="] = true,
  1626     [">"] = true,
  1626     [">>"] = true,
  1626     [">>="] = true,
  1626     [">="] = true,
  1626     ["^"] = true,
  1626     ["^="] = true,
  1626     ["~"] = true,
  1626     ["~="] = true,
  1626     ["("] = true,
  1626     [")"] = true,
  1626     ["["] = true,
  1626     ["]"] = true,
  1626     ["{"] = true,
  1626     ["}"] = true,
  1626     [";"] = true,
  1626     [":"] = true,
  1626     [":="] = true,
  1626     [":=|"] = true,
  1626     ["."] = true,
  1626     [".."] = true,
  1626     ["..."] = true,
  1626     [".="] = true,
  1626     ["?"] = true,
  1626     ["?="] = true,
  1626     ["&"] = true,
  1626     ["&="] = true,
  1626     ["&&"] = true,
  1626     ["|"] = true,
  1626     ["|="] = true,
  1626     ["||"] = true,
  1626     [","] = true
         }

         --(1) state machine
  1626   state = State.START

  5025   while state ~= State.END do
  3399     local ch = reader:next()

  3399     if state == State.START then
  1626       if SYMBOLS[ch.char] then
  1624         ln, col, sym = ch.line, ch.col, ch.char
  1624         state = State.MIDDLE
             else
     2         reader:unshift()
     2         state = State.END
             end
           else
  1773       if SYMBOLS[sym .. ch.char] then
   149         sym = sym .. ch.char
             else
  1624         reader:unshift()
  1624         state = State.END
             end
           end
         end

         --(2) return
  1626   if sym == nil then
     2     error(string.format("invalid symbol on (%s, %s).", reader._.line, reader._.col - 1))
         end

  1624   return Symbol.new(ln, col, sym)
       end

       --Scan a literal hnumber.
       --
       --@return Literal
     1 function Lexer:_scanLiteralNumber()
   475   local reader = self._.reader
         local state, ln, col, lit
   475   local State = {
   475     START = 1,
   475     INT = 2,
   475     DOT = 3,
   475     DECIMAL = 4,
   475     END = 5
         }

         --(1) state machine
   475   state = State.START

  1759   while state ~= State.END do
  1284     local ch = reader:next()

  1284     if state == State.START then
   475       ln, col, lit = ch.line, ch.col, ch.char
   475       state = State.INT
   809     elseif state == State.INT then
   799       ch = ch.char

   799       if stringx.isdigit(ch) then
   250         lit = lit .. ch
   549       elseif ch == " " then
    74         lit = lit --nothing to do
   475       elseif ch == "." then
     4         state = State.DOT
             else
   471         reader:unshift()
   471         state = State.END
             end
    10     elseif state == State.DOT then
     4       ch = ch.char

     4       if stringx.isdigit(ch) then
     2         lit = lit .. "." .. ch
     2         state = State.DECIMAL
             else
     2         reader:unshift() --current
     2         reader:unshift() --dot
     2         state = State.END
             end
           else  --DECIMAL
     6       ch = ch.char

     6       if stringx.isdigit(ch) then
     4         lit = lit .. ch
             else
     2         reader:unshift()
     2         state = State.END
             end
           end
         end

         --(2) return
   475   return Literal.new(ln, col, LiteralType.NUMBER, tonumber(lit))
       end

       --Scan a literal string.
       --
       --@return Literal
     1 function Lexer:_scanLiteralString()
    86   local reader = self._.reader
         local state, ln, col, lit
    86   local State = {
    86     START = 1,
    86     START1 = 2,
    86     START2 = 3,
    86     TEXT1 = 4,
    86     TEXT3 = 5,
    86     END1 = 6,
    86     END2 = 7,
    86     END = 8
         }

         --(1) state machine
    86   state = State.START

   777   while state ~= State.END do
   696     local ch = reader:next()

   696     if state == State.START then
    86       ln, col, lit = ch.line, ch.col, ""
    86       state = State.START1
   610     elseif state == State.START1 then
    86       ch = ch.char

    86       if ch == '"' then
     5         state = State.START2
             else
    81         lit = lit .. ch
    81         state = State.TEXT1
             end
   524     elseif state == State.START2 then
     5       ch = ch.char

     5       if ch == '"' then
     4         state = State.TEXT3
             else
     1         reader:unshift()
     1         state = State.END
             end
   519     elseif state == State.TEXT1 then  --"literal"
   491       if ch == nil then
     2         error(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

   489       ch = ch.char

   489       if ch == '"' then
    79         state = State.END
             else
   410         lit = lit .. ch
             end
    28     elseif state == State.TEXT3 then  --"""literal"""
    22       if ch == nil then
     2         error(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

    20       ch = ch.char

    20       if ch == '"' then
     3         state = State.END1
             else
    17         lit = lit .. ch
             end
     6     elseif state == State.END1 then
     3       ch = ch.char

     3       if ch == '"' then
     2         state = State.END2
             else
     1         lit = lit .. '"' .. ch
     1         state = State.TEXT3
             end
           else  --State.END2
     3       if ch == nil then
     1         error(string.format("literal string opened but not closed on (%s, %s).", ln, col))
             end

     2       ch = ch.char

     2       if ch == '"' then
     1         state = State.END
             else
     1         lit = lit .. '""' .. ch
             end
           end
         end

         --(2) return
    81   return Literal.new(ln, col, LiteralType.STRING, lit)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/LiteralType.lua
==============================================================================
     1 return {
     1   STRING = 1,
     1   NUMBER = 2
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/TokenType.lua
==============================================================================
     1 return {
     1   COMMENT = 1,
     1   EOL = 2,
     1   NAME = 3,
     1   KEYWORD = 4,
     1   LITERAL = 5,
     1   SYMBOL = 6,
     1   DIRECTIVE = 7,
     1   ANNOTATION = 8
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/AdvancedList.lua
==============================================================================
     1 local AdvancedList = {}
     1 AdvancedList.__index = AdvancedList
     1 package.loaded[...] = AdvancedList

     1 function AdvancedList.new(max)
         --(1) arguments
  1351   if max == nil then error("max expected.") end

         --(2) return
  2700   return setmetatable({
  1350     _ = {
  1350       max = max,
  1350       items = {}
  1350     }
  2700   }, AdvancedList)
       end

     1 function AdvancedList:__len()
 75278   return #self._.items
       end

     1 function AdvancedList:insert(item)
 13506   if #self == self._.max then
     1     error("list already full.")
         end

 13505   table.insert(self._.items, 1, item)
       end

     1 function AdvancedList:remove()
 12393   if #self == 0 then
     1     error("empty list, nothing to remove.")
         end

 12392   return table.remove(self._.items, 1)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Annotation.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --An annotation.
     1 local Annotation = {}
     1 Annotation.__index = Annotation
     1 setmetatable(Annotation, {__index = Token})
     1 package.loaded[...] = Annotation

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param val:string
     1 function Annotation.new(ln, col, val)
    14   return setmetatable(Token.new(TokenType.ANNOTATION, ln, col, val), Annotation)
       end

       --@override
     1 function Annotation:__tostring()
     7   return string.format("<annotation>%s</annotation>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Char.lua
==============================================================================
       --A character.
     1 local Char = {}
     1 Char.__index = Char
     1 package.loaded[...] = Char

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param ch:char    Character.
     1 function Char.new(ln, col, ch)
 23050   return setmetatable({
 11525     line = ln,
 11525     col = col,
 11525     char = ch
 23050   }, Char)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Comment.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A comment.
     1 local Comment = {}
     1 Comment.__index = Comment
     1 setmetatable(Comment, {__index = Token})
     1 package.loaded[...] = Comment

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param text:string  Comment text.
     1 function Comment.new(ln, col, text)
     5   return setmetatable(Token.new(TokenType.COMMENT, ln, col, text), Comment)
       end

       --@override
     1 function Comment:__tostring()
    20   return string.format("<comment>%s</comment>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Directive.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A comilation directive.
     1 local Directive = {}
     1 Directive.__index = Directive
     1 setmetatable(Directive, {__index = Token})
     1 package.loaded[...] = Directive

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param val:string
     1 function Directive.new(ln, col, val)
    41   return setmetatable(Token.new(TokenType.DIRECTIVE, ln, col, val), Directive)
       end

       --@override
     1 function Directive:__tostring()
    35   return string.format("<directive>%s</directive>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Eol.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --An end of line.
     1 local Eol = {}
     1 Eol.__index = Eol
     1 setmetatable(Eol, {__index = Token})
     1 package.loaded[...] = Eol

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function Eol.new(ln, col)
   828   return setmetatable(Token.new(TokenType.EOL, ln, col, "\n"), Eol)
       end

     1 function Eol:__tostring()
    91   return "<eol/>"
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Id.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")

       --An identifier.
     1 local Id = {}
     1 Id.__index = Id
     1 setmetatable(Id, {__index = Token})
     1 package.loaded[...] = Id

       --Constructor.
       --
       --@param t:string   Token type.
       --@param ln:number  Line number.
       --@param col:number Column number
       --@param id:string  Identifier.
     1 function Id.new(t, ln, col, id)
  1859   return setmetatable(Token.new(t, ln, col, id), Id)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Keyword.lua
==============================================================================
       --imports
     1 local Id = require("dogma.lex._.Id")
     1 local TokenType = require("dogma.lex.TokenType")

       --A keyword.
     1 local Keyword = {}
     1 Keyword.__index = Keyword
     1 setmetatable(Keyword, {__index = Id})
     1 package.loaded[...] = Keyword

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param id:string  Identifier.
     1 function Keyword.new(ln, col, id)
   652   return setmetatable(Id.new(TokenType.KEYWORD, ln, col, id), Keyword)
       end

       --Check whether an identifier is a keyword.
       --
       --@param id:string  Identifier to check.
       --@return bool
     1 function Keyword.isKeyword(id)
  1730   local KEYWORDS = {
  1730     ["and"] = true,
  1730     ["as"] = true,
  1730     ["async"] = true,
  1730     ["await"] = true,
  1730     ["break"] = true,
  1730     ["catch"] = true,
  1730     ["const"] = true,
  1730     ["do"] = true,
  1730     ["dogma"] = true,
  1730     ["each"] = true,
  1730     ["else"] = true,
  1730     ["end"] = true,
  1730     ["enum"] = true,
  1730     ["export"] = true,
  1730     ["extern"] = true,
  1730     ["false"] = true,
  1730     ["finally"] = true,
  1730     ["fn"] = true,
  1730     ["for"] = true,
  1730     ["from"] = true,
  1730     ["if"] = true,
  1730     ["impl"] = true,
  1730     ["in"] = true,
  1730     ["is"] = true,
  1730     ["like"] = true,
  1730     ["native"] = true,
  1730     ["next"] = true,
  1730     ["nil"] = true,
  1730     ["nop"] = true,
  1730     ["not"] = true,
  1730     ["op"] = true,
  1730     ["or"] = true,
  1730     ["peval"] = true,
  1730     ["pub"] = true,
  1730     ["pvt"] = true, --private
  1730     ["return"] = true,
  1730     ["self"] = true,
  1730     ["Self"] = true,
  1730     ["super"] = true,
  1730     ["then"] = true,
  1730     ["throw"] = true,
  1730     ["true"] = true,
  1730     ["type"] = true,
  1730     ["use"] = true,
  1730     ["var"] = true,
  1730     ["while"] = true,
  1730     ["with"] = true,
  1730     ["yield"] = true
         }

  1730   return KEYWORDS[id] or false
       end

       --@override
     1 function Keyword:__tostring()
    10   return string.format("<keyword>%s</keyword>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Literal.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A literal.
     1 local Literal = {}
     1 Literal.__index = Literal
     1 setmetatable(Literal, {__index = Token})
     1 package.loaded[...] = Literal

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param t:string     Literal type: number, string...
       --@param val:any      Literal value.
     1 function Literal.new(ln, col, t, val)
         local self

         --(1) create
   556   self = setmetatable(Token.new(TokenType.LITERAL, ln, col, val), Literal)
   556   self.subtype = t

         --(2) return
   556   return self
       end

       --@override
     1 function Literal:__tostring()
   156   return string.format("<literal type='%s'>%s</literal>", self.type, self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Name.lua
==============================================================================
       --imports
     1 local Id = require("dogma.lex._.Id")
     1 local TokenType = require("dogma.lex.TokenType")

       --An identifier.
     1 local Name = {}
     1 Name.__index = Id
     1 setmetatable(Name, {__index = Id})
     1 package.loaded[...] = Name

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number
       --@param id:string  Identifier.
     1 function Name.new(ln, col, id)
  1207   return setmetatable(Id.new(TokenType.NAME, ln, col, id), Id)
       end

       --@override
     1 function Id:__tostring()
   112   return string.format("<name>%s</name>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/ProcessedList.lua
==============================================================================
     1 local List = {}
     1 List.__index = List
     1 package.loaded[...] = List

     1 function List.new(max)
         --(1) arguments
  1351   if max == nil then error("max expected.") end

         --(2) return
  2700   return setmetatable({
  1350     _ = {
  1350       max = max,
  1350       items = {}
  1350     }
  2700   }, List)
       end

     1 function List:__len()
 53894   return #self._.items
       end

     1 function List:insert(item)
 27398   if #self == self._.max then
 12298     table.remove(self._.items, 1)
         end

 27398   table.insert(self._.items, item)
       end

     1 function List:remove()
 12110   if #self == 0 then
     1     error("internal error: invalid remove from previous list.")
         end

 12109   return table.remove(self._.items)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Reader.lua
==============================================================================
       --imports
     1 local stringx = require("pl.stringx")
     1 local Char = require("dogma.lex._.Char")
     1 local ProcessedList = require("dogma.lex._.ProcessedList")
     1 local AdvancedList = require("dogma.lex._.AdvancedList")

       --A text reader.
     1 local Reader = {}
     1 Reader.__index = Reader
     1 package.loaded[...] = Reader

       --Constructor.
     1 function Reader.new(txt)
  1360   return setmetatable({
   680     _ = {
   680       text = stringx.split(txt, "\n"),
   680       line = 1,
   680       col = 1,
   680       processed = ProcessedList.new(3),
   680       char = nil,
   680       advanced = AdvancedList.new(3),
   680     }
  1360   }, Reader)
       end

       --Check whether the lexer has some char to shift.
       --
       --@return bool
     1 function Reader:_hasCharToShift()
 21322   return #self._.advanced > 0
       end

       --Read the next character.
       --
       --@return Char
     1 function Reader:next()
         --(1) read
 21322   if self:_hasCharToShift() then
  8901     self:_shift()
         else
 12421     local ln = self._.text[self._.line]

 12421     if ln then
 11525       if self._.col > #ln then
   909         self:_backUp()
   909         self._.char = Char.new(self._.line, self._.col, "\n")
   909         self._.line = self._.line + 1
   909         self._.col = 1
             else
 10616         self:_backUp()
 10616         self._.char = Char.new(self._.line, self._.col, ln:sub(self._.col, self._.col))
 10616         self._.col = self._.col + 1
             end
           else  --end of input
   896       self:_backUp()
   896       self._.char = nil
           end
         end

         --(2) return
 21322   return self._.char
       end

       --Shift a char: <- processed <- current <- advanced
     1 function Reader:_shift()
         --(1) pre
  8905   if #self._.advanced == 0 then
     1     error("no advanced char to shift.")
         end

         --(2) current to processed
  8904   if self._.char then
  8219     self._.processed:insert(self._.char)
         end

         --(3) advanced to current
  8904   self._.char = self._.advanced:remove()
       end

       --Unshift a char: processed -> current -> advanced
     1 function Reader:unshift()
         --(1) current to advanced
  9018   if self._.char then
  9013     self._.advanced:insert(self._.char)
         end

         --(2) last processed to current
  9018   if #self._.processed == 0 then
   689     self._.char = nil
         else
  8329     self._.char = self._.processed:remove()
         end
       end

       --Shift current char to processed chars: processed <- char.
     1 function Reader:_backUp()
 12421   if self._.char then
 11230     self._.processed:insert(self._.char)
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Symbol.lua
==============================================================================
       --imports
     1 local Token = require("dogma.lex._.Token")
     1 local TokenType = require("dogma.lex.TokenType")

       --A symbol.
     1 local Symbol = {}
     1 Symbol.__index = Symbol
     1 setmetatable(Symbol, {__index = Token})
     1 package.loaded[...] = Symbol

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param sym:string   Symbol.
     1 function Symbol.new(ln, col, sym)
  1624   return setmetatable(Token.new(TokenType.SYMBOL, ln, col, sym), Symbol)
       end

       --@override
     1 function Symbol:__tostring()
   495   return string.format("<symbol>%s</symbol>", self.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Token.lua
==============================================================================
       --A token.
     1 local Token = {}
     1 Token.__index = Token
     1 package.loaded[...] = Token

       --Constructor.
       --
       --@param t:TokenType  Token type.
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param val:any      Value.
     1 function Token.new(t, ln, col, val)
  9854   return setmetatable({
  4927     type = t,
  4927     line = ln,
  4927     col = col,
  4927     value = val
  9854   }, Token)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveParser.lua
==============================================================================
       --imports
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local IfDirective = require("dogma.syn._.IfDirective")
     1 local RunWithDirective = require("dogma.syn._.RunWithDirective")

       --A directive parser.
     1 local DirectiveParser = {}
     1 DirectiveParser.__index = DirectiveParser
     1 setmetatable(DirectiveParser, {__index = SubParser})
     1 package.loaded[...] = DirectiveParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function DirectiveParser.new(parser)
   555   return setmetatable(SubParser.new(parser), DirectiveParser)
       end

       --Read the next if directive.
       --
       --@return Directive
     1 function DirectiveParser:nextIf()
    14   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, el

         --(1) read if
    14   tok = lex:next(TokenType.DIRECTIVE)
    14   ln, col = tok.line, tok.col

    14   if tok.value:find("^if [a-zA-Z_0-9]+ then$") then
     9     cond = tok.value:match("^if ([a-zA-Z_0-9]+) then$")
         else
     5     cond = tok.value:match("^if (not [a-zA-Z_0-9]+) then$")
         end

    14   body = {}
         while true do
    55     tok = lex:advance()

    55     if tok == nil then
             break
    54     elseif tok.type == TokenType.EOL then
    21       lex:next()
           else
    33       if tok.type == TokenType.DIRECTIVE then
    13         if tok.value == "else" or tok.value == "end" then
                 break
               else
     1           error(string.format("on (%s,%s), if directive can't be nested.", tok.line, tok.col))
               end
             end

    20       table.insert(body, parser:next())
           end
         end

         --(2) read else
    13   tok = lex:advance()

    13   if tok and tok.type == TokenType.DIRECTIVE and tok.value == "else" then
     6     lex:next()

     6     el = {}
           while true do
    18       tok = lex:advance()

    18       if tok.type == TokenType.EOL then
     6         lex:next()
             else
    12         if tok.type == TokenType.DIRECTIVE then
     6           if tok.value == "end" then
                   break
                 else
     1             error(string.format("on (%s,%s), else directive can't be nested.", tok.line, tok.col))
                 end
               end

     6         table.insert(el, parser:next())
             end
           end
         end

         --(3) read end
    12   lex:next(TokenType.DIRECTIVE, "end")

         --(4) return
    11   return IfDirective.new(ln, col, cond, body, el)
       end

       --Read the next #!/... directive.
       --
       --@return RunWithDirective
     1 function DirectiveParser:nextRunWith()
     3   local lex = self._.lexer
         local tok

     3   tok = lex:next(TokenType.DIRECTIVE)
     3   return RunWithDirective.new(tok.line, tok.col, tok.value)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveType.lua
==============================================================================
     1 return {
     1   IF = "if",
     1   RUNWITH = "runWith"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/ExpParser.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local Keyword = require("dogma.lex._.Keyword")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local SubExp = require("dogma.syn._.SubExp")
     1 local IfSubExp = require("dogma.syn._.IfSubExp")
     1 local UnaryOp = require("dogma.syn._.UnaryOp")
     1 local BinOp = require("dogma.syn._.BinOp")
     1 local SliceOp = require("dogma.syn._.SliceOp")
     1 local CallOp = require("dogma.syn._.CallOp")
     1 local Exp = require("dogma.syn._.Exp")
     1 local LiteralList = require("dogma.syn._.LiteralList")
     1 local LiteralMap = require("dogma.syn._.LiteralMap")
     1 local LiteralFn = require("dogma.syn._.LiteralFn")
     1 local PevalFn = require("dogma.syn._.PevalFn")
     1 local NativeFn = require("dogma.syn._.NativeFn")
     1 local ThrowFn = require("dogma.syn._.ThrowFn")
     1 local ReturnStmt = require("dogma.syn._.ReturnStmt")
     1 local PackOp = require("dogma.syn._.PackOp")

       --An expression parser.
     1 local ExpParser = {}
     1 ExpParser.__index = ExpParser
     1 setmetatable(ExpParser, {__index = SubParser})
     1 package.loaded[...] = ExpParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function ExpParser.new(parser)
         local self

         --(1) create
   555   self = setmetatable(SubParser.new(parser), ExpParser)
   555   self._.stmtParser = parser._.stmtParser

         --(2) return
   555   return self
       end

       --Read an expression.
       --
       --@return Exp
     1 function ExpParser:next()
   617   return self:_readExp()
       end

     1 function ExpParser:_readExp()
   793   local lex = self._.lexer
         local tok, node, exp

         --(1) init expression
   793   tok = lex:advance()
   793   exp = Exp.new(tok.line, tok.col)

         --(2) read
         while true do
  2564     tok = lex:next()

  2564     if tok == nil then
     3       if exp.tree:isWellFormed() then
               break
             else
     6         error(string.format(
     3           "incomplete expression started on (%s, %s).",
     3           exp.line,
                 exp.col
     3         ))
             end
           end

  2561     if tok.type == TokenType.EOL then
   507       if exp.tree:isWellFormed() then
   502         lex:unshift()
               break
             end
  2054     elseif tok.type == TokenType.SYMBOL and tok.value == "(" then
   111       lex:unshift()

   111       if exp.tree:isWellFormed() then
    99         self:_readCallArgs(exp)
             else
    12         exp:insert(self:_readSubExp())
             end
  1943     elseif tok.type == TokenType.SYMBOL and tok.value == "[" then
    26       lex:unshift()

    26       if exp.tree:isWellFormed() then
    15         self:_readIndexOp(exp)
             else
    11         exp:insert(self:_readLiteralList())
             end
  1917     elseif tok.type == TokenType.SYMBOL and tok.value == "{" then
    23       lex:unshift()
    23       if exp.tree:isWellFormed() then
    12         self:_readPackOp(exp)
             else
    11         exp:insert(self:_readLiteralMap())
             end
  1894     elseif tok.type == TokenType.KEYWORD and tok.value == "fn" then
    11       lex:unshift()
    11       exp:insert(self:_readFn())
  1883     elseif tok.type == TokenType.KEYWORD and tok.value == "if" then
     5       lex:unshift()
     5       exp:insert(self:_readIfSubExp())
  1878     elseif tok.type == TokenType.KEYWORD and tok.value == "native" then
     3       lex:unshift()
     3       exp:insert(self:_readNative())
  1875     elseif tok.type == TokenType.KEYWORD and tok.value == "peval" then
     4       lex:unshift()
     4       exp:insert(self:_readPeval())
  1871     elseif tok.type == TokenType.KEYWORD and tok.value == "throw" then
     6       lex:unshift()
     6       exp:insert(self:_readThrow())
           else
  1865       if tok.type == TokenType.KEYWORD and tok.value == "not" then
     8         local aux = lex:advance()

     8         if aux.type == TokenType.KEYWORD and aux.value == "in" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "notin"))
     6         elseif aux.type == TokenType.KEYWORD and aux.value == "like" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "notlike"))
               else
     4           node = UnaryOp.new(tok)
               end
  1857       elseif tok.type == TokenType.KEYWORD and tok.value == "is" then
     4         local aux = lex:advance()

     4         if aux.type == TokenType.KEYWORD and aux.value == "not" then
     2           lex:next()
     2           node = BinOp.new(Keyword.new(tok.line, tok.col, "isnot"))
               else
     2           node = self:_getNodeOf(tok)
               end
  1853       elseif tok.type == TokenType.SYMBOL and (tok.value == "+" or tok.value == "-") then
   250         if exp.tree:isWellFormed() then
   242           node = BinOp.new(tok)
               else
     8           node = UnaryOp.new(tok)
               end
  1603       elseif tok.type == TokenType.SYMBOL and tok.value == ":" then
    15         if exp.tree:isWellFormed() then
     9           node = BinOp.new(tok)
               else
     6           node = UnaryOp.new(tok)
               end
  1588       elseif tok.type == TokenType.SYMBOL and tok.value == "." then
    24         if exp.tree:isWellFormed() then
    15           node = BinOp.new(tok)
               else
     9           node = UnaryOp.new(tok)
               end
             else
  1564         node = self:_getNodeOf(tok)
             end

  1865       if node == nil then
   273         if exp.tree:isWellFormed() then
   272           lex:unshift()
                 break
               else
     2           error(string.format(
     1             "invalid expression node on (%s, %s).",
     1             tok.line,
                   tok.col
     1           ))
               end
             else
  1592         exp:insert(node)
             end
           end
         end

         --(3) return
   774   return exp
       end

       --Return a node for a given token.
       --
       --@param tok:Token  The token.
       --@return Node
     1 function ExpParser:_getNodeOf(tok)
         local node

         --(1) create node
  1566   if tok.type == TokenType.NAME then
   644     node = Terminal.new(TerminalType.NAME, tok)
   922   elseif tok.type == TokenType.LITERAL then
   467     if type(tok.value) == "string" then
    34       node = Terminal.new(TerminalType.TEXT, tok)
   433     elseif type(tok.value) == "number" then
   433       node = Terminal.new(TerminalType.NUM, tok)
           end
   455   elseif tok.type == TokenType.KEYWORD then
   131     local kw = tok.value

   131     if kw == "nop" then
     2       node = Terminal.new(TerminalType.NOP, tok)
   129     elseif kw == "false" then
     2       node = Terminal.new(TerminalType.FALSE, tok)
   127     elseif kw == "nil" then
     1       node = Terminal.new(TerminalType.NIL, tok)
   126     elseif kw == "self" then
     2       node = Terminal.new(TerminalType.SELF, tok)
   124     elseif kw == "super" then
     1       node = Terminal.new(TerminalType.SUPER, tok)
   123     elseif kw == "true" then
    25       node = Terminal.new(TerminalType.TRUE, tok)
    98     elseif tablex.find({"and", "in", "is", "like", "or"}, kw) then
    10       node = BinOp.new(tok)
           end
   324   elseif tok.type == TokenType.SYMBOL then
   324     local sym = tok.value

   324     if tablex.find({"!", "~", "..."}, sym) then
     5       node = UnaryOp.new(tok)
   638     elseif tablex.find({
   319                           "+=", "-=", "*", "*=", "**", "**=", "/", "/=", "%", "%=",
   319                           "=", ".=", ":=", "?=", "==", "===", "!=", "!==",
   319                           "<", "<<", "<<=", "<=", ">", ">>", ">>=", ">=",
   319                           "^", "^=", ".", ":", "&", "&=", "&&", "|", "|=", "||"
   638                        }, sym) then
   134       node = BinOp.new(tok)
           end
         end

         --(2) return
  1566   return node
       end

       --Read (expr).
       --
       --@return Exp
     1 function ExpParser:_readSubExp()
    12   local lex = self._.lexer
         local term, tok, ln, col

         --(1) read
    12   tok = lex:next(TokenType.SYMBOL, "(")
    12   ln, col = tok.line, tok.col
    12   term = SubExp.new(ln, col, self:_readExp())
    11   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     9   return term
       end

       --Read if then else end.
       --
       --@return IfSubExp
     1 function ExpParser:_readIfSubExp()
     5   local lex = self._.lexer
         local tok, ln, col, cond, tcase, fcase

         --(1) read
     5   tok = lex:next(TokenType.KEYWORD, "if")
     5   ln, col = tok.line, tok.col
     5   cond = self:_readExp()
     5   lex:next(TokenType.KEYWORD, "then")
     4   tcase = self:_readExp()
     4   lex:next(TokenType.KEYWORD, "else")
     4   fcase = self:_readExp()
     4   lex:next(TokenType.KEYWORD, "end")

         --(2) return
     3   return IfSubExp.new(ln, col, cond, tcase, fcase)
       end

       --Read a native(code) terminal.
       --
       --@return NativeFn
     1 function ExpParser:_readNative()
     3   local lex = self._.lexer
         local tok, ln, col, code

         --(1) read
     3   tok = lex:next(TokenType.KEYWORD, "native")
     3   ln, col = tok.line, tok.col
     3   lex:next(TokenType.SYMBOL, "(")
     3   code = lex:next(TokenType.LITERAL).value
     2   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return NativeFn.new(ln, col, code)
       end

       --Read a peval(Exp) terminal.
       --
       --@return PevalFn
     1 function ExpParser:_readPeval()
     4   local lex = self._.lexer
         local tok, ln, col, exp

         --(1) read
     4   tok = lex:next(TokenType.KEYWORD, "peval")
     4   ln, col = tok.line, tok.col
     4   lex:next(TokenType.SYMBOL, "(")
     4   exp = self:_readExp()
     3   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     2   return PevalFn.new(ln, col, exp)
       end

       --Read a throw(Exp [, Exp]) terminal.
       --
       --@return ThrowFn
     1 function ExpParser:_readThrow()
     6   local lex = self._.lexer
         local tok, ln, col, args

         --(1) read
     6   tok = lex:next(TokenType.KEYWORD, "throw")
     6   ln, col = tok.line, tok.col
     6   lex:next(TokenType.SYMBOL, "(")

     6   args = {}
         while true do
    12     table.insert(args, self:_readExp())

    12     tok = lex:advance()
    12     if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
             break
           end

     6     lex:next(TokenType.SYMBOL, ",")
         end

     6   lex:next(TokenType.SYMBOL, ")")

         --(2) return
     6   return ThrowFn.new(ln, col, args)
       end

       --Read a call arguments.
       --
       --@param exp:Exp  Current expression.
     1 function ExpParser:_readCallArgs(exp)
    99   local lex = self._.lexer
         local tok, call

         --(1) pre: read (
    99   tok = lex:next(TokenType.SYMBOL, "(")
    99   tok.value = "()"

         --(2) create operator
    99   call = CallOp.new(tok)
    99   exp:insert(call)

         --(3) read arguments
    99   tok = lex:advance()

    99   if tok.type == TokenType.SYMBOL and tok.value == ")" then
    18     lex:next()
    18     call.finished = true
         else
    81     local sep = ","

    81     if tok.type == TokenType.EOL then
     5       lex:next()
     5       sep = "\n"
           end

           while true do
    86       call:insert(self:_readExp())

    86       tok = lex:next()

    86       if tok.type == TokenType.SYMBOL and tok.value == ")" then
    77         call.finished = true
               break
             end

     9       if sep == "," then
     4         if tok.type ~= TokenType.SYMBOL and tok.value ~= "," then
     2           error(string.format(
     1             "on (%s, %s), comma expected for argument end or ) for call end.",
     1             tok.line,
                   tok.col
     1           ))
               end
     5       elseif sep == "\n" then
     5         if tok.type ~= TokenType.EOL then
     2           error(string.format(
     1             "on (%s, %s), end of line expected for argument end.",
     1             tok.line,
                   tok.col
     1           ))
               end

     4         tok = lex:advance()

     4         if tok.type == TokenType.SYMBOL and tok.value == ")" then
     2           lex:next()
     2           call.finished = true
                 break
               end
             end
           end
         end
       end

       --Read a literal list: [...].
       --
       --@return LiteralList
     1 function ExpParser:_readLiteralList()
    11   local lex = self._.lexer
         local tok, ln, col, items

         --(1) read [
    11   tok = lex:next(TokenType.SYMBOL, "[")
    11   ln, col = tok.line, tok.col

         --(2) read items]
    11   items = {}

    11   tok = lex:advance()
    11   if not (tok.type == TokenType.SYMBOL and tok.value == ']') then
           local sep

     9     if tok.type == TokenType.EOL then
     3       lex:next()
     3       sep = "\n"
           else
     6       sep = ","
           end

           while true do
    18       table.insert(items, self:_readExp())

    18       if sep == "," then
    12         tok = lex:advance()

    12         if tok.type == TokenType.SYMBOL and tok.value == "," then
     6           lex:next()
               else
                 break
               end
             else
     6         lex:next(TokenType.EOL)

     6         tok = lex:advance()
     6         if tok.type == TokenType.SYMBOL and tok.value == "]" then
                 break
               end
             end
           end
         end

    11   lex:next(TokenType.SYMBOL, "]")

         --(4) return
    11   return LiteralList.new(ln, col, items)
       end

       --Read a literal map: {...}.
       --
       --@return LiteralMap
     1 function ExpParser:_readLiteralMap()
    11   local lex = self._.lexer
         local tok, ln, col, entries

         --(1) read {
    11   tok = lex:next(TokenType.SYMBOL, "{")
    11   ln, col = tok.line, tok.col

         --(2) read entries}
    11   entries = {}

    11   tok = lex:advance()
    11   if not (tok.type == TokenType.SYMBOL and tok.value == '}') then
           local sep

     9     if tok.type == TokenType.EOL then
     4       lex:next()
     4       sep = "\n"
           else
     5       sep = ","
           end

           while true do
             local name, val

             --skip ends of line
    17       if sep == "\n" then
     8         self:_nextEols()
             end

             --read item
    17       name = lex:next(TokenType.NAME).value
    17       lex:next(TokenType.SYMBOL, "=")
    17       val = self:_readExp()

    17       table.insert(entries, {name = name, value = val})

             --read sep
    17       if sep == "," then
     9         tok = lex:advance()

     9         if tok.type == TokenType.SYMBOL and tok.value == "," then
     4           lex:next()
               else
                 break
               end
             else
     8         self:_nextEols()

     8         tok = lex:advance()
     8         if tok.type == TokenType.SYMBOL and tok.value == "}" then
                 break
               end
             end
           end
         end

    11   lex:next(TokenType.SYMBOL, "}")

         --(4) return
    11   return LiteralMap.new(ln, col, entries)
       end

       --Read a fn.
       --
       --@return LiteralFn
     1 function ExpParser:_readFn()
    11   local lex, stmt = self._.lexer, self._.stmtParser
         local tok, ln, col, params, rtype, rvar, body

         --(1) read
    11   tok = lex:next(TokenType.KEYWORD, "fn")
    11   ln, col = tok.line, tok.col

    11   params = stmt:_readFnParams()
    11   rvar = stmt:_readFnReturnVar()
    11   rtype = stmt:_readFnType()

    11   tok = lex:advance()
    11   if tok.type == TokenType.SYMBOL and tok.value == "=" then
     2     lex:next()
     2     body = self:_readExp()
     2     body = {ReturnStmt.new(body.ln, body.col, body)}
     2     lex:next(TokenType.KEYWORD, "end")
         else
     9     body = stmt:_readBody(3)
         end

         --(2) return
    11   return LiteralFn.new(ln, col, params, rtype, rvar, body)
       end

       --Read an indexing operator.
       --
       --@param exp:Exp  Expression to update.
     1 function ExpParser:_readIndexOp(exp)
    15   local lex = self._.lexer
         local tok, ln, col, init, fin

         --(1) read [Exp
    15   tok = lex:next(TokenType.SYMBOL, "[")
    15   ln, col = tok.line, tok.col
    15   init = self:next()

         --(2) read "", Exp" if existing
    15   tok = lex:advance()

    15   if tok.type == TokenType.SYMBOL and tok.value == "," then
     5     lex:next()
     5     fin = self:next()
         end

         --(3) read ]
    15   lex:next(TokenType.SYMBOL, "]")

         --(4) add
         local op

    15   if fin == nil then
    10     op = BinOp.new({line = ln, col = col, value = "[]"})
    10     exp:insert(op)
    10     op:insert(init.tree.root)
         else
     5     op = SliceOp.new({line = ln, col = col, value = "[]"})
     5     exp:insert(op)
     5     op:insert(init.tree.root)
     5     op:insert(fin.tree.root)
         end
       end

       --Read the next {name,name...} op.
       --
       --@param exp:Exp  Expression to update.
     1 function ExpParser:_readPackOp(exp)
    12   local lex = self._.lexer
         local tok, op

         --(1) read {
    12   tok = lex:next(TokenType.SYMBOL, "{")

         --(2) create op
    12   tok.value = "{}"
    12   op = PackOp.new(tok)
    12   exp:insert(op)

         --(3) read fields
    12   tok = lex:advance()
    12   if not (tok.type == TokenType.SYMBOL and tok.value == "}") then
           while true do
             local visib, name

             --name, .name or :name
    15       tok = lex:advance()

    15       if tok.type == TokenType.SYMBOL and tok.value == "*" then
     4         if #op.children > 1 then
     1           error(string.format("on (%s,%s), '*' only allowed when '{*}'.", tok.line, tok.col))
               end

     3         lex:next()
     3         visib = "."
     3         name = "*"
    11       elseif tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
     6         lex:next()
     6         visib = tok.value
     6         name = ""
             else
     5         visib = "."
     5         name = ""
             end

    14       if name ~= "*" then
    11         name = lex:next(TokenType.NAME).value
             end

    14       table.insert(op.children, {visib = visib, name = name})

             --end?
    14       if name == "*" then
               break
             else
    11         tok = lex:advance()

    11         if tok.type == TokenType.SYMBOL and tok.value == "}" then
                 break
               end

     5         lex:next(TokenType.SYMBOL, ",")
             end
           end
         end

         --(4) read }
    11   lex:next(TokenType.SYMBOL, "}")
    10   op.finished = true
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/NodeType.lua
==============================================================================
     1 return {
     1   TERMINAL = "terminal",
     1   NON_TERMINAL = "non-terminal"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/NonTerminalType.lua
==============================================================================
     1 return {
     1   OP = 1,
     1   TREE = 2
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/Parser.lua
==============================================================================
       --imports
     1 local Lexer = require("dogma.lex.Lexer")
     1 local TokenType = require("dogma.lex.TokenType")
     1 local DirectiveParser = require("dogma.syn.DirectiveParser")
     1 local ExpParser = require("dogma.syn.ExpParser")
     1 local StmtParser = require("dogma.syn.StmtParser")
     1 local UnpackParser = require("dogma.syn.UnpackParser")

       --A parser.
     1 local Parser = {}
     1 Parser.__index = Parser
     1 package.loaded[...] = Parser

       --Constructor.
     1 function Parser.new()
         local self

         --(1) create
   555   self = setmetatable({_ = {}}, Parser)
   555   self._.lexer = Lexer.new()
   555   self._.directiveParser = DirectiveParser.new(self)
   555   self._.expParser = ExpParser.new(self)
   555   self._.stmtParser = StmtParser.new(self)
   555   self._.unpackParser = UnpackParser.new(self)
   555   self._.expParser._.stmtParser = self._.stmtParser

         --(2) return
   555   return self
       end

       --Parse a given text.
       --
       --@param txt:string   Text to parse.
       --@param file?:string File name..
     1 function Parser:parse(txt, file)
   555   self._.lexer:scan(txt, file)
       end

       --Parse the next sentence.
       --
       --@return Sentence
     1 function Parser:next()
   974   local lex, stmter, unpacker, direr = self._.lexer, self._.stmtParser, self._.unpackParser, self._.directiveParser
         local sent, tok, annots

         --(1) remove white lines and read annotations
   974   annots = {}
   974   tok = lex:advance()
         while true do
  1149     if tok == nil then
             break
   882     elseif tok.type == TokenType.EOL then
   162       lex:next()
   720     elseif tok.type == TokenType.ANNOTATION then
    13       lex:next()
    13       table.insert(annots, tok.value)
           else
             break
           end

   175     tok = lex:advance()
         end

          --(2) parse next sentence
   974   tok = lex:advance()

   974   if tok ~= nil then
   707     if tok.type == TokenType.DIRECTIVE then
    17       if tok.value:find("^if") then
    14         sent = direr:nextIf()
     3       elseif tok.value:find("^/") then
     3         sent = direr:nextRunWith()
             end
   690     elseif tok.type == TokenType.KEYWORD then
   325       if tok.value == "async" then
     8         sent = stmter:nextAsync()
   317       elseif tok.value == "break" then
     3         sent = stmter:nextBreak()
   314       elseif tok.value == "const" then
    14         tok = lex:advance(2)

    14         if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     3           sent = self._.unpackParser:next()
               else
    11           sent = stmter:nextConst()
               end
   300       elseif tok.value == "do" then
    11         sent = stmter:nextDo()
   289       elseif tok.value == "enum" then
    22         sent = stmter:nextEnum(annots)
   267       elseif tok.value == "export" or tok.value == "pub" or tok.value == "pvt" then
    47         local toParse = tok.value

    47         tok = lex:advance(2)

    47         if tok.type == TokenType.KEYWORD then
    36           if tok.value == "const" then
    10             tok = lex:advance(3)

    10             if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     6               sent = unpacker:next()
                   else
     4               sent = stmter:nextConst()
                   end
    26           elseif tok.value == "enum" then
     7             sent = stmter:nextEnum(annots)
    19           elseif tok.value == "fn" then
     5             sent = stmter:nextFn(annots)
    14           elseif tok.value == "type" then
     3             sent = stmter:nextType(annots)
    11           elseif tok.value == "var" then
    11             tok = lex:advance(3)

    11             if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     7               sent = unpacker:next()
                   else
     4               sent = stmter:nextVar()
                   end
                 end
               end

    47         if not sent then
    11           if toParse == "pub" then
     8             sent = stmter:nextPub()
     3           elseif toParse == "export" then
     3             sent = stmter:nextExport()
                 end
               end
   220       elseif tok.value == "fn" then
    66         sent = stmter:nextFn(annots)
   154       elseif tok.value == "for" then
    22         tok = lex:advance(2)

    22         if tok.type == TokenType.KEYWORD and tok.value == "each" then
    10           sent = stmter:nextForEach()
               else
    12           sent = stmter:nextFor()
               end
   132       elseif tok.value == "from" then
     8         sent = stmter:nextFrom()
   124       elseif tok.value == "if" then
    14         sent = stmter:nextIf()
   110       elseif tok.value == "next" then
     3         sent = stmter:nextNext()
   107       elseif tok.value == "return" then
    10         sent = stmter:nextReturn()
    97       elseif tok.value == "type" then
    11         sent = stmter:nextType(annots)
    86       elseif tok.value == "use" then
    18         sent = stmter:nextUse()
    68       elseif tok.value == "var" then
    20         tok = lex:advance(2)

    20         if tok.type == TokenType.SYMBOL and (tok.value == "{" or tok.value == "[") then
     6           sent = self._.unpackParser:next()
               else
    14           sent = stmter:nextVar()
               end
    48       elseif tok.value == "while" then
    18         sent = stmter:nextWhile()
    30       elseif tok.value == "with" then
     8         sent = stmter:nextWith()
             end
           end

   685     if not sent and tok.type == TokenType.SYMBOL and (tok.value == "[" or tok.value == "{") then
    22       sent = self._.unpackParser:next()
           end

   681     if not sent then
   365       sent = self:nextExp()
           end
         end

         --(3) return
   940   return sent
       end

       --Read the next expression.
       --
       --@return Exp
     1 function Parser:nextExp()
   559   return self._.expParser:next()
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/SentType.lua
==============================================================================
     1 return {
     1   EXP = "exp",
     1   STMT = "stmt",
     1   UNPACK = "unpack",
     1   DIRECTIVE = "directive"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SentType = require("dogma.syn.SentType")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local BlockParser = require("dogma.syn._.BlockParser")
     1 local BreakStmt = require("dogma.syn._.BreakStmt")
     1 local ConstStmt = require("dogma.syn._.ConstStmt")
     1 local EnumStmt = require("dogma.syn._.EnumStmt")
     1 local NextStmt = require("dogma.syn._.NextStmt")
     1 local ReturnStmt = require("dogma.syn._.ReturnStmt")
     1 local UseStmt = require("dogma.syn._.UseStmt")
     1 local FromStmt = require("dogma.syn._.FromStmt")
     1 local VarStmt = require("dogma.syn._.VarStmt")
     1 local WhileStmt = require("dogma.syn._.WhileStmt")
     1 local DoStmt = require("dogma.syn._.DoStmt")
     1 local ForEachStmt = require("dogma.syn._.ForEachStmt")
     1 local ForStmt = require("dogma.syn._.ForStmt")
     1 local CatchCl = require("dogma.syn._.CatchCl")
     1 local FinallyCl = require("dogma.syn._.FinallyCl")
     1 local FnStmt = require("dogma.syn._.FnStmt")
     1 local TypeStmt = require("dogma.syn._.TypeStmt")
     1 local Param = require("dogma.syn._.Param")
     1 local Params = require("dogma.syn._.Params")
     1 local AsyncStmt = require("dogma.syn._.AsyncStmt")
     1 local IfStmt = require("dogma.syn._.IfStmt")
     1 local Exp = require("dogma.syn._.Exp")
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local PubStmt = require("dogma.syn._.PubStmt")
     1 local ExportStmt = require("dogma.syn._.ExportStmt")
     1 local WithStmt = require("dogma.syn._.WithStmt")

       --Parser for the Dogma statements.
     1 local StmtParser = {}
     1 StmtParser.__index = StmtParser
     1 setmetatable(StmtParser, {__index = SubParser})
     1 package.loaded[...] = StmtParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
     1 function StmtParser.new(parser)
         local self

         --(1) create
   555   self = setmetatable(SubParser.new(parser), StmtParser)
   555   self._.expParser = parser._.expParser

         --(2) return
   555   return self
       end

       --Read a const statement.
       --
       --@return ConstStmt
     1 function StmtParser:nextConst()
    15   local lexer, exper = self._.lexer, self._.expParser
         local tok, ln, col, visib, stmt, sep

         --(1) read visibility
    15   tok = lexer:advance()
    15   ln, col = tok.line, tok.col

    15   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     4     lexer:next()
     4     visib = tok.value
         end

         --(2) read
    15   lexer:next(TokenType.KEYWORD, "const")
    15   stmt = ConstStmt.new(ln, col, visib)

         --(3) get separator
    15   tok = lexer:advance()

    15   if tok.type == TokenType.EOL then
     5     sep = "\n"
     5     lexer:next()
         else
    10     sep = ","
         end

         --(4) get variables
         while true do
           local name, val

           --read name
    23     tok = lexer:advance()

    23     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

    18     name = lexer:next(TokenType.NAME).value

           --read value
    18     lexer:next(TokenType.SYMBOL, "=")
    17     val = exper:next()

           --insert variable
    17     stmt:insert(name, val)

           --read separator
    17     if sep == "\n" then
     5       lexer:next(TokenType.EOL)
           else  --using comma as separator
    12       tok = lexer:next()

    12       if tok.type == TokenType.EOL then
               break
             end

     4       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating variables.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(5) return
    13   return stmt
       end

       --Read a break statement.
       --
       --@return BreakStmt
     1 function StmtParser:nextBreak()
     3   local lexer = self._.lexer
         local tok, stmt

         --(1) read
     3   tok = lexer:next(TokenType.KEYWORD, "break")
     3   stmt = BreakStmt.new(tok.line, tok.col)

         --(2) get end of line
     3   lexer:next(TokenType.EOL)

         --(3) return
     2   return stmt
       end

       --Read a next statement.
       --
       --@return NextStmt
     1 function StmtParser:nextNext()
     3   local lexer = self._.lexer
         local tok, stmt

         --(1) read
     3   tok = lexer:next(TokenType.KEYWORD, "next")
     3   stmt = NextStmt.new(tok.line, tok.col)

         --(2) get end of line
     3   lexer:next(TokenType.EOL)

         --(3) return
     2   return stmt
       end

       --Read a return statement.
       --
       --@return ReturnStmt
     1 function StmtParser:nextReturn()
    10   local lex, exper = self._.lexer, self._.expParser
         local tok, stmt

         --(1) read
    10   tok = lex:next(TokenType.KEYWORD, "return")
    10   stmt = ReturnStmt.new(tok.line, tok.col)

         --(2) get values
    10   tok = lex:advance()

    10   if tok.type ~= TokenType.EOL then
     8     stmt:insert(exper:next())
         end

    10   lex:next(TokenType.EOL)

         --(3) return
    10   return stmt
       end

       --Read a use stament.
       --
       --@return UseStmt
     1 function StmtParser:nextUse()
    18   local lex = self._.lexer
         local tok, stmt, sep

         --(1) read
    18   tok = lex:next(TokenType.KEYWORD, "use")
    18   stmt = UseStmt.new(tok.line, tok.col)

         --(2) get separator
    18   tok = lex:advance()

    18   if tok.type == TokenType.EOL then
     5     sep = "\n"
     5     lex:next()
         else
    13     sep = ","
         end

         --(3) get variables
         while true do
           local path, name

    28     tok = lex:advance()

    28     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

           --path
    23     path = lex:next(TokenType.LITERAL).value

           --as
    23     tok = lex:advance()

    23     if tok.type == TokenType.KEYWORD and tok.value == "as" then
     9       lex:next()  --as
     9       name = lex:next(TokenType.NAME).value
           end

           --insert
    23     stmt:insert(path, name)

           --read separator
    22     if sep == "\n" then
     6       lex:next(TokenType.EOL)
           else  --using comma as separator
    16       tok = lex:next()

    16       if tok.type == TokenType.EOL then
               break
             end

     5       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating modules.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(4) return
    16   return stmt
       end

       --Read a from statement.
       --
       --@return FromStmt
     1 function StmtParser:nextFrom()
     8   local lex = self._.lexer
         local tok, ln, col, stmt

         --(1) read module
     8   tok = lex:next(TokenType.KEYWORD, "from")
     8   ln, col = tok.line, tok.col
     8   stmt = FromStmt.new(ln, col, lex:next(TokenType.LITERAL).value)

         --(2) items
     8   lex:next(TokenType.KEYWORD, "use")

         while true do
           local name, as

           --(1) item
    12     name = lex:next(TokenType.NAME).value

    12     tok = lex:advance()
    12     if tok.type == TokenType.KEYWORD and tok.value == "as" then
     6       lex:next()  --as
     6       as = lex:next(TokenType.NAME).value
           end

    12     stmt:insert(name, as)

           --(2) end?
    12     tok = lex:advance()
    12     if tok.type == TokenType.EOL then
     8       lex:next()
             break
           else
     4       lex:next(TokenType.SYMBOL, ",")
           end
         end

         --(3) return
     8   return stmt
       end

       --Read a var statement.
       --
       --@return VarStmt
     1 function StmtParser:nextVar()
    18   local lexer, exper = self._.lexer, self._.expParser
         local tok, ln, col, stmt, visib, sep

         --(1) read visibility
    18   tok = lexer:advance()
    18   ln, col = tok.line, tok.col

    18   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     4     lexer:next()
     4     visib = tok.value
         end

         --(2) read
    18   lexer:next(TokenType.KEYWORD, "var")
    18   stmt = VarStmt.new(ln, col, visib)

         --(3) get separator
    18   tok = lexer:advance()

    18   if tok.type == TokenType.EOL then
     6     sep = "\n"
     6     lexer:next()
         else
    12     sep = ","
         end

         --(4) get variables
         while true do
           local name, val

           --read name
    28     tok = lexer:advance()

    28     if tok == nil or (sep == "\n" and tok.col <= stmt.col) then
             break
           end

    22     name = lexer:next(TokenType.NAME).value

           --read value
    22     tok = lexer:advance()

    22     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    13       lexer:next()
    13       val = exper:next()
           else
     9       val = nil
           end

           --insert variable
    22     stmt:insert(name, val)

           --read separator
    22     if sep == "\n" then
     6       lexer:next(TokenType.EOL)
           else  --using comma as separator
    16       tok = lexer:next()

    16       if tok.type == TokenType.EOL then
               break
             end

     5       if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
     2         error(string.format(
     1           "comma expected on (%s, %s) for separating variables.",
     1           tok.line,
                 tok.col
     1         ))
             end
           end
         end

         --(5) return
    17   return stmt
       end

       --Read a next statement.
       --
       --@return EnumStmt
     1 function StmtParser:nextEnum(annots)
    29   local lexer = self._.lexer
         local tok, ln, col, visib, name, stmt, sep

         --(1) create stmt
    29   tok = lexer:advance()
    29   ln, col = tok.line, tok.col

         --visibility
    29   if tok.type == TokenType.KEYWORD then
    29     if tok.value == "export" or tok.value == "pub" then
     7       lexer:next()
     7       visib = tok.value
           end
         end

         --enum Name
    29   lexer:next(TokenType.KEYWORD, "enum")
    29   name = lexer:next(TokenType.NAME).value

         --create
    28   stmt = EnumStmt.new(ln, col, annots, visib, name)

         --(2) read items
    28   tok = lexer:next()

    28   if tok.type == TokenType.SYMBOL and tok.value == "{" then
    11     sep = ","
    17   elseif tok.type == TokenType.EOL then
    16     sep = "\n"
         else
     1     error(string.format("invalid token on (%s, %s).", tok.line, tok.col))
         end

         while true do
           local item, value

    57     tok = lexer:advance()

    57     if tok == nil then
             break
           end

    43     if sep == "\n" and tok.col <= stmt.col then
             break
           end

           --name
    41     item = lexer:next(TokenType.NAME).value

           --value
    40     tok = lexer:advance()

    40     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    21       lexer:next()  --=
    21       value = lexer:next(TokenType.LITERAL).value
           else
    19       value = nil
           end

           --insert
    40     stmt:insert(item, value)

           --separator
    40     if sep == "," then
    21       tok = lexer:advance()

    21       if tok.type == TokenType.SYMBOL and tok.value == "}" then
    10         lexer:next()
               break
             else
    11         lexer:next(TokenType.SYMBOL, ",")
             end
           else
    19       lexer:next(TokenType.EOL)
           end
         end

         --(3) return
    26   return stmt
       end

       --Read a while statement.
       --
       --@return WhileStmt
     1 function StmtParser:nextWhile()
    18   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, btype, cond, iter, body, catch, fin

         --(1) read while keyword
    18   tok = lex:next(TokenType.KEYWORD, "while")
    18   ln, col = tok.line, tok.col

         --(2) read condition and iter
         --condition
    18   cond = parser:nextExp()

         --iter
    18   tok = lex:advance()

    18   if tok.type == TokenType.SYMBOL and tok.value == ";" then
     3     lex:next()
     3     iter = parser:nextExp()
         end

         --do
    18   lex:next(TokenType.KEYWORD, "do")

    18   tok = lex:advance()
    18   if tok.type == TokenType.EOL then
    13     lex:next()
    13     btype = 2
         else
     5     btype = 1
         end

         --(4) read rest
    18   body = self:_readBody(btype, col)
    18   catch = self:_readCatch(col)
    18   fin = self:_readFinally(col)

         --(5) return
    18   return WhileStmt.new(ln, col, cond, iter, body, catch, fin)
       end

       --Read a do statement.
       --
       --@return Dotmt
     1 function StmtParser:nextDo()
    11   local lexer, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, catch, fin

         --(1) read while keyword
    11   tok = lexer:next(TokenType.KEYWORD, "do")
    11   ln, col = tok.line, tok.col

    11   lexer:next(TokenType.DO)

         --(2) read body
    11   body = self:_readBody(2, col)

         --(3) read condition if existing
    11   tok = lexer:advance()

    11   if tok and tok.type == TokenType.KEYWORD and tok.value == "while" then
     4     lexer:next()
     4     cond = parser:nextExp()
     4     lexer:next(TokenType.EOL)
         end

         --(4) read rest
    11   catch = self:_readCatch(col)
    11   fin = self:_readFinally(col)

         --(5) return
    11   return DoStmt.new(ln, col, body, cond, catch, fin)
       end

       --Read for statement.
       --
       --@return ForStmt
     1 function StmtParser:nextFor()
    12   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, def, cond, iter, btype, body, catch, fin

         --(1) read for keyword
    12   tok = lex:next(TokenType.KEYWORD, "for")
    12   ln, col = tok.line, tok.col

         --(2) variables
    12   def = {}

         while true do
           local name, val

           --name [= value]
    17     name = lex:next(TokenType.NAME).value

    17     tok = lex:advance()
    17     if tok.type == TokenType.SYMBOL and tok.value == "=" then
    10       lex:next()
    10       val = parser:nextExp()
           else
     7       val = nil
           end

    17     table.insert(def, {name = name, value = val})

           --end?
    17     tok = lex:advance()

    17     if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
             break
           end

     5     lex:next(TokenType.SYMBOL, ",")
         end

    12   lex:next(TokenType.SYMBOL, ";")

         --(3) cond
    12   cond = parser:nextExp()

         --(4) iter
    12   tok = lex:advance()
    12   if tok.type == TokenType.SYMBOL and tok.value == ";" then
     4     lex:next()
     4     iter = parser:nextExp()
         end

         --(5) rest
    12   lex:next(TokenType.KEYWORD, "do")

    12   tok = lex:advance()
    12   if tok.type == TokenType.EOL then
     1     lex:next()
     1     btype = 2
         else
    11     btype = 1
         end

    12   body = self:_readBody(btype, col)
    12   catch = self:_readCatch(col)
    12   fin = self:_readFinally(col)

         --(5) return
    12   return ForStmt.new(ln, col, def, cond, iter, body, catch, fin)
       end

       --Read for each statement.
       --
       --@return ForEachStmt
     1 function StmtParser:nextForEach()
    10   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, key, val, iter, btype, body, catch, fin

         --(1) read for each keywords
    10   tok = lex:next(TokenType.KEYWORD, "for")
    10   lex:next(TokenType.KEYWORD, "each")
    10   ln, col = tok.line, tok.col

         --key
    10   key = lex:next(TokenType.NAME).value

         --value
    10   tok = lex:advance()

    10   if tok.type == TokenType.SYMBOL and tok.value == "," then
     3     lex:next()
     3     val = lex:next(TokenType.NAME).value
         else
     7     val, key = key, nil
         end

         --(3) read iter
    10   lex:next(TokenType.KEYWORD, "in")
    10   iter = parser:nextExp()

         --(4) read rest
    10   lex:next(TokenType.KEYWORD, "do")

    10   tok = lex:advance()
    10   if tok.type == TokenType.EOL then
     8     lex:next()
     8     btype = 2
         else
     2     btype = 1
         end

    10   body = self:_readBody(btype, col)
    10   catch = self:_readCatch(col)
    10   fin = self:_readFinally(col)

         --(5) return
    10   return ForEachStmt.new(ln, col, key, val, iter, body, catch, fin)
       end

       --Read a body statement as, fo example, while, for, if, etc.
       --
       --@param btype:number Body type: 1, one line; 2, block; 3, between {}.
       --@param col:number   Column line where it starts.
       --
       --@return Sent[]
     1 function StmtParser:_readBody(btype, col)
   166   local parser = self._.parser
         local body

         --(1) read body
   166   if btype == 1 then
    21     body = {parser:next()}
   145   elseif btype == 2 then
   136     body = BlockParser.new(parser, col):next()
     9   elseif btype == 3 then
     9     body = BlockParser.new(parser):next()
         end

         --(2) return
   166   return body
       end

       --Read a catch clause.
       --
       --@param col:number Column number where this must start.
       --@return CatchCl
     1 function StmtParser:_readCatch(col)
   136   local lexer, parser = self._.lexer, self._.parser
         local tok, var, body

         --(1) read catch keyword
   136   tok = lexer:advance()

   136   if tok == nil or not (tok.type == TokenType.KEYWORD and tok.value == "catch" and tok.col == col) then
   117     return
         end

    19   lexer:next()

         --(2) read error variable name
    19   tok = lexer:advance()

    19   if tok.type == TokenType.NAME then
     4     lexer:next()
     4     var = tok.value
         end

    19   lexer:next(TokenType.EOL)

         --(3) read body
    19   body = BlockParser.new(parser, col):next()

         --(4) return
    19   return CatchCl.new(var, body)
       end

       --Read a finally clause.
       --
       --@param col:number Column number where this must start.
       --@return FinallyCl
     1 function StmtParser:_readFinally(col)
   131   local lexer, parser = self._.lexer, self._.parser
         local tok, body

         --(1) read finally keyword
   131   tok = lexer:advance()

   131   if tok == nil or not (tok.type == TokenType.KEYWORD and tok.value == "finally" and tok.col == col) then
   118     return
         end

    13   lexer:next()
    13   lexer:next(TokenType.EOL)

         --(2) read body
    13   body = BlockParser.new(parser, col):next()

         --(4) return
    13   return FinallyCl.new(body)
       end

       --Read a fn statement.
       --
       --@return FnStmt
     1 function StmtParser:nextFn(annots)
    71   local lexer = self._.lexer
         local tok, ln, col, visib, itype, name, params, rtype, rvar, body, catch, fin

         --(1) read visibility
    71   tok = lexer:advance()
    71   ln, col = tok.line, tok.col

    71   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub" or tok.value == "pvt") then
     5     lexer:next()
     5     visib = tok.value
         end

         --(2) read fn type.name
    71   lexer:next(TokenType.KEYWORD, "fn")
    71   name = lexer:next(TokenType.NAME).value

    71   tok = lexer:advance()
    71   if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
    17     lexer:next()
    17     visib = (tok.value == "." and "pub" or "pvt")
    17     itype = name
    17     name = lexer:next(TokenType.NAME).value
         end

         --(3) read parameters, return type and return variable
    71   params = self:_readFnParams()
    68   rvar = self:_readFnReturnVar()
    67   rtype = self:_readFnType()

         --(4) read body
    66   tok = lexer:advance()

    66   if tok.type == TokenType.SYMBOL and tok.value == "=" then
    12     lexer:next()
    12     body = {self._.expParser:_readExp()}

    12     if #body > 0 and body[1].type == SentType.EXP then
    12       local exp = body[1]

    12       body[1] = ReturnStmt.new(exp.line, exp.col)
    12       body[1]:insert(exp)
           end
         else
    54     lexer:next(TokenType.EOL)
    54     body = self:_readBody(2, col)
         end

         --(5) read rest
    66   catch = self:_readCatch(col)
    66   fin = self:_readFinally(col)

         --(6) return
    66   return FnStmt.new(ln, col, annots, visib, itype, name, params, rtype, rvar, body, catch, fin)
       end

       --Read the function parameters.
       --
       --@return Param[]
     1 function StmtParser:_readFnParams()
    96   local lex = self._.lexer
    96   local params = Params.new()
         local tok

         --(1) read (
    96   lex:next(TokenType.SYMBOL, "(")

         --(2) read params
    96   tok = lex:advance()

    96   if not (tok.type == TokenType.SYMBOL and tok.value == ")") then
           while true do
             local const, mod, name, opt, dtype, val

             --const
    71       tok = lex:advance()

    71       if tok.type == TokenType.KEYWORD and tok.value == "const" then
     3         lex:next()
     3         const = true
             else
    68         const = false
             end

             --. or : or ...
    71       tok = lex:advance()

    71       if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":" or tok.value == "...") then
    15         lex:next()
    15         mod = tok.value
             end

             --name
    71       name = lex:next(TokenType.NAME).value

             --optional?
    71       tok = lex:advance()

    71       if tok.type == TokenType.SYMBOL and tok.value == "?" then
    16         lex:next()
    16         opt = true
             end

             --type
    71       tok = lex:advance()

    71       if tok.type == TokenType.SYMBOL and tok.value == ":" then
    15         dtype = self:_readFnParamType()
             else
    56         dtype = nil
             end

             --default value
    71       if not opt then
    55         tok = lex:advance()

    55         if tok.type == TokenType.SYMBOL and tok.value == "=" then
     3           opt = true
     3           val = self:_readFnParamValue()
    52         elseif tok.type == TokenType.SYMBOL and tok.value == ":=" then
     5           opt = true
     5           val, dtype = self:_readFnParamValueWithInference()
               end
             end

             --insert param
    70       params:insert(Param.new(const, mod, name, opt, dtype, val))

             --,
    70       tok = lex:advance()

    70       if tok.type == TokenType.SYMBOL and tok.value == "," then
    16         lex:next()
             else
               break
             end
           end
         end

         --(3) read close
    95   lex:next(TokenType.SYMBOL, ")")

         --(4) return
    93   return params
       end

       --Read the parameter type.
       --
       --@return string
     1 function StmtParser:_readFnParamType()
    15   local lex = self._.lexer
         local tok, dtype

         --(1) read
    15   lex:next(TokenType.SYMBOL, ":")

    15   tok = lex:advance()
    15   if tok.type == TokenType.SYMBOL and tok.value == "{" then
     7     lex:next()

     7     dtype = {}

     7     tok = lex:advance()
     7     if tok.type == TokenType.SYMBOL and tok.value == "}" then
     2       lex:next()
           else
             while true do
               --read field
               local pname, ptype

     8         pname = lex:next(TokenType.NAME).value

     8         tok = lex:advance()
     8         if tok.type == TokenType.SYMBOL and tok.value == ":" then
     5           lex:next()
     5           ptype = lex:next(TokenType.NAME).value
               else
     3           ptype = "any"
               end

     8         table.insert(dtype, {name = pname, type = ptype})

               --read next or end
     8         tok = lex:advance()
     8         if tok.type == TokenType.SYMBOL and tok.value == "}" then
     5           lex:next()
                 break
               end

     3         lex:next(TokenType.SYMBOL, ",")
             end --while
           end
         else
     8     dtype = lex:next(TokenType.NAME).value
         end

         --(2) return
    15   return dtype
       end

       --Read the parameter value wihtout inference.
       --
       --@return string
     1 function StmtParser:_readFnParamValue()
     3   self._.lexer:next(TokenType.SYMBOL, "=")
     3   return self._.parser:nextExp()
       end

       --Read the parameter value using inference.
       --
       --@return val, type
     1 function StmtParser:_readFnParamValueWithInference()
     5   local lex = self._.lexer
         local tok, val, dtype

         --(1) read
     5   lex:next(TokenType.SYMBOL, ":=")
     5   tok = lex:next()

     5   if tok.type == TokenType.LITERAL and type(tok.value) == "string" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.TEXT, tok))
     1     dtype = "text"
     4   elseif tok.type == TokenType.LITERAL and type(tok.value) == "number" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.NUM, tok))
     1     dtype = "num"
     3   elseif tok.type == TokenType.KEYWORD and tok.value == "true" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.TRUE, tok))
     1     dtype = "bool"
     2   elseif tok.type == TokenType.KEYWORD and tok.value == "false" then
     1     val = Exp.new(tok.line, tok.col)
     1     val:insert(Terminal.new(TerminalType.FALSE, tok))
     1     dtype = "bool"
         else
     2     error(string.format(
     1       "on (%s, %s), for infering type, the default value must be a literal: text, num or bool.",
     1       tok.line,
             tok.col
     1     ))
         end

         --(2) return
     4   return val, dtype
       end

       --Read the function return type.
       --
       --@return string
     1 function StmtParser:_readFnType()
    78   local lex = self._.lexer
         local tok, rtype

         --(1) read
    78   tok = lex:advance()

    78   if tok.type == TokenType.SYMBOL and tok.value == ":" then
     3     lex:next()  --:
     3     rtype = lex:next(TokenType.NAME).value
         end

         --(2) return
    77   return rtype
       end

       --Read the function return variable.
       --
       --@return string
     1 function StmtParser:_readFnReturnVar()
    79   local lex = self._.lexer
         local tok, rvar

         --(1) read
    79   tok = lex:advance()

    79   if tok.type == TokenType.SYMBOL and tok.value == "->" then
    12     lex:next()  -- ->
    12     tok = lex:next()

    12     if tok.type == TokenType.KEYWORD and tok.value == "self" then
     3       rvar = "self"
     9     elseif tok.type == TokenType.NAME then
     8       rvar = tok.value
           else
     2       error(string.format(
     1         "on (%s, %s), return value must be 'self' or a name.",
     1         tok.line,
               tok.col
     1       ))
           end
         end

         --(2) return
    78   return rvar
       end

       --Read a type statement.
       --
       --@return TypeStmt
     1 function StmtParser:nextType(annots)
    14   local lexer, parser = self._.lexer, self._.parser
         local tok, ln, col, visib, name, params, btype, bargs, body, catch, fin

         --(1) read visibility
    14   tok = lexer:advance()
    14   ln, col = tok.line, tok.col

    14   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
     3     lexer:next()
     3     visib = tok.value
         end

         --(2) read type name
    14   lexer:next(TokenType.KEYWORD, "type")
    14   name = lexer:next(TokenType.NAME).value

         --(3) read parameters
    14   params = self:_readFnParams()

         --(4) read base type
    14   tok = lexer:advance()

    14   if tok.type == TokenType.SYMBOL and tok.value == ":" then
     5     lexer:next()
     5     btype = lexer:next(TokenType.NAME).value

     5     tok = lexer:advance()
     5     if tok.type == TokenType.SYMBOL and tok.value == "(" then
     3       lexer:next()
     3       bargs = {}

     3       tok = lexer:advance()
     3       if not (tok.type == TokenType.SYMBOL and tok.value == ")") then
               while true do
     4           table.insert(bargs, parser:nextExp())

     4           tok = lexer:advance()
     4           if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
                   break
                 end

     2           lexer:next(TokenType.SYMBOL, ",")
               end
             end

     3       lexer:next(TokenType.SYMBOL, ")")
           end
         end

         --(5) read body
    14   lexer:next(TokenType.EOL)
    14   body = self:_readBody(2, col)

         --(6) read rest
    14   catch = self:_readCatch(col)
    14   fin = self:_readFinally(col)

         --(6) return
    14   return TypeStmt.new(ln, col, annots, visib, name, params, btype, bargs, body, catch, fin)
       end

       --Read an async statement.
       --
       --@return AsyncStmt
     1 function StmtParser:nextAsync()
     8   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, opts, body, catch

         --(1) read async keyword
     8   tok = lex:next(TokenType.KEYWORD, "async")
     8   ln, col = tok.line, tok.col

         --(2) read options
     8   opts = {}
     8   tok = lex:advance()

     8   if tok.type == TokenType.KEYWORD and tok.value == "with" then
     2     lex:next()
     2     lex:next(TokenType.SYMBOL, "{")
     2     lex:next(TokenType.NAME, "delay")
     2     lex:next(TokenType.SYMBOL, "=")
     2     opts.delay = parser:nextExp()
     2     lex:next(TokenType.SYMBOL, "}")
         end

         --(2) read body
     8   tok = lex:advance()

     8   if tok.type == TokenType.EOL then
     5     lex:next()
     5     body = self:_readBody(2, col)
     5     catch = self:_readCatch(col)
         else
     3     body = self:_readBody(1, col)
         end

         --(3) return
     8   return AsyncStmt.new(ln, col, opts, body, catch)
       end

       --Read an if statement.
       --
       --@return IfStmt
     1 function StmtParser:nextIf()
    14   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, cond, body, elif, el

         --(1) read if keyword
    14   tok = lex:next(TokenType.KEYWORD, "if")
    14   ln, col = tok.line, tok.col

         --.(2) read condition
    14   cond = parser:nextExp()
    14   lex:next(TokenType.KEYWORD, "then")

    14   tok = lex:advance()

    14   if tok.type ~= TokenType.EOL then
     7     body = {parser:next()}

     7     tok = lex:advance()
     7     if tok and tok.type == TokenType.KEYWORD and tok.value == "else" then
     3       lex:next()
     3       el = {parser:next()}
           end
         else
     7     lex:next(TokenType.EOL)
     7     body = self:_readBody(2, col)

           while true do
    17       tok = lex:advance()

    17       if tok == nil or tok.col ~= col then
               break
             end

    10       if tok.type == TokenType.KEYWORD and tok.value == "else" then
    10         tok = lex:advance(2)

    10         if tok.type == TokenType.KEYWORD and tok.value == "if" then
                 local c, b

     7           lex:next()  --else
     7           lex:next()  --if
     7           c = parser:nextExp()
     7           lex:next(TokenType.KEYWORD, "then")
     7           lex:next(TokenType.EOL)
     7           b = self:_readBody(2, col)

     7           if elif == nil then
     5             elif = {}
                 end

     7           table.insert(elif, {cond = c, body = b})
               else
     3           lex:next()  --else
     3           el = self:_readBody(2, col)
               end
             else
               break
             end
           end
         end

         --(3) return
    14   return IfStmt.new(ln, col, cond, body, elif, el)
       end

       --Read a pub statement.
       --
       --@return PubStmt
     1 function StmtParser:nextPub()
     8   local lex = self._.lexer
         local tok, ln, col, items

         --(1) read pub keyword
     8   tok = lex:next(TokenType.KEYWORD, "pub")
     8   ln, col = tok.line, tok.col

         --(2) read items
     8   items = {}

         while true do
           --item
    10     tok = lex:advance()

    10     if tok and tok.type == TokenType.LITERAL and type(tok.value) == "string" then
     4       lex:next()
     4       table.insert(items, {type = "use", value = tok.value})
     6     elseif tok and tok.type == TokenType.NAME then
     5       lex:next()
     5       table.insert(items, {type = "pub", value = tok.value})
           else
     1       error(string.format("on (%s,%s), literal text or name expected.", tok.line, tok.col))
           end

           --end or next?
     9     tok = lex:next()

     9     if tok.type == TokenType.EOL then
             break
           else
     3       if tok.type ~= TokenType.SYMBOL or tok.value ~= "," then
     1         error(string.format("on (%s,%s), comma expected.", tok.line, tok.col))
             end
           end
         end

         --(3) return
     6   return PubStmt.new(ln, col, items)
       end

       --Read an export statement.
       --
       --@return ExportStmt
     1 function StmtParser:nextExport()
     3   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, exp

         --(1) read
     3   tok = lex:next(TokenType.KEYWORD, "export")
     3   ln, col = tok.line, tok.col

     3   exp = parser:nextExp()
     2   lex:next(TokenType.EOL)

         --(2) return
     2   return ExportStmt.new(ln, col, exp)
       end

       --Read a with statement.
       --
       --@return WithStmt
     1 function StmtParser:nextWith()
     8   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, val, ifs, els

         --(1) read with
     8   tok = lex:next(TokenType.KEYWORD, "with")
     8   ln, col = tok.line, tok.col

     8   val = parser:nextExp()
     7   lex:next(TokenType.EOL)

         --(2) read ifs
     7   ifs = {}

         while true do
           local cond, ifCol, body

    17     tok = lex:advance()
    17     if not (tok and tok.type == TokenType.KEYWORD and tok.value == "if" and tok.col > col) then
             break
           end

    10     lex:next()  --if
    10     ifCol = tok.col
    10     cond = parser:nextExp()
    10     lex:next(TokenType.KEYWORD, "then")
    10     body = self:_readBody(2, ifCol)

    10     table.insert(ifs, {cond = cond, body = body})
         end

         --(3) read else
     7   tok = lex:advance()

     7   if tok and tok.type == TokenType.KEYWORD and tok.value == "else" and tok.col > col then
     3     lex:next()
     3     els = self:_readBody(2, tok.col)
         end

         --(4) return
     7   return WithStmt.new(ln, col, val, ifs, els)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtType.lua
==============================================================================
     1 return {
     1   ASYNC = "async",
     1   BREAK = "break",
     1   CONST = "const",
     1   DO = "do",
     1   ENUM = "enum",
     1   EXPORT = "export",
     1   FN = "fn",
     1   FOR = "for",
     1   FOR_EACH = "for each",
     1   FROM = "from",
     1   IF = "if",
     1   NEXT = "next",
     1   PUB = "pub",
     1   RETURN = "return",
     1   TYPE = "type",
     1   USE = "use",
     1   VAR = "var",
     1   WHILE = "while",
     1   WITH = "with",
     1   YIELD = "yield"
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/TerminalType.lua
==============================================================================
     1 return {
     1   NAME = 1,
     1   NUM = 2,
     1   TEXT = 3,
     1   TRUE = 4,
     1   FALSE = 5,
     1   NIL = 6,
     1   LIST = 7,
     1   MAP = 8,
     1   SELF = 9,
     1   SUPER = 10,
     1   FN = 11,
     1   SUBEXP = 12,
     1   IF = 13,
     1   PEVAL = 14,
     1   THROW = 15,
     1   NOP = 16,
     1   NATIVE = 17
     1 }

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/UnpackParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SubParser = require("dogma.syn._.SubParser")
     1 local Unpack = require("dogma.syn._.Unpack")
     1 local DataAccess = require("dogma.syn._.DataAccess")

       --An unpack sentence parser.
     1 local UnpackParser = {}
     1 UnpackParser.__index = UnpackParser
     1 setmetatable(UnpackParser, {__index = SubParser})
     1 package.loaded[...] = UnpackParser

       --Constructor.
       --
       --@param parser:Parser  Parent parser.
     1 function UnpackParser.new(parser)
   555   return setmetatable(SubParser.new(parser), UnpackParser)
       end

       --Parse the next unpack sentence.
       --
       --@return Unpack
     1 function UnpackParser:next()
    44   local lex, parser = self._.lexer, self._.parser
         local tok, ln, col, visib, def, typ, vars, assign, exp

         --(1) read visibility if needed
    44   tok = lex:advance()
    44   ln, col = tok.line, tok.col

    44   if tok.type == TokenType.KEYWORD and (tok.value == "export" or tok.value == "pub") then
    13     lex:next()
    13     visib = tok.value
         end

         --(2) get type definition
    44   tok = lex:advance()

    44   if tok.type == TokenType.KEYWORD and (tok.value == "var" or tok.value == "const") then
    22     lex:next()
    22     def = tok.value
         end

         --(3) get type
    44   tok = lex:next()

    44   if tok.type == TokenType.SYMBOL and tok.value == "[" then
    29     typ = "[]"
         else
    15     typ = "{}"
         end

         --(4) get vars
    44   vars = {}

         while true do
           local mod, name, val

           --visib
   107     tok = lex:advance()

   107     if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
    16       lex:next()
    16       mod = tok.value
    91     elseif tok.type == TokenType.SYMBOL and tok.value == "..." then
     6       if typ == "{}" then
     1         error(string.format("on (%s,%s), '...' only allowed with list unpack.", tok.line, tok.col))
             else
     5         lex:next()
     5         mod = tok.value
             end
           end

           --name, name=val, name{...}
   106     name = lex:next(TokenType.NAME).value

   106     tok = lex:advance()
   106     if tok.type == TokenType.SYMBOL and tok.value == "{" then
     4       if typ == "{}" then
     1         error(string.format("on (%s,%s), 'object{}' only allowed with list unpack.", tok.line, tok.col))
             else
     3         lex:next(TokenType.SYMBOL, "{")

               while true do
     5           table.insert(vars, DataAccess.new(mod, name .. "." .. lex:next(TokenType.NAME).value))

     5           tok = lex:advance()
     5           if not (tok.type == TokenType.SYMBOL and tok.value == ",") then
                   break
                 end

     2           lex:next(TokenType.SYMBOL, ",")
               end

     3         lex:next(TokenType.SYMBOL, "}")
             end
           else
             while true do
   110         tok = lex:advance()

   110         if tok.type == TokenType.SYMBOL and (tok.value == "." or tok.value == ":") then
     8           lex:next()
     8           name = name .. tok.value .. lex:next(TokenType.NAME).value
               else
                 break
               end
             end

   102       tok = lex:advance()

   102       if tok.type == TokenType.SYMBOL and tok.value == "=" then
     6         lex:next()
     6         val = parser:nextExp()
             end

   102       table.insert(vars, DataAccess.new(mod, name, val))
           end

           --comma or end
   105     tok = lex:advance()

   105     if typ == "[]" then
    80       if tok.type == TokenType.SYMBOL and tok.value == "]" then
    29         lex:next()
               break
             end
    25     elseif typ == "{}" then
    25       if tok.type == TokenType.SYMBOL and tok.value == "}" then
    13         lex:next()
               break
             end
           end

    63     lex:next(TokenType.SYMBOL, ",")
         end

         --(5) expression
    42   tok = lex:advance()
    42   if typ == "[]" then
    29     if not (tok.type == TokenType.SYMBOL and (tok.value == "=" or tok.value == ":=" or tok.value == "?=")) then
     1       error(string.format("on (%s,%s), '=', ':=' or '?=' expected.", tok.line, tok.col))
           end
         else
    13     if not (tok.type == TokenType.SYMBOL and (tok.value == "=" or tok.value == ":=")) then
     1       error(string.format("on (%s,%s), '=' or ':=' expected.", tok.line, tok.col))
           end
         end

    40   lex:next()
    40   assign = tok.value
    40   exp = parser:nextExp()
    40   lex:next(TokenType.EOL)

         --(6) return
    40   return Unpack.new(ln, col, visib, def, typ, vars, assign, exp)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AsyncStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An async statement.
     1 local AsyncStmt = {}
     1 AsyncStmt.__index = AsyncStmt
     1 setmetatable(AsyncStmt, {__index = Stmt})
     1 package.loaded[...] = AsyncStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param opts:object
       --@param body:Sent[]
       --@param catch:CatchCls
     1 function AsyncStmt.new(ln, col, opts, body, catch)
         local self

         --(1) create
     8   self = setmetatable(Stmt.new(StmtType.ASYNC, ln, col), AsyncStmt)
     8   self.opts = opts
     8   self.body = body
     8   self.catch = catch

         --(2) return
     8   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BinOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A binary operator.
     1 local BinOp = {}
     1 BinOp.__index = BinOp
     1 setmetatable(BinOp, {__index = Op})
     1 package.loaded[...] = BinOp

       --Constructor.
       --
       --@param tok:Token
     1 function BinOp.new(tok)
         local self

         --(1) create
   426   self = setmetatable(Op.new("b", tok), BinOp)
   426   self.children = {}

         --(2) return
   426   return self
       end

       --@override
     1 function BinOp:insert(node)
         -- if #self.children == 2 then
         --   error("children already set.")
         -- end

   874   table.insert(self.children, node)
   874   node.parent = self
       end

       --@override
     1 function BinOp:remove(node)
         -- if #self.children == 0 then
         --   error("no child to remove from the operator.")
         -- end

    25   return table.remove(self.children)
       end

       --@override
     1 function BinOp:isWellFormed()
   901   return #self.children == 2
       end

       --@override
     1 function BinOp:__tostring()
   355   return string.format("(%s %s %s)", self.op, self.children[1], self.children[2])
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BlockParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local SubParser = require("dogma.syn._.SubParser")

       --An expression parser.
     1 local BlockParser = {}
     1 BlockParser.__index = BlockParser
     1 setmetatable(BlockParser, {__index = SubParser})
     1 package.loaded[...] = BlockParser

       --Constructor.
       --
       --@param parser:Parser  Parser to use.
       --@param col:number     Column number.
     1 function BlockParser.new(parser, col)
         local self

   177   self = setmetatable(SubParser.new(parser), BlockParser)
   177   if col == nil then
     9     self._.col = 0
     9     self._.type = "end"
         else
   168     self._.col = col
   168     self._.type = "\n"
         end

   177   return self
       end

       --Parse the next block.
       --
       --@return Sent[]
     1 function BlockParser:next()
   177   local lex, parser, btype = self._.lexer, self._.parser, self._.type
         local tok
   177   local col, block = self._.col, {}

         --(1) see if empty function
   177   if btype == "end" then
     9     tok = lex:advance()

     9     if tok.type == TokenType.KEYWORD and tok.value == "end" then
     7       lex:next()
     7       return block
           end
         end

         --(1) read
         while true do
           local sent

   292     tok = lex:advance()

           --remove white lines
   417     while tok and tok.type == TokenType.EOL do
   125       lex:next()
   125       tok = lex:advance()
           end

   292     if btype == "end" and tok and tok.type == TokenType.KEYWORD and tok.value == "end" then
             break
           end

   290     if tok == nil or tok.col <= col then
             break
           end

           --parse next sentence
   122     sent = parser:next()

   122     if sent then
   122       table.insert(block, sent)
           else
             break
           end
         end

         --(3) read } if needed
   170   if btype == "end" then
     2     lex:next(TokenType.KEYWORD, "end")
         end

         --(3) return
   170   return block
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BreakStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A break statement.
     1 local BreakStmt = {}
     1 BreakStmt.__index = BreakStmt
     1 setmetatable(BreakStmt, {__index = Stmt})
     1 package.loaded[...] = BreakStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function BreakStmt.new(ln, col)
     3   return setmetatable(Stmt.new(StmtType.BREAK, ln, col), BreakStmt)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CallOp.lua
==============================================================================
       --imports
     1 local NaryOp = require("dogma.syn._.NaryOp")

       --A call operator.
     1 local CallOp = {}
     1 CallOp.__index = CallOp
     1 setmetatable(CallOp, {__index = NaryOp})
     1 package.loaded[...] = CallOp

       --Constructor.
       --
       --@param tok:Token
     1 function CallOp.new(tok)
         local self

         --(1) create
   101   self = setmetatable(NaryOp.new(tok), CallOp)
   101   self.children = {}
   101   self.finished = false

         --(2) return
   101   return self
       end

       --@override
     1 function CallOp:__tostring()
         local ops

         --(1) get expressions
    70   ops = ""
   198   for _, op in ipairs(self.children) do
   128     ops = ops .. (ops == "" and "" or " ") .. op:__tostring()
         end

         --(2) return
    70   return string.format("(call %s)", ops)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CatchCl.lua
==============================================================================
       --A catch clause.
     1 local CatchCl = {}
     1 CatchCl.__index = CatchCl
     1 package.loaded[...] = CatchCl

       --Constructor.
       --
       --@param var:string Exception variable name.
       --@param body:Body  Body sentences.
     1 function CatchCl.new(var, body)
    38   return setmetatable({
    19     var = var,
    19     body = body
    38   }, CatchCl)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ConstStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A var statement.
     1 local ConstStmt = {}
     1 ConstStmt.__index = ConstStmt
     1 setmetatable(ConstStmt, {__index = Stmt})
     1 package.loaded[...] = ConstStmt

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param visib:string Visibility: export or pub.
     1 function ConstStmt.new(ln, col, visib)
         local self

         --(1) create
    15   self = setmetatable(Stmt.new(StmtType.CONST, ln, col), ConstStmt)
    15   self.vars = {}
    15   self.visib = visib

         --(2) return
    15   return self
       end

       --Add a variable declaration.
       --
       --@param name:string  Variable name.
       --@param val?:Exp     Default value.
     1 function ConstStmt:insert(name, val)
    17   table.insert(self.vars, {name = name, value = val})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DataAccess.lua
==============================================================================
       --Data access.
     1 local DataAccess = {}
     1 DataAccess.__index = DataAccess
     1 package.loaded[...] = DataAccess

       --Constructor.
     1 function DataAccess.new(mod, name, value)
   107   return setmetatable({mod = mod, name = name, value = value}, DataAccess)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Directive.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --A directive.
       --@abstract
     1 local Directive = {}
     1 Directive.__index = Directive
     1 setmetatable(Directive, {__index = Sent})
     1 package.loaded[...] = Directive

       --Constructor.
       --
       --@param subtype:DirectiveType  Directive type.
       --@param ln:number              Line number.
       --@param col:number             Column number.
     1 function Directive.new(subtype, ln, col)
         local self

         --(1) create
    14   self = setmetatable(Sent.new(SentType.DIRECTIVE, ln, col), Directive)
    14   self.subtype = subtype

         --(2) return
    14   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DoStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A while statement.
     1 local DoStmt = {}
     1 DoStmt.__index = DoStmt
     1 setmetatable(DoStmt, {__index = Stmt})
     1 package.loaded[...] = DoStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param body:Sent[]
       --@param cond?:Exp
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function DoStmt.new(ln, col, body, cond, catch, fin)
         local self

         --(1) create
    11   self = setmetatable(Stmt.new(StmtType.DO, ln, col), DoStmt)
    11   self.body = body
    11   self.cond = cond
    11   self.catch = catch
    11   self.finally = fin

         --(2) return
    11   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/EnumStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An enum statement.
     1 local EnumStmt = {}
     1 EnumStmt.__index = EnumStmt
     1 setmetatable(EnumStmt, {__index = ObjectStmt})
     1 package.loaded[...] = EnumStmt

       --Constructor.
     1 function EnumStmt.new(ln, col, annots, visib, name)
         local self

         --(1) create
    28   self = setmetatable(ObjectStmt.new(StmtType.ENUM, ln, col, name, visib), EnumStmt)
    28   self.items = {}
    28   self.annots = annots or {}
    28   self._.lastValue = nil

         --(2) return
    28   return self
       end

       --Insert an item.
       --
       --@param item:string    Item name.
       --@param value:any      Item value.
     1 function EnumStmt:insert(item, value)
         --(1) set value if needed
    40   if value == nil then
    19     if self._.lastValue == nil then
    11       self._.lastValue = 1
           else
     8       self._.lastValue = self._.lastValue + 1
           end

    19     value = self._.lastValue
         end

         --(2) insert
    40   table.insert(self.items, {name = item, value = value})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Exp.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")
     1 local SyntaxTree = require("dogma.syn._.SyntaxTree")

       --An expression.
     1 local Exp = {}
     1 Exp.__index = Exp
     1 setmetatable(Exp, {__index = Sent})
     1 package.loaded[...] = Exp

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function Exp.new(ln, col)
         local self

         --(1) create
   797   self = setmetatable(Sent.new(SentType.EXP, ln, col), Exp)
   797   self.tree = SyntaxTree.new()

         --(2) return
   797   return self
       end

       --Add a new node to the expression.
       --
       --@param node:Node  Node to add.
     1 function Exp:insert(node)
  1777   self.tree:insert(node)
       end

       --@override
     1 function Exp:__tostring()
   695   return self.tree:__tostring()
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ExportStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An export statement.
     1 local ExportStmt = {}
     1 ExportStmt.__index = ExportStmt
     1 setmetatable(ExportStmt, {__index = Stmt})
     1 package.loaded[...] = ExportStmt

       --Constructor.
     1 function ExportStmt.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Stmt.new(StmtType.EXPORT, ln, col), ExportStmt)
     2   self.exp = exp

         --(2) return
     2   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FinallyCl.lua
==============================================================================
       ----A finally clause.
     1 local FinallyCl = {}
     1 FinallyCl.__index = FinallyCl
     1 package.loaded[...] = FinallyCl

       --Constructor.
       --
       --@param body:Body  Body sentences.
     1 function FinallyCl.new(body)
    26   return setmetatable({
    13     body = body
    26   }, FinallyCl)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FnStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A fn statement.
     1 local FnStmt = {}
     1 FnStmt.__index = FnStmt
     1 setmetatable(FnStmt, {__index = ObjectStmt})
     1 package.loaded[...] = FnStmt

       --Constructor.
     1 function FnStmt.new(ln, col, annots, visib, itype, name, params, rtype, rvar, body, catch, fin)
         local self

         --(1) create
    66   self = setmetatable(ObjectStmt.new(StmtType.FN, ln, col, name, visib), FnStmt)
    66   self.itype = itype
    66   self.params = params
    66   self.rtype = rtype
    66   self.rvar = rvar
    66   self.body = body
    66   self.catch = catch
    66   self.finally = fin
    66   self.annots = annots or {}

         --(2) return
    66   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForEachStmt.lua
==============================================================================
       --Imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A for each statement.
     1 local ForEachStmt = {}
     1 ForEachStmt.__index = ForEachStmt
     1 setmetatable(ForEachStmt, {__index = Stmt})
     1 package.loaded[...] = ForEachStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param key?:string
       --@param value:string
       --@param iter:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function ForEachStmt.new(ln, col, key, val, iter, body, catch, fin)
         local self

         --(1) create
    10   self = setmetatable(Stmt.new(StmtType.FOR_EACH, ln, col), ForEachStmt)
    10   self.key = key
    10   self.value = val
    10   self.iter = iter
    10   self.body = body
    10   self.catch = catch
    10   self.finally = fin

         --(2) return
    10   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForStmt.lua
==============================================================================
       --Imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A for statement.
     1 local ForStmt = {}
     1 ForStmt.__index = ForStmt
     1 setmetatable(ForStmt, {__index = Stmt})
     1 package.loaded[...] = ForStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param def:VarStmt
       --@param cond:Exp
       --@param iter:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function ForStmt.new(ln, col, def, cond, iter, body, catch, fin)
         local self

         --(1) create
    12   self = setmetatable(Stmt.new(StmtType.FOR, ln, col), ForStmt)
    12   self.def = def
    12   self.cond = cond
    12   self.iter = iter
    12   self.body = body
    12   self.catch = catch
    12   self.finally = fin

         --(2) return
    12   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FromStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A from statement.
     1 local FromStmt = {}
     1 FromStmt.__index = FromStmt
     1 setmetatable(FromStmt, {__index = Stmt})
     1 package.loaded[...] = FromStmt

       --Constructor.
     1 function FromStmt.new(ln, col, mod)
         local self

         --(1) create
     8   self = setmetatable(Stmt.new(StmtType.FROM, ln, col), FromStmt)
     8   self.module = mod
     8   self.members = {}

         --(2) return
     8   return self
       end

       --Insert an imported member.
       --
       --@param name:string  Member name to import.
       --@param as?:string   Name to use in the code.
     1 function FromStmt:insert(name, as)
    12   table.insert(self.members, {name = name, as = as or name})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfDirective.lua
==============================================================================
       --imports
     1 local Directive = require("dogma.syn._.Directive")
     1 local DirectiveType = require("dogma.syn.DirectiveType")

       --An if directive.
     1 local IfDirective = {}
     1 IfDirective.__index = IfDirective
     1 setmetatable(IfDirective, {__index = Directive})
     1 package.loaded[...] = IfDirective

       --Constructor.
     1 function IfDirective.new(ln, col, cond, body, el)
         local self

         --(1) create
    11   self = setmetatable(Directive.new(DirectiveType.IF, ln, col), IfDirective)
    11   self.cond = cond
    11   self.body = body
    11   self.el = el

         --(2) return
    11   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfStmt.lua
==============================================================================
       --importsa
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --An if statement.
     1 local IfStmt = {}
     1 IfStmt.__index = IfStmt
     1 setmetatable(IfStmt, {__index = Stmt})
     1 package.loaded[...] = IfStmt

       --Constructor.
     1 function IfStmt.new(ln, col, cond, body, elif, el)
         local self

         --(1) create
    14   self = setmetatable(Stmt.new(StmtType.IF, ln, col), IfStmt)
    14   self.cond = cond
    14   self.body = body
    14   self.elif = elif
    14   self.el = el

         --(2) return
    14   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfSubExp.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An (if Exp then Exp else Exp) subexpression.
     1 local IfSubExp = {}
     1 IfSubExp.__index = IfSubExp
     1 setmetatable(IfSubExp, {__index = Terminal})
     1 package.loaded[...] = IfSubExp

       --Constructor.
     1 function IfSubExp.new(ln, col, cond, ifTrue, ifFalse)
         local self

         --(1) create
     3   self = setmetatable(Terminal.new(TerminalType.IF, {line = ln, col = col}), IfSubExp)
     3   self.cond = cond
     3   self.trueCase = ifTrue
     3   self.falseCase = ifFalse

         --(2) return
     3   return self
       end

       --@override
     1 function IfSubExp:__tostring()
     4   return string.format(
     2     "(if %s %s %s)",
     2     tostring(self.cond),
     2     tostring(self.trueCase),
     2     tostring(self.falseCase)
     2   )
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --An array terminal node.
     1 local LiteralFn = {}
     1 LiteralFn.__index = LiteralFn
     1 setmetatable(LiteralFn, {__index = Terminal})
     1 package.loaded[...] = LiteralFn

       --Constructor.
     1 function LiteralFn.new(ln, col, params, rtype, rvar, body)
         local self

    33   self = setmetatable(Terminal.new(TerminalType.FN, {
    11     line = ln,
    11     col = col,
    11     value = {
    11       params = params,
    11       type = rtype,
    11       rvar = rvar,
    11       body = body
    11     }
    22   }), LiteralFn)

    11   return self
       end

       --@override
     1 function LiteralFn:__tostring()
         local desc

    24   desc = "fn("
    48   for i, p in ipairs(self.data.params) do
    24     desc = desc .. (i == 1 and "" or ", ") .. p.name
         end
    24   desc = desc .. ")"

    24   desc = desc .. "{"
    48   for i, s in ipairs(self.data.body) do
    24     desc = desc .. (i == 1 and "" or "; ") .. tostring(s)
         end
    24   desc = desc .. "}"

    24   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralList.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A literal list node.
     1 local LiteralList = {}
     1 LiteralList.__index = LiteralList
     1 setmetatable(LiteralList, {__index = Terminal})
     1 package.loaded[...] = LiteralList

       --Constructor.
     1 function LiteralList.new(ln, col, arr)
    11   return setmetatable(Terminal.new(TerminalType.LIST, {line = ln, col = col, value = arr}), LiteralList)
       end

       --@override
     1 function LiteralList:__tostring()
         local desc

    48   desc = "["
   138   for i, v in ipairs(self.data) do
    90     desc = desc .. (i == 1 and "" or ", ") .. tostring(v)
         end
    48   desc = desc .. "]"

    48   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralMap.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A map terminal node.
     1 local LiteralMap = {}
     1 LiteralMap.__index = LiteralMap
     1 setmetatable(LiteralMap, {__index = Terminal})
     1 package.loaded[...] = LiteralMap

       --Constructor.
     1 function LiteralMap.new(ln, col, map)
    11   return setmetatable(Terminal.new(TerminalType.MAP, {line = ln, col = col, value = map}), LiteralMap)
       end

       --@override
     1 function LiteralMap:__tostring()
         local desc

    48   desc = "{"
   132   for i, e in ipairs(self.data) do
    84     desc = desc .. (i == 1 and "" or ", ") .. e.name .. " = " .. tostring(e.value)
         end
    48   desc = desc .. "}"

    48   return desc
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NaryOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A n-ary operator.
     1 local NaryOp = {}
     1 NaryOp.__index = NaryOp
     1 setmetatable(NaryOp, {__index = Op})
     1 package.loaded[...] = NaryOp

       --Constructor.
       --
       --@param tok:Token
     1 function NaryOp.new(tok)
         local self

         --(1) create
   113   self = setmetatable(Op.new("n", tok), NaryOp)
   113   self.children = {}
   113   self.finished = false

         --(2) return
   113   return self
       end

       --@override
     1 function NaryOp:insert(node)
   198   if self.finished then
     2     error(string.format(
     1       "(%s,%s): node can't be inserted to full call.",
     1       node.tok.line,
     1       node.tok.col
     1     ))
         end

   197   table.insert(self.children, node)
       end

       --@override
     1 function NaryOp.remove()
     1   error("call operator can't remove children.")
       end

       --@override
     1 function NaryOp:isWellFormed()
   109   return self.finished
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NativeFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A native code.
     1 local NativeFn = {}
     1 NativeFn.__index = NativeFn
     1 setmetatable(NativeFn, {__index = Terminal})
     1 package.loaded[...] = NativeFn

       --Constructor.
     1 function NativeFn.new(ln, col, code)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.NATIVE, {line = ln, col = col}), NativeFn)
     2   self.code = code

         --(2) return
     2   return self
       end

       --@override
     1 function NativeFn:__tostring()
     1   return string.format('(native "%s")', self.code)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NextStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A next statement.
     1 local NextStmt = {}
     1 NextStmt.__index = NextStmt
     1 setmetatable(NextStmt, {__index = Stmt})
     1 package.loaded[...] = NextStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
     1 function NextStmt.new(ln, col)
     3   return setmetatable(Stmt.new(StmtType.NEXT, ln, col), NextStmt)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Node.lua
==============================================================================
       --A node.
     1 local Node = {}
     1 Node.__index = Node
     1 package.loaded[...] = Node

       --Constructor.
       --
       --@param t:string           Node type.
     1 function Node.new(t, tok)
  5160   return setmetatable({
  2580     type = t,
  2580     parent = nil,
  2580     token = tok
  5160   }, Node)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NonTerminal.lua
==============================================================================
       --imports
     1 local Node = require("dogma.syn._.Node")
     1 local NodeType = require("dogma.syn.NodeType")

       --A non-terminal node, that is, a branch.
     1 local NonTerminal = {}
     1 NonTerminal.__index = NonTerminal
     1 setmetatable(NonTerminal, {__index = Node})
     1 package.loaded[...] = NonTerminal

       --Constructor.
       --
       --@param sub:NonTerminalType
       --@param tok:Token
     1 function NonTerminal.new(sub, tok)
         local self

         --(1) create
  1375   self = setmetatable(Node.new(NodeType.NON_TERMINAL, tok), NonTerminal)
  1375   self.subtype = sub

         --(2) return
  1375   return self
       end

       --Add a node to the non-terminal.
       --
       --@param child:Node Node to add.
     1 function NonTerminal.insert()
     1   error("abstract node.")
       end

       --Remove and return last child for transfering to other node.
       --
       --@return Node
     1 function NonTerminal.remove()
     1   error("abstract node.")
       end

       --Is it well-formed?
       --
       --@return bool
       -- function NonTerminal:isWellFormed()
       --   error("abstract method.")
       -- end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ObjectStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")

       --A statement for defining an object.
     1 local ObjectStmt = {}
     1 ObjectStmt.__index = ObjectStmt
     1 setmetatable(ObjectStmt, {__index = Stmt})
     1 package.loaded[...] = ObjectStmt

       --Constructor.
       --
       --@param sub:StmtType   Statement type.
       --@param ln:number      Line number.
       --@param col:number     Column number.
       --@param name:string    Object name.
       --@param visib:string   export or pub if indicated?
     1 function ObjectStmt.new(sub, ln, col, name, visib)
         local self

         --(1) create
   108   self = setmetatable(Stmt.new(sub, ln, col), ObjectStmt)
   108   self.name = name
   108   self.visib = visib

         --(2) return
   108   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Op.lua
==============================================================================
       --imports
     1 local NonTerminal = require("dogma.syn._.NonTerminal")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")

       --An operator.
     1 local Op = {}
     1 Op.__index = Op
     1 setmetatable(Op, {__index = NonTerminal})
     1 package.loaded[...] = Op

       --Constructor.
       --
       --@param arity:string       Arity: u, b, t, n.
       --@param optor:string       The operator.
     1 function Op.new(arity, tok)
         local self

         --(1) create
   576   self = setmetatable(NonTerminal.new(NonTerminalType.OP, tok), Op)
   576   self.op = tok.value
   576   self.arity = arity
   576   local desc = self:getDesc()
   576   self.assoc = desc.assoc
   576   self.prec = desc.prec

         --(2) return
   576   return self
       end

       --Return the operator descriptor: assoc and prec.
     1 function Op:getDesc()
   576   local OPS = {
   576     ["u ."] = {assoc = "r", prec = 20},
   576     ["u :"] = {assoc = "r", prec = 20},

   576     ["b ."] = {assoc = "l", prec = 19},
   576     ["b :"] = {assoc = "l", prec = 19},
   576     ["b []"] = {assoc = "l", prec = 19},  --index
   576     ["t []"] = {assoc = "l", prec = 19},  --index
   576     ["n ()"] = {assoc = "l", prec = 19},  --call
   576     ["n {}"] = {assoc = "l", prec = 19},  --exp{}

   576     ["u !"] = {assoc = "r", prec = 18},
   576     ["u not"] = {assoc = "r", prec = 18},
   576     ["u ~"] = {assoc = "r", prec = 18},
   576     ["u +"] = {assoc = "r", prec = 18},
   576     ["u -"] = {assoc = "r", prec = 18},

   576     ["b **"] = {assoc = "r", prec = 17},

   576     ["b *"] = {assoc = "l", prec = 16},
   576     ["b /"] = {assoc = "l", prec = 16},
   576     ["b %"] = {assoc = "l", prec = 16},

   576     ["b +"] = {assoc = "l", prec = 15},
   576     ["b -"] = {assoc = "l", prec = 15},

   576     ["b <<"] = {assoc = "l", prec = 14},
   576     ["b >>"] = {assoc = "l", prec = 14},

   576     ["b <"] = {assoc = "l", prec = 13},
   576     ["b <="] = {assoc = "l", prec = 13},
   576     ["b >"] = {assoc = "l", prec = 13},
   576     ["b >="] = {assoc = "l", prec = 13},
   576     ["b in"] = {assoc = "l", prec = 13},
   576     ["b notin"] = {assoc = "l", prec = 13},
   576     ["b is"] = {assoc = "l", prec = 13},
   576     ["b isnot"] = {assoc = "l", prec = 13},
   576     ["b like"] = {assoc = "l", prec = 13},
   576     ["b notlike"] = {assoc = "l", prec = 13},

   576     ["b =="] = {assoc = "l", prec = 12},
   576     ["b ==="] = {assoc = "l", prec = 12},
   576     ["b !="] = {assoc = "l", prec = 12},
   576     ["b !=="] = {assoc = "l", prec = 12},

   576     ["b &"] = {assoc = "l", prec = 11},
   576     ["b ^"] = {assoc = "l", prec = 10},
   576     ["b |"] = {assoc = "l", prec = 9},

   576     ["b &&"] = {assoc = "l", prec = 8},
   576     ["b and"] = {assoc = "l", prec = 8},

   576     ["b ||"] = {assoc = "l", prec = 7},
   576     ["b or"] = {assoc = "l", prec = 7},

   576     ["b ="] = {assoc = "r", prec = 6},
   576     ["b :="] = {assoc = "r", prec = 6},
   576     ["b .="] = {assoc = "r", prec = 6},
   576     ["b +="] = {assoc = "r", prec = 6},
   576     ["b -="] = {assoc = "r", prec = 6},
   576     ["b *="] = {assoc = "r", prec = 6},
   576     ["b **="] = {assoc = "r", prec = 6},
   576     ["b /="] = {assoc = "r", prec = 6},
   576     ["b %="] = {assoc = "r", prec = 6},
   576     ["b <<="] = {assoc = "r", prec = 6},
   576     ["b >>="] = {assoc = "r", prec = 6},
   576     ["b &="] = {assoc = "r", prec = 6},
   576     ["b |="] = {assoc = "r", prec = 6},
   576     ["b ^="] = {assoc = "r", prec = 6},
   576     ["b ?="] = {assoc = "r", prec = 6},

   576     ["u ..."] = {assoc = "r", prec = 5}
         }

   576   return OPS[self.arity .. " " .. self.op]
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PackOp.lua
==============================================================================
       --imports
     1 local NaryOp = require("dogma.syn._.NaryOp")

       --A
     1 local PackOp = {}
     1 PackOp.__index = PackOp
     1 setmetatable(PackOp, {__index = NaryOp})
     1 package.loaded[...] = PackOp

       --Constructor.
       --
       --@param tok:Token
       --@param
     1 function PackOp.new(tok)
         local self

         --(1) create
    12   self = setmetatable(NaryOp.new(tok), PackOp)
    12   self.children = {}
    12   self.finished = false

         --(2) return
    12   return self
       end

       --@override
     1 function NaryOp:__tostring()
         local ops

         --(1) get expressions
    19   for ix, op in ipairs(self.children) do
    13     if ix == 1 then
     6       ops = op:__tostring()
           else
     7       ops = ops .. " " .. op.visib .. op.name
           end
         end

         --(2) return
     6   return string.format("(pack %s)", ops)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Param.lua
==============================================================================
       --A function parameter.
     1 local Param = {}
     1 Param.__index = Param
     1 package.loaded[...] = Param

       --Constructor.
       --
       --@param const:bool
       --@param mod?:string . or : or ....
       --@param name:string
       --@param opt:bool
       --@param dtype?:Exp
       --@param val?:Exp
     1 function Param.new(const, mod, name, opt, dtype, val)
         local self

         --(1) create
   140   self = setmetatable({
    70     const = const,
    70     modifier = mod,  --. or : or ...
    70     name = name,
    70     optional = not not opt,
    70     type = dtype,
    70     value = val
   140   }, Param)

         --(2) return
    70   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Params.lua
==============================================================================
       --A parameters list.
     1 local Params = {}
     1 Params.__index = Params
     1 setmetatable(Params, {__index = table})
     1 package.loaded[...] = Params

       --Constructor.
     1 function Params.new()
    96   return setmetatable({}, Params)
       end

       --Check whether a parameter exists.
       --
       --@param name:string  Parameter name.
       --@return bool
     1 function Params:has(name)
         local res

         --(1) check
     6   res = false

    10   for _, param in ipairs(self) do
     6     if param.name == name then
     2       res = true
             break
           end
         end

         --(2) return
     6   return res
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PevalFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A protected call.
     1 local PevalFn = {}
     1 PevalFn.__index = PevalFn
     1 setmetatable(PevalFn, {__index = Terminal})
     1 package.loaded[...] = PevalFn

       --Constructor.
     1 function PevalFn.new(ln, col, exp)
         local self

         --(1) create
     2   self = setmetatable(Terminal.new(TerminalType.PEVAL, {line = ln, col = col}), PevalFn)
     2   self.exp = exp

         --(2) return
     2   return self
       end

       --@override
     1 function PevalFn:__tostring()
     1   return string.format("(peval %s)", tostring(self.exp))
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PubStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")
     1 local UseStmt = require("dogma.syn._.UseStmt")

       --A pub statement.
     1 local PubStmt = {}
     1 PubStmt.__index = PubStmt
     1 setmetatable(PubStmt, {__index = Stmt})
     1 package.loaded[...] = PubStmt

       --Constructor.
     1 function PubStmt.new(ln, col, items)
         local self

         --(1) create
     6   self = setmetatable(Stmt.new(StmtType.PUB, ln, col), PubStmt)
     6   self.items = items

    14   for _, item in ipairs(items) do
     8     if item.type == "use" then
     4       item.value = {
     4         path = item.value,
     4         name = UseStmt.getNameFor(item.value)
     4       }
           end
         end

         --(2) return
     6   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ReturnStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A return statement.
     1 local ReturnStmt = {}
     1 ReturnStmt.__index = ReturnStmt
     1 setmetatable(ReturnStmt, {__index = Stmt})
     1 package.loaded[...] = ReturnStmt

       --Constructor.
       --
       --@param ln:number  Line number.
       --@param col:number Column number.
       --@param val?:Exp   Value to return.
     1 function ReturnStmt.new(ln, col, val)
         local self

         --(1) create
    24   self = setmetatable(Stmt.new(StmtType.RETURN, ln, col), ReturnStmt)
    24   if val then
     2     self.values = {val}
         else
    22     self.values = {}
         end

         --(2) return
    24   return self
       end

       --@override
     1 function ReturnStmt:__len()
     2   return #self.values
       end

       --Add a value.
       --
       --@param val:Exp  Value to add.
     1 function ReturnStmt:insert(val)
    20   table.insert(self.values, val)
       end

     1 function ReturnStmt:__tostring()
    24   if #self.values == 0 then
     3     return "return"
         else
    21     return "return " .. tostring(self.values[1])
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/RunWithDirective.lua
==============================================================================
       --imports
     1 local Directive = require("dogma.syn._.Directive")
     1 local DirectiveType = require("dogma.syn.DirectiveType")

       --A runWith directive.
     1 local RunWithDirective = {}
     1 RunWithDirective.__index = RunWithDirective
     1 setmetatable(RunWithDirective, {__index = Directive})
     1 package.loaded[...] = RunWithDirective

       --Constructor.
     1 function RunWithDirective.new(ln, col, cmd)
         local self

         --(1) create
     3   self = setmetatable(Directive.new(DirectiveType.RUNWITH, ln, col), RunWithDirective)
     3   self.cmd = cmd

         --(2) return
     3   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Sent.lua
==============================================================================
       --A sentence.
     1 local Sent = {}
     1 Sent.__index = Sent
     1 package.loaded[...] = Sent

       --Constructor.
     1 function Sent.new(t, ln, col)
  2272   return setmetatable({
  1136     type = t,
  1136     line = ln,
  1136     col = col,
  1136     _ = {}
  2272   }, Sent)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SliceOp.lua
==============================================================================
       --imports
     1 local Op = require("dogma.syn._.Op")

       --A slice operator: [,].
     1 local SliceOp = {}
     1 SliceOp.__index = SliceOp
     1 setmetatable(SliceOp, {__index = Op})
     1 package.loaded[...] = SliceOp

       --Constructor.
       --
       --@param tok:Token
     1 function SliceOp.new(tok)
         local self

     5   self = setmetatable(Op.new("t", tok), SliceOp)
     5   self.children = {}

     5   return self
       end

       --@override
     1 function SliceOp:insert(node)
         -- if #self.children == 3 then
         --   error("children already set.")
         -- end

    15   table.insert(self.children, node)
       end

       --@override
       -- function SliceOp.remove()
       --   error("slice operator can't remove children.")
       -- end

       --@override
     1 function SliceOp:isWellFormed()
     5   return #self.children == 3
       end

       --@override
     1 function SliceOp:__tostring()
    15   return string.format("(%s %s %s %s)", self.op, self.children[1], self.children[2], self.children[3])
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Stmt.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --A statement.
     1 local Stmt = {}
     1 Stmt.__index = Stmt
     1 setmetatable(Stmt, {__index = Sent})
     1 package.loaded[...] = Stmt

       --Constructor.
       --
       --@param sub:StmtType   Statement type.
       --@param ln:number      Line number.
       --@param col:number     Column number.
     1 function Stmt.new(sub, ln, col)
         local self

         --(1) create
   285   self = setmetatable(Sent.new(SentType.STMT, ln, col), Stmt)
   285   self.subtype = sub

         --(2) return
   285   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubExp.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A subexpression: (Exp).
     1 local SubExp = {}
     1 SubExp.__index = SubExp
     1 setmetatable(SubExp, {__index = Terminal})
     1 package.loaded[...] = SubExp

       --Constructor.
     1 function SubExp.new(ln, col, exp)
    11   return setmetatable(Terminal.new(TerminalType.SUBEXP, {line = ln, col = col, value = exp}), SubExp)
       end

       --@override
     1 function SubExp:__tostring()
     7   return tostring(self.data)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubParser.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")

       --A subparser.
     1 local SubParser = {}
     1 SubParser.__index = SubParser
     1 package.loaded[...] = SubParser

       --Constructor.
       --
       --@param Parser:Parser  Parent parser.
     1 function SubParser.new(parser)
         --(1) arguments
  2397   if not parser then error("parser expected.") end

         --(2) create
  4794   return setmetatable({
  2397     _ = {
  2397       parser = parser,
  2397       lexer = parser._.lexer
  2397     }
  4794   }, SubParser)
       end

       --Read next end of lines.
     1 function SubParser:_nextEols()
    16   local lex = self._.lexer

         while true do
    25     local tok = lex:advance()
    25     if tok.type == TokenType.EOL then
     9       lex:next()
           else
             break
           end
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SyntaxTree.lua
==============================================================================
       --imports
     1 local NodeType = require("dogma.syn.NodeType")
     1 local NonTerminal = require("dogma.syn._.NonTerminal")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")

       --A syntax tree, for example, an expression.
     1 local SyntaxTree = {}
     1 SyntaxTree.__index = SyntaxTree
     1 setmetatable(SyntaxTree, {__index = NonTerminal})
     1 package.loaded[...] = SyntaxTree

       --Constructor.
     1 function SyntaxTree.new()
         local self

         --(1) create
   797   self = setmetatable(NonTerminal.new(NonTerminalType.TREE), SyntaxTree)
   797   self.root = nil
   797   self._ = {
   797     current = nil
   797   }

         --(2) return
   797   return self
       end

       --@override
     1 function SyntaxTree:insert(node)
         --(1) arguments
  1777   if not node then error("node expected.") end

         --(2) add
  1777   if self.root == nil then --1st node to add
   788     self:_init(node)
         else
   989     self:_update(node)
         end
       end

     1 function SyntaxTree:_init(node)
   788   self.root = node

   788   if node.type == NodeType.NON_TERMINAL then
    26     self._.current = node
         end
       end

     1 function SyntaxTree:_update(node)
   989   if self.root.type == NodeType.TERMINAL then
   479     self:_updateTerminalRoot(node)
         else
   510     self:_updateFromCurrent(node)
         end
       end

       --Update the tree when this is well-formed with one terminal.
     1 function SyntaxTree:_updateTerminalRoot(node)
   479   if node.type == NodeType.TERMINAL then
     2     error(string.format(
     1       "(%s,%s): terminal can't follow to other terminal.",
     1       node.token.line,
     1       node.token.col
     1     ))
         end

         --node is non-terminal, for example, an operator
   478   node:insert(self.root)
   478   self.root = node
   478   self._.current = node
       end

       --Update th tree from the current node.
       --For example, when a+b for adding a call operator.
       --We use the precedence and the associativity for determining.
     1 function SyntaxTree:_updateFromCurrent(new)
   518   local cur = self._.current

   518   if self:isWellFormed() then
    73     if new.type == NodeType.TERMINAL then
     2       error(string.format(
     1         "on (%s,%s), invalid terminal node for well-formed expression.",
     1         new.token.line,
     1         new.token.col
     1       ))
           else
    72       if cur.prec > new.prec then
    30         self:_updateUpNodeFromCurrent(new)
    42       elseif cur.prec < new.prec then
    26         self:_updateDownNodeFromCurrent(new)
             else
    16         if cur.assoc == "l" then
    15           self:_updateUpNodeFromCurrent(new)
               else
     1           self:_updateDownNodeFromCurrent(new)
               end
             end
           end
         else  --non well-formed
   445     cur:insert(new)

   444     if new.type == NodeType.NON_TERMINAL then
     6       self._.current = new
           end
         end
       end

     1 function SyntaxTree:_updateUpNodeFromCurrent(node)
    45   if self.root == self._.current then
    37     node:insert(self.root)
    37     self.root = node
    37     self._.current = node
         else
     8     self._.current = self._.current.parent
     8     self:_updateFromCurrent(node)
         end
       end

     1 function SyntaxTree:_updateDownNodeFromCurrent(node)
    27   node:insert(self._.current:remove())
    27   self._.current:insert(node)
    27   self._.current = node
       end

       --@override
     1 function SyntaxTree:__tostring()
   695   return self.root:__tostring()
       end

       --@override
     1 function SyntaxTree:isWellFormed()
  1750   if not self.root then
    33     return false
  1717   elseif self.root.type == NodeType.TERMINAL then
   633     return true
         else
  1084     return self._.current:isWellFormed()
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Terminal.lua
==============================================================================
       --imports
     1 local TokenType = require("dogma.lex.TokenType")
     1 local Node = require("dogma.syn._.Node")
     1 local NodeType = require("dogma.syn.NodeType")

       --A terminal node.
     1 local Terminal = {}
     1 Terminal.__index = Terminal
     1 setmetatable(Terminal, {__index = Node})
     1 package.loaded[...] = Terminal

       --Constructor.
       --
       --@param sub:TerminalTtype
       --@param tok:Token
     1 function Terminal.new(sub, tok)
         local self

         --(1) create
  1205   self = setmetatable(Node.new(NodeType.TERMINAL, tok), Terminal)
  1205   self.subtype = sub
  1205   self.data = tok.value

         --(2) return
  1205   return self
       end

       --@override
     1 function Terminal:__tostring()
   968   return string.format("%s", self.data)
       end

       --Is it an identifier?
       --
       --@return bool
     1 function Terminal:isId()
    15   return self.token.type == TokenType.NAME
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ThrowFn.lua
==============================================================================
       --imports
     1 local Terminal = require("dogma.syn._.Terminal")
     1 local TerminalType = require("dogma.syn.TerminalType")

       --A throw function.
     1 local ThrowFn = {}
     1 ThrowFn.__index = ThrowFn
     1 setmetatable(ThrowFn, {__index = Terminal})
     1 package.loaded[...] = ThrowFn

       --Constructor.
     1 function ThrowFn.new(ln, col, args)
         local self

         --(1) create
     6   self = setmetatable(Terminal.new(TerminalType.THROW, {line = ln, col = col}), ThrowFn)
     6   self.args = args

         --(2) return
     6   return self
       end

       --@override
     1 function ThrowFn:__tostring()
         local repr

         --(1) build
     3   repr = "(throw "

     9   for i, arg in ipairs(self.args) do
     6     repr = repr .. (i == 1 and "" or " ") .. tostring(arg)
         end

     3   repr = repr .. ")"

         --(2) return
     3   return repr
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/TypeStmt.lua
==============================================================================
       --imports
     1 local ObjectStmt = require("dogma.syn._.ObjectStmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A type statement.
     1 local TypeStmt = {}
     1 TypeStmt.__index = TypeStmt
     1 setmetatable(TypeStmt, {__index = ObjectStmt})
     1 package.loaded[...] = TypeStmt

       --Constructor.
     1 function TypeStmt.new(ln, col, annots, visib, name, params, btype, bargs, body, catch, fin)
         local self

         --(1) create
    14   self = setmetatable(ObjectStmt.new(StmtType.TYPE, ln, col, name, visib), TypeStmt)
    14   self.params = params
    14   self.base = btype
    14   self.bargs = bargs
    14   self.body = body
    14   self.catch = catch
    14   self.finally = fin
    14   self.annots = annots or {}

         --(2) return
    14   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UnaryOp.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local Op = require("dogma.syn._.Op")
     1 local NodeType = require("dogma.syn.NodeType")

       --Unary operator.
     1 local UnaryOp = {}
     1 UnaryOp.__index = UnaryOp
     1 setmetatable(UnaryOp, {__index = Op})
     1 package.loaded[...] = UnaryOp

       --Constructor.
       --
       --@param tok:Token
     1 function UnaryOp.new(tok)
         local self

         --(1) create
    32   self = setmetatable(Op.new("u", tok), UnaryOp)
    32   self.child = nil

         --(2) return
    32   return self
       end

       --@override
     1 function UnaryOp:insert(node)
         --(1) pre
    34   if tablex.find({".", ":"}, self.op) then
    15     if not (node.type == NodeType.TERMINAL and node:isId()) then
     2       error(string.format(
     1         "on (%s, %s), '.' and ':' must be followed by identifier.",
     1         node.token.line,
     1         node.token.col
     1       ))
           end
         end

         --(2) add
    33   self.child = node
    33   node.parent = self
       end

       --@override
     1 function UnaryOp:remove()
     2   local c = self.child
     2   self.child = nil
     2   return c
       end

       --@override
     1 function UnaryOp:isWellFormed()
    69   return not not self.child
       end

       --@override
     1 function UnaryOp:__tostring()
    18   return string.format("(%s %s)", self.op, self.child)
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Unpack.lua
==============================================================================
       --imports
     1 local Sent = require("dogma.syn._.Sent")
     1 local SentType = require("dogma.syn.SentType")

       --An unpack sentence.
     1 local Unpack = {}
     1 Unpack.__index = Unpack
     1 setmetatable(Unpack, {__index = Sent})
     1 package.loaded[...] = Unpack

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param visib:string   Visibility: nil, export or pub.
       --@param def:string     Type definition: nil, var or const.
       --@param sub:string     Unpack type: [] or {}.
       --@param vars:array
       --@param assign:string  =, := or ?=.
       --@param exp:Exp
     1 function Unpack.new(ln, col, visib, def, sub, vars, assign, exp)
         local self

         --(1) create
    40   self = setmetatable(Sent.new(SentType.UNPACK, ln, col), Unpack)
    40   self.visib = visib
    40   self.def = def
    40   self.subtype = sub
    40   self.vars = vars
    40   self.assign = assign
    40   self.exp = exp

         --(2) return
    40   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --use statement.
     1 local UseStmt = {}
     1 UseStmt.__index = UseStmt
     1 setmetatable(UseStmt, {__index = Stmt})
     1 package.loaded[...] = UseStmt

       --Constructor.
     1 function UseStmt.new(ln, col)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.USE, ln, col), UseStmt)
    18   self.modules = {}

         --(2) return
    18   return self
       end

       --Add a module.
       --
       --@param mod:string   Module to use.
       --@param name?:string Variable module name.
     1 function UseStmt:insert(mod, name)
         --(1) set name if needed
    23   if not name then
    14     name = UseStmt.getNameFor(mod)
         end

         --(2) add module
    22   table.insert(self.modules, {name = name, path = mod})
       end

     1 function UseStmt.getNameFor(path)
    18   local NAME_PATTERN1 = "^[%a_][%w_]*$"
    18   local NAME_PATTERN2 = "^[%a_][%w_%-]*-([%a_][%w_]*)$"
    18   local Q_PATTERN1 = "^.*/([%a_][%w_]*)$"
    18   local Q_PATTERN2 = "^.*%.([%a_][%w_]*)$"
         local name

    18   if path:find(NAME_PATTERN1) then
     9     name = path
     9   elseif path:find(NAME_PATTERN2) then
     1     name = path:match(NAME_PATTERN2)
     8   elseif path:find(Q_PATTERN1) then
     6     name = path:match(Q_PATTERN1)
     2   elseif path:find(Q_PATTERN2) then
     1     name = path:match(Q_PATTERN2)
         else
     1     error(string.format("invalid module path format: '%s'.", path))
         end

    17   return name
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A var statement.
     1 local VarStmt = {}
     1 VarStmt.__index = VarStmt
     1 setmetatable(VarStmt, {__index = Stmt})
     1 package.loaded[...] = VarStmt

       --Constructor.
       --
       --@param ln:number    Line number.
       --@param col:number   Column number.
       --@param visib:string Visibility: export or pub.
     1 function VarStmt.new(ln, col, visib)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.VAR, ln, col), VarStmt)
    18   self.vars = {}
    18   self.visib = visib

         --(2) return
    18   return self
       end

       --Add a variable declaration.
       --
       --@param name:string  Variable name.
       --@param val?:Exp     Default value.
     1 function VarStmt:insert(name, val)
    22   table.insert(self.vars, {name = name, value = val})
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WhileStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --A while statement.
     1 local WhileStmt = {}
     1 WhileStmt.__index = WhileStmt
     1 setmetatable(WhileStmt, {__index = Stmt})
     1 package.loaded[...] = WhileStmt

       --Constructor.
       --
       --@param ln:number
       --@param col:number
       --@param cond:Exp
       --@param iter?:Exp
       --@param body:Sent[]
       --@param catch?:CatchCl
       --@param fin?:FinallyCl
     1 function WhileStmt.new(ln, col, cond, iter, body, catch, fin)
         local self

         --(1) create
    18   self = setmetatable(Stmt.new(StmtType.WHILE, ln, col), WhileStmt)
    18   self.cond = cond
    18   self.iter = iter
    18   self.body = body
    18   self.catch = catch
    18   self.finally = fin

         --(2) return
    18   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WithStmt.lua
==============================================================================
       --imports
     1 local Stmt = require("dogma.syn._.Stmt")
     1 local StmtType = require("dogma.syn.StmtType")

       --with statement.
     1 local WithStmt = {}
     1 WithStmt.__index = WithStmt
     1 setmetatable(WithStmt, {__index = Stmt})
     1 package.loaded[...] = WithStmt

       --Constructor.
     1 function WithStmt.new(ln, col, val, ifs, els)
         local self

         --(1) create
     7   self = setmetatable(Stmt.new(StmtType.WITH, ln, col), WithStmt)
     7   self.value = val
     7   self.ifs = ifs
     7   self.els = els

         --(2) return
     7   return self
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/Trans.lua
==============================================================================
       --A transformer.
     1 local Trans = {}
     1 Trans.__index = Trans
     1 package.loaded[...] = Trans

       --Constructor.
     1 function Trans.new()
   492   return setmetatable({
   246     _ = {

   246     }
   492   }, Trans)
       end

       --Confirgue the transformer.
       --
       --@param parser:Parser  Parser to use.
     1 function Trans:transform(parser)
   245   self._.parser = parser
       end

       --Transform the next sentence or file from the parser configured previously.
       --
       --@abstract
       --@return string
     1 function Trans:next()
     1   error("abstract method.")
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/Trans.lua
==============================================================================
       --imports
     1 local Trans = require("dogma.trans.Trans")
     1 local DirectiveTrans = require("dogma.trans.js._.DirectiveTrans")
     1 local ExpTrans = require("dogma.trans.js._.ExpTrans")
     1 local StmtTrans = require("dogma.trans.js._.StmtTrans")
     1 local UnpackTrans = require("dogma.trans.js._.UnpackTrans")
     1 local SentType = require("dogma.syn.SentType")

       --internal data
       local PRE = [[
       import {any, bool, func, list, map, num, promise, proxy, text, abstract, coalesce, dogma, exec, keys, len, print, printf, todo, typename} from "dogmalang";
     1 ]]

       --A JavaScript transformer.
     1 local JsTrans = {}
     1 JsTrans.__index = JsTrans
     1 setmetatable(JsTrans, {__index = Trans})
     1 package.loaded[...] = JsTrans

       --Constructor.
     1 function JsTrans.new(opts)
         local self

         --(1) create
   245   self = setmetatable(Trans.new(opts), JsTrans)
   245   self._.directiveTrans = DirectiveTrans.new(self)
   245   self._.expTrans = ExpTrans.new(self)
   245   self._.stmtTrans = StmtTrans.new(self)
   245   self._.unpackTrans = UnpackTrans.new(self)

         --(2) return
   245   return self
       end

       --@override
     1 function JsTrans:next(opts)
   244   local parser = self._.parser
         local out

         --(1) arguments
   244   if not opts then
   242     opts = {}
         end

         --(2) transform
   244   local first = false

   244   out = ""
         while true do
           local sent

   489     sent = parser:next()

   489     if sent == nil then
             break
           end

   245     out = out .. self:_trans(sent, ";") .. "\n"

   245     if opts.importDogmalang then
     3       if not first then
     2         first = true

     2         if out:find("^#!/") then
     1           out = out .. PRE
               else
     1           out = PRE .. out
               end
             end
           end
         end

         --(2) return
   244   return out
       end

     1 function JsTrans:_trans(sent, eoe)
   431   if sent.type == SentType.DIRECTIVE then
    10     return self._.directiveTrans:transform(sent)
   421   elseif sent.type == SentType.EXP then
   276     return self._.expTrans:transform(sent) .. (eoe or "")
   145   elseif sent.type == SentType.STMT then
   119     return self._.stmtTrans:transform(sent)
    26   elseif sent.type == SentType.UNPACK then
    26     return self._.unpackTrans:transform(sent)
         end
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/DirectiveTrans.lua
==============================================================================
       --imports
     1 local DirectiveType = require("dogma.syn.DirectiveType")
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --A directive transformer.
     1 local DirectiveTrans = {}
     1 DirectiveTrans.__index = DirectiveTrans
     1 setmetatable(DirectiveTrans, {__index = SubTrans})
     1 package.loaded[...] = DirectiveTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function DirectiveTrans.new(trans)
   245   return setmetatable(SubTrans.new(trans), DirectiveTrans)
       end

       --Transform a directive.
       --
       --@param dir:Directive  Directive to transform.
       --@return string
     1 function DirectiveTrans:transform(dir)
    10   if dir.subtype == DirectiveType.IF then
     8     return self:_transIf(dir)
     2   elseif dir.subtype == DirectiveType.RUNWITH then
     2     return self:_transRunWith(dir)
         end
       end

       --Transform an if directive.
       --
       --@return string
     1 function DirectiveTrans:_transIf(dir)
         local function transform(sents)
     6     local trans = self._.trans
           local code

     6     code = ""
    12     for _, sent in ipairs(sents) do
     6       code = code .. trans:_trans(sent)
           end

     6     return code
         end

         --(1) transform if
         local code

     8   if dir.cond == "js" or (dir.cond:find("^not") and dir.cond ~= "not js") then
     4     code = transform(dir.body)
     4   elseif dir.el then
     2     code = transform(dir.el)
         else
     2     code = ""
         end

         --(2) return
     8   return code
       end

       --Transform a runWith directive.
       --
       --@return string
     1 function DirectiveTrans:_transRunWith(dir)
     2   return "#!" .. dir.cmd
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/ExpTrans.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local NodeType = require("dogma.syn.NodeType")
     1 local TerminalType = require("dogma.syn.TerminalType")
     1 local NonTerminalType = require("dogma.syn.NonTerminalType")
     1 local transName = require("dogma.trans.js._.util").transName
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --An expression transformer to JavaScript.
     1 local ExpTrans = {}
     1 ExpTrans.__index = ExpTrans
     1 setmetatable(ExpTrans, {__index = SubTrans})
     1 package.loaded[...] = ExpTrans

       --Constructor.
     1 function ExpTrans.new(trans)
   245   return setmetatable(SubTrans.new(trans), ExpTrans)
       end

       --Transform an expression.
       --
       --@param exp:Exp      Expression to transform.
       --@return string
     1 function ExpTrans:transform(exp)
   294   return self:_transNode(exp.tree.root)
       end

       --Transform a node.
       --
       --@param node:Node
       --@return string
     1 function ExpTrans:_transNode(node)
   770   if node.type == NodeType.TERMINAL then
   524     return self:_transTerminal(node)
   246   elseif node.type == NodeType.NON_TERMINAL then
   246     return self:_transNonTerminal(node)
         end
       end

       --Transform a terminal node.
       --
       --@param node:Terminal
       --@return string
     1 function ExpTrans:_transTerminal(node)
   524   if node.subtype == TerminalType.NAME then
   278     return transName(node.data)
   246   elseif node.subtype == TerminalType.NUM then
   191     return tostring(node.data)
    55   elseif node.subtype == TerminalType.TEXT then
    14     return string.format([["%s"]], node.data)
    41   elseif node.subtype == TerminalType.TRUE then
    14     return "true"
    27   elseif node.subtype == TerminalType.FALSE then
     2     return "false"
    25   elseif node.subtype == TerminalType.NIL then
     1     return "null"
    24   elseif node.subtype == TerminalType.LIST then
     3     return self:_transLiteralList(node)
    21   elseif node.subtype == TerminalType.MAP then
     3     return self:_transLiteralMap(node)
    18   elseif node.subtype == TerminalType.SELF then
     1     return "this"
    17   elseif node.subtype == TerminalType.SUPER then
     1     return "super"
    16   elseif node.subtype == TerminalType.NOP then
     1     return "dogma.nop()"
    15   elseif node.subtype == TerminalType.FN then
     7     return self:_transLiteralFn(node)
     8   elseif node.subtype == TerminalType.SUBEXP then
     2     return self:transform(node.data)
     6   elseif node.subtype == TerminalType.NATIVE then
     1     return self:_transNativeFn(node)
     5   elseif node.subtype == TerminalType.PEVAL then
     1     return self:_transPevalFn(node)
     4   elseif node.subtype == TerminalType.THROW then
     3     return self:_transThrowFn(node)
     1   elseif node.subtype == TerminalType.IF then
     1     return self:_transIfSubExp(node)
         end
       end

       --Transform if Exp then Exp else Exp end
     1 function ExpTrans:_transIfSubExp(node)
     2   return string.format(
     1     "(%s ? %s : %s)",
     1     self:transform(node.cond),
     1     self:transform(node.trueCase),
     1     self:transform(node.falseCase)
     1   )
       end

       --Transform a native() function.
     1 function ExpTrans:_transNativeFn(fn)
     1   return string.format(fn.code)
       end

       --Transform a peval() function.
     1 function ExpTrans:_transPevalFn(fn)
     1   return string.format("dogma.peval(() => {return %s;})", self:transform(fn.exp))
       end

       --Transform a throw() function.
     1 function ExpTrans:_transThrowFn(fn)
         local code

         --(1) transform
     3   code = "dogma.raise("

     3   if #fn.args == 1 then
     1     code = code .. self:transform(fn.args[1])
         else
     7     for i, arg in ipairs(fn.args) do
     5       code = code .. (i == 1 and "" or ", ") .. self:transform(arg)
           end
         end

     3   code = code .. ")"

         --(2) return
     3   return code
       end

       --Transform a literal list.
     1 function ExpTrans:_transLiteralList(term)
         local code

         --(1) transform
     3   code = "["

     6   for ix, item in ipairs(term.data) do
     3     code = code .. (ix == 1 and "" or ", ") .. self:transform(item)
         end

     3   code = code .. "]"

         --(2) return
     3   return code
       end

       --Transform a literal map.
     1 function ExpTrans:_transLiteralMap(term)
         local code

         --(1) transform
     3   code = "{"

     6   for i, entry in ipairs(term.data) do
     6     code = code .. (i == 1 and "" or ", ") .. string.format(
     3       '["%s"]: %s',
     3       entry.name,
     3       self:transform(entry.value)
           )
         end

     3   code = code .. "}"

         --(2) return
     3   return code
       end

       --Transform a literal function.
     1 function ExpTrans:_transLiteralFn(term)
     7   local strans = self._.trans._.stmtTrans

    14   return string.format(
     7     "(%s) => { %s%s%s%s }",
     7     strans:_transParams(term.data.params),
     7     strans:_transReturnVar(term.data),
     7     strans:_transParamsCheck(term.data.params),
     7     strans:_transBody(term.data.body),
     7     term.data.rvar and string.format(" return %s;", term.data.rvar == "self" and "this" or term.data.rvar) or ""
    13   )
       end

       --Transform a non-terminal node.
       --
       --@param node:NonTerminal
       --@return string
     1 function ExpTrans:_transNonTerminal(node)
   246   if node.subtype == NonTerminalType.OP then
   246     return self:_transOp(node)
         end
       end

       --Transform an operator node.
       --
       --@param node:Op
       --@return string
     1 function ExpTrans:_transOp(node)
   246   if node.arity == "u" then
    10     return self:_transUnaryOp(node)
   236   elseif node.arity == "b" then
   215     return self:_transBinOp(node)
    21   elseif node.arity == "t" then
     2     return self:_transTernaryOp(node)
    19   elseif node.arity == "n" then
    19     return self:_transNaryOp(node)
         end
       end

     1 function ExpTrans:_transUnaryOp(node)
    10   if node.op == "." then
     3     return "this." .. node.child.data
     7   elseif node.op == ":" then
     1     return "this._" .. node.child.data
     6   elseif node.op == "not" or node.op == "!" then
     2     return string.format("!(%s)", self:_transNode(node.child))
     4   elseif node.op == "~" then
     1     return string.format("~(%s)", self:_transNode(node.child))
     3   elseif node.op == "+" then
     1     return string.format("+(%s)", self:_transNode(node.child))
     2   elseif node.op == "-" then
     1     return string.format("-(%s)", self:_transNode(node.child))
     1   elseif node.op == "..." then
     1     return string.format("...(%s)", self:_transNode(node.child))
         end
       end

     1 function ExpTrans:_transBinOp(node)
   215   local left, right = node.children[1], node.children[2]

   215   if tablex.find({"+", "-", "*", "**", "/", "%", "==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", "||", "&&"}, node.op) then
   150     return "(" .. self:_transNode(left) .. node.op .. self:_transNode(right) .. ")"
    65   elseif tablex.find({"=", "+=", "-=", "*=", "**=", "/=", "%=", "<<=", ">>=", "|=", "&=", "^="}, node.op) then
    27     return self:_transAssign(node)
    38   elseif node.op == "?=" then
     4     return self:_transCondAssign(node)
    34   elseif node.op == ".=" then
     1     return self:_transAssignWithPubProp(node)
    33   elseif node.op == ":=" then
     5     return self:_transConstAssign(node)
    28   elseif node.op == "and" then
     1     return "(" .. self:_transNode(left) .. "&&" .. self:_transNode(right) .. ")"
    27   elseif node.op == "or" then
     1     return "(" .. self:_transNode(left) .. "||" .. self:_transNode(right) .. ")"
    26   elseif node.op == "." then
    11     return self:_transNode(left) .. "." .. self:_transNode(right)
    15   elseif node.op == ":" then
     6     return self:_transNode(left) .. "._" .. right.data
     9   elseif node.op == "is" then
     1     return string.format("dogma.is(%s, %s)", self:_transNode(left), self:_transNode(right))
     8   elseif node.op == "isnot" then
     1     return string.format("dogma.isNot(%s, %s)", self:_transNode(left), self:_transNode(right))
     7   elseif node.op == "in" then
     1     return string.format("(%s).includes(%s)", self:_transNode(right), self:_transNode(left))
     6   elseif node.op == "notin" then
     1     return string.format("!(%s).includes(%s)", self:_transNode(right), self:_transNode(left))
     5   elseif node.op == "like" then
     1     return string.format("dogma.like(%s, %s)", self:_transNode(left), self:_transNode(right))
     4   elseif node.op == "notlike" then
     1     return string.format("dogma.notLike(%s, %s)", self:_transNode(left), self:_transNode(right))
     3   elseif node.op == "[]" then
     3     return string.format("dogma.getItem(%s, %s)", self:_transNode(left), self:_transNode(right))
         end
       end

     1 function ExpTrans:_transCondAssign(op)
     4   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     4   if left.arity == "b" and left.op == "[]" then
     2     code = string.format(
     1       'dogma.setItem("=", %s, %s, coalesce(dogma.getItem(%s, %s), %s))',
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         else
     6     code = string.format(
     3       "(%s = coalesce(%s, %s))",
     3       self:_transNode(left),
     3       self:_transNode(left),
     3       self:_transNode(right)
     3     )
         end

         --(2) return
     4   return code
       end

     1 function ExpTrans:_transAssign(op)
    27   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
    27   if left.op == "[]" then
     2     code = string.format(
     1       [[dogma.setItem("%s", %s, %s, %s)]],
     1       op.op,
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         else
    26     code = string.format("(%s%s%s)", self:_transNode(left), op.op, self:_transNode(right))
         end

         --(2) return
    27   return code
       end

     1 function ExpTrans:_transConstAssign(op)
     5   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     5   if left.arity == "u" and left.op == "." then
     2     code = string.format(
     1       [[Object.defineProperty(this, "%s", {value: %s, enum: true})]],
     1       self:_transNode(left.child),
     1       self:_transNode(right)
     1     )
     4   elseif left.arity == "b" and left.op == "." then
     2     code = string.format(
     1       [[Object.defineProperty(%s, "%s", {value: %s, enum: true})]],
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
     3   elseif left.op == ":" then
     2     if left.arity == "u" then
     2       code = string.format(
     1         [[Object.defineProperty(this, "_%s", {value: %s})]],
     1         left.child.data,
     1         self:_transNode(right)
     1       )
           else
     2       code = string.format(
     1         [[Object.defineProperty(%s, "_%s", {value: %s})]],
     1         self:_transNode(left.children[1]),
     1         left.children[2].data,
     1         self:_transNode(right)
     1       )
           end
     1   elseif left.op == "[]" then
     2     code = string.format(
     1       [[dogma.setItem("=", %s, %s, %s)]],
     1       self:_transNode(left.children[1]),
     1       self:_transNode(left.children[2]),
     1       self:_transNode(right)
     1     )
         end

         --(2) return
     5   return code
       end

     1 function ExpTrans:_transAssignWithPubProp(op)
     1   local left, right = op.children[1], op.children[2]
         local code

         --(1) transform
     1   if left.arity == "u" then
     2     code = string.format(
     1       'Object.defineProperty(this, "_%s", {value: %s, writable: true});',
     1       left.child.data,
     1       self:_transNode(right)
     1     )

     2     code = code .. string.format(
     1       'Object.defineProperty(this, "%s", {enum: true, get() { return this._%s; }})',
     1       left.child.data,
     1       left.child.data
     1     )
         end

         --(2) return
     1   return code
       end

     1 function ExpTrans:_transTernaryOp(op)
     2   if op.op == "[]" then
     4     return string.format(
     2       "dogma.getSlice(%s, %s, %s)",
     2       self:_transNode(op.children[1]),
     2       self:_transNode(op.children[2]),
     2       self:_transNode(op.children[3])
     2     )
         end
       end

     1 function ExpTrans:_transNaryOp(node)
    19   if node.op == "()" then
    15     return self:_transCallOp(node)
     4   elseif node.op == "{}" then
     4     return self:_transPackOp(node)
         end
       end

     1 function ExpTrans:_transCallOp(node)
         local code

    15   code = self:_transNode(node.children[1]) .. "("
    44   for i, arg in ipairs(node.children) do
    29     if i > 1 then
    14       code = code .. (i == 2 and "" or ", ") .. self:_transNode(arg.tree.root)
           end
         end
    15   code = code .. ")"

    15   return code
       end

     1 function ExpTrans:_transPackOp(node)
         local code

         --(1) transform
     4   if #node.children == 2 and node.children[2].name == "*" then
     1     code = string.format("dogma.clone(%s)", self:_transNode(node.children[1]))
         else
     3     code = "dogma.pack("

    10     for i, item in ipairs(node.children) do
     7       if i == 1 then
     3         code = code .. self:_transNode(item)
             else
     4         code = code .. string.format(', "%s%s"', item.visib == "." and "" or "_", item.name)
             end
           end

     3     code = code .. ")"
         end

         --(2) return
     4   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/StmtTrans.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")
     1 local StmtType = require("dogma.syn.StmtType")
     1 local transName = require("dogma.trans.js._.util").transName
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --A statement transformer.
     1 local StmtTrans = {}
     1 StmtTrans.__index = StmtTrans
     1 setmetatable(StmtTrans, {__index = SubTrans})
     1 package.loaded[...] = StmtTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function StmtTrans.new(trans)
   245   return setmetatable(SubTrans.new(trans), StmtTrans)
       end

       --Transform a statement.
       --
       --@param stmt:Stmt  Statement to transform.
       --@return string
     1 function StmtTrans:transform(stmt)
   119   if stmt.subtype == StmtType.ASYNC then
     4     return self:_transAsync(stmt)
   115   elseif stmt.subtype == StmtType.BREAK then
     1     return self:_transBreak(stmt)
   114   elseif stmt.subtype == StmtType.CONST then
     5     return self:_transConst(stmt)
   109   elseif stmt.subtype == StmtType.DO then
     5     return self:_transDo(stmt)
   104   elseif stmt.subtype == StmtType.ENUM then
     4     return self:_transEnum(stmt)
   100   elseif stmt.subtype == StmtType.EXPORT then
     1     return self:_transExport(stmt)
    99   elseif stmt.subtype == StmtType.FN then
    34     return self:_transFn(stmt)
    65   elseif stmt.subtype == StmtType.FOR then
     7     return self:_transFor(stmt)
    58   elseif stmt.subtype == StmtType.FOR_EACH then
     5     return self:_transForEach(stmt)
    53   elseif stmt.subtype == StmtType.FROM then
     4     return self:_transFrom(stmt)
    49   elseif stmt.subtype == StmtType.IF then
     6     return self:_transIf(stmt)
    43   elseif stmt.subtype == StmtType.NEXT then
     1     return self:_transNext(stmt)
    42   elseif stmt.subtype == StmtType.PUB then
     3     return self:_transPub(stmt)
    39   elseif stmt.subtype == StmtType.RETURN then
    14     return self:_transReturn(stmt)
    25   elseif stmt.subtype == StmtType.TYPE then
     7     return self:_transType(stmt)
    18   elseif stmt.subtype == StmtType.USE then
     4     return self:_transUse(stmt)
    14   elseif stmt.subtype == StmtType.VAR then
     7     return self:_transVar(stmt)
     7   elseif stmt.subtype == StmtType.WHILE then
     6     return self:_transWhile(stmt)
     1   elseif stmt.subtype == StmtType.WITH then
     1     return self:_transWith(stmt)
         end
       end

       --Transform a use statement.
       --
       --@return string
     1 function StmtTrans:_transUse(stmt)
         local code

         --(1) transform
     6   code = ""

    14   for _, mod in ipairs(stmt.modules) do
     8     code = code .. string.format('const %s = require("%s").default || require("%s");', mod.name, mod.path, mod.path)
         end

         --(2) return
     6   return code
       end

       --Transform a from statement.
       --
       --@return string
     1 function StmtTrans:_transFrom(stmt)
         local code

         --(1) transform
     4   code = "import {"

    10   for i, mem in ipairs(stmt.members) do
     6     code = code .. (i == 1 and "" or ", ")

     6     if mem.name == mem.as then
     3       code = code .. mem.name
           else
     3       code = code .. string.format("%s as %s", mem.name, mem.as)
           end
         end

     4   code = code .. [[} from "]] .. stmt.module .. [[";]]

         --(2) return
     4   return code
       end

       --Transform a break statement.
       --
       --@return string
     1 function StmtTrans:_transBreak(stmt)
     1   return "break;"
       end

       --Transform a next statement.
       --
       --@return string
     1 function StmtTrans:_transNext(stmt)
     1   return "continue;"
       end

       --Transform an enum statement.
       --
       --@return string
     1 function StmtTrans:_transEnum(enum)
         local code

         --(1) transform
     8   code = string.format([[
       %sclass %s {
         constructor(name, val) {
           Object.defineProperty(this, "name", {value: name, enum: true});
           Object.defineProperty(this, "value", {value: val, enum: true});
         }
       }
     4 ]],
     4     self:_transVisib(enum.visib),
           enum.name
     8   )

    12   for _, item in ipairs(enum.items) do
    16     code = code .. string.format(
     8       [[Object.defineProperty(%s, "%s", {value: new %s("%s", %s), enum: true});]] .. "\n",
     8       enum.name,
     8       item.name,
     8       enum.name,
     8       item.name,
     8       (type(item.value) == "string" and string.format([["%s"]], item.value) or item.value)
           )
         end

         --(2) return
     4   return code
       end

     1 function StmtTrans:_transVisib(visib)
    28   if visib == "export" then
     4     return "export default "
    24   elseif visib == "pub" then
     4     return "export "
         else
    20     return ""
         end
       end

       --Transform an async statement.
       --
       --@param node
       --@return string
     1 function StmtTrans:_transAsync(node)
     4   local trans = self._.trans
         local code

         --(1) get sentences to run
     4   if node.catch then
     2     code = "try "
         else
     2     code = ""
         end

     4   code = code .. self:_transBody(node.body)
     4   code = code .. self:_transCatch(node.catch)

         --(2) return
     4   if node.opts.delay then
     1     return string.format("setTimeout(() => %s, %s);", code, trans:_trans(node.opts.delay))
         else
     3     return string.format("setImmediate(() => %s);", code)
         end
       end

       --Transform a var statement.
       --
       --@return string
     1 function StmtTrans:_transVar(stmt)
         local code

         --(1) transform
     7   if #stmt.vars > 0 then
     6     if stmt.visib then
     2       code = "var "
           else
     4       code = "let "
           end

    14     for i, var in ipairs(stmt.vars) do
     8       code = code .. (i == 1 and "" or ", ") .. var.name

     8       if var.value then
     5         code = code .. " = " .. self._.trans:_trans(var.value)
             end
           end

     6     code = code .. ";"

     6     if stmt.visib then
     4       for _, var in ipairs(stmt.vars) do
     2         code = code .. self:_transVisib(stmt.visib) .. var.name .. ";"
             end
           end
         else
     1     code = ""
         end

         --(2) return
     7   return code
       end

       --Transform a const statement.
       --
       --@return string
     1 function StmtTrans:_transConst(stmt)
         local code

         --(1) transform
     5   if #stmt.vars > 0 then
     4     code = "const "

     9     for i, var in ipairs(stmt.vars) do
     5       code = code .. (i == 1 and "" or ", ") ..
     5              var.name .. " = " .. self._.trans:_trans(var.value)
           end

     4     code = code .. ";"

     4     if stmt.visib then
     4       for _, var in ipairs(stmt.vars) do
     2         code = code .. self:_transVisib(stmt.visib) .. var.name .. ";"
             end
           end
         else
     1     code = ""
         end

         --(2) return
     5   return code
       end

       --Transform an while statement.
       --
       --@return string
     1 function StmtTrans:_transWhile(node)
     6   local trans = self._.trans
         local code

         --(1) transform
     6   if node.iter then
     2     code = string.format(
     1       "for (; %s; %s) ",
     1       trans:_trans(node.cond),
     1       trans:_trans(node.iter)
     1     )
         else
     5     code = string.format("while (%s) ", trans:_trans(node.cond))
         end

     6   if node.catch or node.finally then
     3     code = code .. "try "
         end

     6   code = code .. self:_transBody(node.body)
     6   code = code .. self:_transCatch(node.catch)
     6   code = code .. self:_transFinally(node.finally)

         --(2) return
     6   return code
       end

       --Transform a statement body.
       --
       --2return string
     1 function StmtTrans:_transBody(body)
    88   local trans = self._.trans
         local code

         --(1) transform
    88   code = "{"

   151   for _, sent in ipairs(body) do
    63     code = code .. trans:_trans(sent, ";")
         end

    88   code = code .. "}"

         --(2) return
    88   return code
       end

       --Transform a catch clause.
       --
       --@return string
     1 function StmtTrans:_transCatch(catch)
    66   local trans = self._.trans
         local code

         --(1) transform
    66   if catch then
    10     code = string.format(" catch(%s) {", catch.var or "_")

    20     for _, sent in ipairs(catch.body) do
    10       code = code .. trans:_trans(sent, ";")
           end

    10     code = code .. "}"
         end

         --(2) return
    66   return code or ""
       end

       --Transform a finally clause.
       --
       --@return string
     1 function StmtTrans:_transFinally(fin)
    62   local trans = self._.trans
         local code

         --(1) transform
    62   if fin then
     7     code = " finally {"

    14     for _, sent in ipairs(fin.body) do
     7       code = code .. trans:_trans(sent, ";")
           end

     7     code = code .. "}"
         end

         --(2) return
    62   return code or ""
       end

       --Transform a do statement.
       --
       --@return string
     1 function StmtTrans:_transDo(node)
     5   local trans = self._.trans
         local code

         --(1) transform
     5   if node.catch or node.finally then
     4     if node.cond then
     1       code = "do try "
           else
     3       code = "try "
           end
         else
     1     code = "do "
         end

     5   code = code .. self:_transBody(node.body)
     5   code = code .. self:_transCatch(node.catch)
     5   code = code .. self:_transFinally(node.finally)

     5   if node.cond then
     2     code = code .. string.format(" while (%s);", trans:_trans(node.cond))
         end

         --(2) return
     5   return code
       end

       --Transfor a for statement.
       --
       --@return string
     1 function StmtTrans:_transFor(stmt)
     7   local trans = self._.trans
         local code

         --(1) transform
     7   code = "for (let "

    17   for i, var in ipairs(stmt.def) do
    10     code = code .. (i == 1 and "" or ", ") .. var.name

    10     if var.value then
     6       code = code .. " = " .. trans:_trans(var.value)
           end
         end

     7   code = code .. "; " .. trans:_trans(stmt.cond) .. "; "

     7   if stmt.iter then
     3     code = code .. trans:_trans(stmt.iter)
         end

     7   code = code .. ") "

     7   if stmt.catch or stmt.finally then
     1     code = code .. "try "
         end

     7   code = code .. self:_transBody(stmt.body)
     7   code = code .. self:_transCatch(stmt.catch)
     7   code = code .. self:_transFinally(stmt.finally)

         --(2) return
     7   return code
       end

       --Transform a for each statement.
       --
       --@return string
     1 function StmtTrans:_transForEach(node)
     5   local trans = self._.trans
         local code

         --(1) transform
     5   if node.key then
     1     local iter = self:_getRandomName()

     2     code = string.format(
     1       "const %s = %s; for (let %s in %s) { let %s = %s[%s]; ",
     1       iter,
     1       trans:_trans(node.iter),
     1       node.key,
     1       iter,
     1       node.value,
     1       iter,
             node.key
     2     )
         else
     8     code = string.format(
     4       "for (let %s of %s) ",
     4       node.value,
     4       trans:_trans(node.iter)
     4     )
         end

     5   if node.catch or node.finally then
     3     code = code .. "try "
         end

     5   code = code .. self:_transBody(node.body)
     5   code = code .. self:_transCatch(node.catch)
     5   code = code .. self:_transFinally(node.finally)

     5   if node.key then
     1     code = code .. " }"
         end

         --(2) return
     5   return code
       end

       --Transform a return statement.
       --
       --@return string
     1 function StmtTrans:_transReturn(node)
    14   local trans = self._.trans
         local code

         --(1) transform
    14   code = "return"

    14   if #node.values == 1 then
    13     code = code .. " " .. trans:_trans(node.values[1])
         end

    14   code = code .. ";"

         --(2) return
    14   return code
       end

       --Transform a type statement.
       --
       --@return string
     1 function StmtTrans:_transType(stmt)
         local code

         --(1) transform
         --$class
     7   code = string.format("const $%s = class %s", stmt.name, stmt.name)
     7   if stmt.base then
     3     code = code .. " extends " .. stmt.base
         end

     7   code = code .. " {\n"

     7   code = code .. string.format("  constructor(%s) { ", self:_transParams(stmt.params))
     7   code = code .. self:_transParamsCheck(stmt.params)
     7   code = code .. self:_transSuperConstructor(stmt.bargs)
     7   code = code .. self:_transSelfParams(stmt.params)
     7   if stmt.catch or stmt.finally then code = code .. " try " end
     7   code = code .. self:_transBody(stmt.body)
     7   code = code .. self:_transCatch(stmt.catch)
     7   code = code .. self:_transFinally(stmt.finally)
     7   code = code .. "  }\n"
     7   code = code .. "};\n"

         --class proxy
    14   code = code .. string.format(
     7     "const %s = new Proxy($%s, { apply(receiver, self, args) { return new $%s(...args); } });",
     7     stmt.name,
     7     stmt.name,
           stmt.name
     7   )

     7   if stmt.visib == "export" then
     1     code = code .. string.format("export default %s;", stmt.name)
         end

         --(2) return
     7   return code
       end

       --Transform function parameters.
       --
       --@return string
     1 function StmtTrans:_transParams(params)
    43   local trans = self._.trans
         local code

         --(1) transform
    43   if #params > 0 then
    28     code = ""

    66     for i, p in ipairs(params) do
    38       if i > 1 then
    10         code = code .. ", "
             end

    38       if p.modifier == "..." then
     1         code = code .. "..."
             end

    38       code = code .. transName(p.name)

    38       if p.value then
     1         code = code .. " = " .. trans:_trans(p.value)
             end
           end
         end

         --(2) return
    43   return code or ""
       end

       --Return the code for checking the function parameters.
       --
       --@return string
     1 function StmtTrans:_transParamsCheck(params)
         local function toJs(obj)
           local repr

     3     repr = "{"
     7     for ix, val in ipairs(obj) do
     4       repr = repr .. (ix == 1 and "" or ", ") .. val.name .. ": " .. val.type
           end
     3     repr = repr .. "}"

     3     return repr
         end

         local code

         --(1) transform
    43   if #params > 0 then
    28     code = ""

    66     for _, p in ipairs(params) do
    38       if not p.optional and p.modifier ~= "..." then  --mandatory parameter with(out) type check
    25         if type(p.type) == "table" then
     4           code = code .. string.format(
     2             [[dogma.paramExpectedToHave("%s", %s, %s);]],
     2             transName(p.name),
     2             transName(p.name),
     2             toJs(p.type)
     2           )
               else
    46           code = code .. string.format(
    23             [[dogma.paramExpected("%s", %s, %s);]],
    23             transName(p.name),
    23             transName(p.name),
    23             p.type or "null"
    21           )
               end
    13       elseif p.type then  --optional parameter with type check
     3         if type(p.type) == "table" then
     2           code = code .. string.format(
     1             [[dogma.paramExpectedToHave("%s", %s, %s);]],
     1             transName(p.name),
     1             transName(p.name),
     1             toJs(p.type)
     1           )
               else
     4           code = code .. string.format(
     2             [[dogma.paramExpectedToBe("%s", %s, %s);]],
     2             transName(p.name),
     2             transName(p.name),
                   p.type
     2           )
               end
             end
           end
         end

         --(2) return
    43   return code or ""
       end

       --Return the code for setting . or : attributes from parameters.
       --
       --@return string
     1 function StmtTrans:_transSelfParams(params)
         local code

         --(1) transform
    36   if #params > 0 then
    22     code = ""

    53     for _, p in ipairs(params) do
    31       if p.modifier == "." then
    18         code = code .. string.format(
     9           [[Object.defineProperty(this, "%s", {value: %s, enum: true, writable: %s});]],
     9           transName(p.name),
     9           transName(p.name),
     9           not p.const
     9         )
    22       elseif p.modifier == ":" then
     2         code = code .. string.format(
     1           [[Object.defineProperty(this, "_%s", {value: %s, writable: %s});]],
     1           p.name,
     1           p.name,
     1           not p.const
               )
             end
           end
         end

         --(2) return
    36   return code or ""
       end

       --Return a call to the super constructor.
       --
       --@return string
     1 function StmtTrans:_transSuperConstructor(bargs)
     7   local trans = self._.trans
         local code

         --(1) Transform
     7   if bargs then
     2     if #bargs == 0 then
     1       code = "super();"
           else
     1       code = "super("

     3       for i, a in ipairs(bargs) do
     2         code = code .. (i == 1 and "" or ", ") .. trans:_trans(a)
             end

     1       code =  code .. ");"
           end
         end

         --(2) return
     7   return code or ""
       end

       --Transform a fn statement.
       --
       --@return string
     1 function StmtTrans:_transFn(stmt)
    34   if stmt.itype then
    14     return self:_transTypeFn(stmt)
         else
    20     return self:_transStdFn(stmt)
         end
       end

     1 function StmtTrans:_transStdFn(fn)
         local code

         --(1) transform
    40   code = string.format(
    20     "%sfunction %s(%s) { ",
    20     self:_transVisib(fn.visib),
    20     fn.name,
    20     self:_transParams(fn.params)
    20   )

    20   code = code .. self:_transReturnVar(fn)
    20   code = code .. self:_transParamsCheck(fn.params)
    20   code = code .. self:_transSelfParams(fn.params)
    20   if fn.catch or fn.finally then code = code .. " try " end
    20   code = code .. self:_transBody(fn.body)
    20   code = code .. self:_transCatch(fn.catch)
    20   code = code .. self:_transFinally(fn.finally)
    20   if fn.rvar then
     4     code = code .. string.format(" return %s;", fn.rvar == "self" and "this" or fn.rvar)
         end
    20   code = code .. " }"

         --(2) return
    20   return code
       end

     1 function StmtTrans:_transTypeFn(stmt)
    14   if tablex.find(stmt.annots, "prop") then
     4     return self:_transProp(stmt)
         else
    10     return self:_transMethod(stmt)
         end
       end

     1 function StmtTrans:_transProp(stmt)
         local code

         --(1) transform
     8   code = string.format(
     4     [[Object.defineProperty(%s.prototype, "%s%s", {enum: %s, get: function() { ]],
     4     stmt.itype,
     4     stmt.visib == "pub" and "" or "_",
     4     stmt.name,
     4     stmt.visib == "pub"
     8   )

     4   if tablex.find(stmt.annots, "abstract") then
     1     code = code .. "abstract();"
         else
     3     code = code .. self:_transReturnVar(stmt)
     3     if stmt.catch or stmt.finally then code = code .. " try " end
     3     code = code .. self:_transBody(stmt.body)
     3     code = code .. self:_transCatch(stmt.catch)
     3     code = code .. self:_transFinally(stmt.finally)

     3     if stmt.rvar then
     1       code = code .. string.format(" return %s;", stmt.rvar == "self" and "this" or stmt.rvar)
           end
         end

     4   code = code .. " }});"

         --(2) return
     4   return code
       end

     1 function StmtTrans:_transMethod(stmt)
         local code

         --(1) transform
    10   if tablex.find(stmt.annots, "abstract") then
     2     code = string.format(
     1       "%s.prototype.%s%s = function() { abstract(); };",
     1       stmt.itype,
     1       stmt.visib == "pub" and "" or "_",
             stmt.name
     2     )
         else
     9     if tablex.find(stmt.annots, "static") then
     2       code = string.format(
     1         "%s.%s%s = function(%s) { ",
     1         stmt.itype,
     1         stmt.visib == "pub" and "" or "_",
     1         stmt.name,
     1         self:_transParams(stmt.params)
     1       )
           else
    16       code = string.format(
     8         "%s.prototype.%s%s = function(%s) { ",
     8         stmt.itype,
     8         stmt.visib == "pub" and "" or "_",
     8         stmt.name,
     8         self:_transParams(stmt.params)
     8       )
           end

     9     code = code .. self:_transReturnVar(stmt)
     9     code = code .. self:_transParamsCheck(stmt.params)
     9     code = code .. self:_transSelfParams(stmt.params)

     9     if stmt.catch or stmt.finally then code = code .. " try " end
     9     code = code .. self:_transBody(stmt.body)
     9     code = code .. self:_transCatch(stmt.catch)
     9     code = code .. self:_transFinally(stmt.finally)

     9     if stmt.rvar then
     2       code = code .. string.format(" return %s;", stmt.rvar == "self" and "this" or stmt.rvar)
           end

     9     code = code .. " };"
         end

         --(2) return
    10   return code
       end

     1 function StmtTrans:_transReturnVar(fn)
         local code

         --(1) transform
    39   code = ""

    39   if fn.rvar then
     8     if fn.rvar ~= "self" and not fn.params:has(fn.rvar) then
     4       code = string.format("let %s;", fn.rvar)
           end
         end

         --(2) return
    39   return code
       end

       --Transform an if statement.
       --
       --@return string
     1 function StmtTrans:_transIf(stmt)
     6   local trans = self._.trans
         local code

         --(1) transform
    12   code = string.format(
     6     "if (%s) %s",
     6     trans:_trans(stmt.cond),
     6     self:_transBody(stmt.body)
     6   )

     6   if stmt.elif then
     5     for _, cl in ipairs(stmt.elif) do
     6       code = code .. string.format(
     3         " else if (%s) %s",
     3         trans:_trans(cl.cond),
     3         self:_transBody(cl.body)
             )
           end
         end

     6   if stmt.el then
     3     code = code .. " else " .. self:_transBody(stmt.el)
         end

         --(2) return
     6   return code
       end

       --Transform a pub statement.
       --
       --@return string
     1 function StmtTrans:_transPub(stmt)
         local code

         --(1) transform
     3   code = ""

     7   for _, item in ipairs(stmt.items) do
     4     if item.type == "pub" then
     2       code = code .. string.format("export {%s};", item.value)
           else
     2       code = code .. self:_transUse({modules = {item.value}})
     2       code = code .. string.format("export {%s};", item.value.name)
           end
         end

         --(2) return
     3   return code
       end

       --Transform an export statement.
       --
       --@return string
     1 function StmtTrans:_transExport(stmt)
     1   local trans = self._.trans
         local code

         --(1) transform
     1   code = "export default " .. trans:_trans(stmt.exp) .. ";"

         --(2) return
     1   return code
       end

       --Transform a with statement.
       --
       --@return string
     1 function StmtTrans:_transWith(stmt)
     1   local trans = self._.trans
         local var, code

         --(1) transform
     1   var = self:_getRandomName()

     1   code = string.format("const %s = %s;", var, trans:_trans(stmt.value))

     3   for ix, cls in ipairs(stmt.ifs) do
     4     code = code .. string.format(
     2       "%sif (%s == %s) %s",
     2       ix == 1 and "" or " else ",
     2       var,
     2       trans:_trans(cls.cond),
     2       self:_transBody(cls.body)
           )
         end

     1   if stmt.els then
     1     code = code .. " else " .. self:_transBody(stmt.els)
         end

         --(2) return
     1   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/SubTrans.lua
==============================================================================
       --A sub transformer.
     1 local SubTrans = {}
     1 SubTrans.__index = SubTrans
     1 package.loaded[...] = SubTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function SubTrans.new(trans)
  1960   return setmetatable({
   980     _ = {
   980       trans = trans
   980     }
  1960   }, SubTrans)
       end

       --Return a random name.
       --
       --@return string
     1 function SubTrans._getRandomName()
     5   math.randomseed(os.time())
     5   return "$aux" .. os.time() .. math.random(1, 10000)
       end

       --Transform a data access.
       --
       --@param def:DataAccess
       --@return string, string
     1 function SubTrans:_transDataAccess(def)
         local prefix

    43   if def.mod == "." then
     3     prefix = "this."
    40   elseif def.mod == ":" then
     3     prefix = "this._"
         else
    37     prefix = ""
         end

    43   return prefix .. def.name:gsub(":", "._")
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/UnpackTrans.lua
==============================================================================
       --imports
     1 local SubTrans = require("dogma.trans.js._.SubTrans")

       --An unpack sentence transformer.
     1 local UnpackTrans = {}
     1 UnpackTrans.__index = UnpackTrans
     1 setmetatable(UnpackTrans, {__index = SubTrans})
     1 package.loaded[...] = UnpackTrans

       --Constructor.
       --
       --@param trans:Trans  Parent transformer.
     1 function UnpackTrans.new(trans)
   245   return setmetatable(SubTrans.new(trans), UnpackTrans)
       end

       --Transform an unpack sentence.
       --
       --@param sent:Unpack  Sentence to transform.
       --@return string
     1 function UnpackTrans:transform(sent)
    26   if sent.subtype == "[]" then
    15     if sent.assign == "=" then
    13       return self:_transList(sent)
     2     elseif sent.assign == ":=" then
     1       return self:_transReadOnlyFieldsList(sent)
           else
     1       return self:_transOptionalList(sent)
           end
    11   elseif sent.subtype == "{}" then
    11     if sent.assign == "=" then
    10       return self:_transMap(sent)
           else
     1       return self:_transReadOnlyFieldsMap(sent)
           end
         end
       end

       --Transform [...] = Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transList(sent)
    13   local trans = self._.trans
         local code

         --(1) visibility?
    13   if sent.visib == nil then
     9     code = ""
     4   elseif sent.visib == "export" then
     2     code = "export default "
     2   elseif sent.visib == "pub" then
     2     code = "export "
         end

         --(2) var or const definition?
    13   if sent.def == "var" then
     6     code = code .. "let "
     7   elseif sent.def == "const" then
     3     code = code .. "const "
         end

         --(3) variables
    13   code = code .. "["

    42   for i, def in ipairs(sent.vars) do
    29     local var = self:_transDataAccess(def)

    58     code = code .. (i == 1 and "" or ", ") .. string.format(
    29       "%s%s%s",
    29       def.mod == "..." and "..." or "",
    29       var,
    29       def.value and (" = " .. trans:_trans(def.value)) or ""
    27     )
         end

    13   code = code .. "]"

         --(4) expression
    13   code = code .. " = " .. trans:_trans(sent.exp) .. ";"

         --(5) return
    13   return code
       end

       --Transform [...] := Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transReadOnlyFieldsList(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     1   code = string.format("const %s = %s;", valVar, trans:_trans(sent.exp))

         --(2) unpack
     6   for ix, fld in ipairs(sent.vars) do
     5     local name = fld.name:gsub(":", "._")

     5     if fld.mod == "." then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "%s", {value: %s[%s], enum: true});',
     1         name,
     1         valVar,
     1         ix - 1
     1       )
     4     elseif fld.mod == ":" then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "_%s", {value: %s[%s]});',
     1         name,
     1         valVar,
     1         ix - 1
     1       )
           else
     3       code = code .. string.format('%s = %s[%s];', name, valVar, ix - 1)
           end
         end

         --(3) return
     1   return code
       end

       --Transform [...] ?= Exp
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transOptionalList(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     1   code = string.format("const %s = %s;", valVar, trans:_trans(sent.exp))

         --(2) unpack
     1   local left, right = "", ""

     6   for ix, def in ipairs(sent.vars) do
     5     local js = self:_transDataAccess(def)

     5     if ix > 1 then
     4       left = left .. ", "
     4       right = right .. ", "
           end

     5     left = left .. js
    10     right = right .. string.format(
     5       "%s != null ? %s : %s[%s]",
     5       js,
     5       js,
     5       valVar,
     5       ix - 1
           )
         end

     1   code = code .. string.format("[%s] = [%s];", left, right)

         --(3) return
     1   return code
       end

       --Transform {...} = Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transMap(sent)
    10   local trans = self._.trans
         local code

         --(1) visibility?
    10   if sent.visib == nil then
     6     code = ""
     4   elseif sent.visib == "export" then
     2     code = "export default "
     2   elseif sent.visib == "pub" then
     2     code = "export "
         end

         --(2) var or const definition?
    10   if sent.def == "var" then
     3     code = code .. "let "
     7   elseif sent.def == "const" then
     3     code = code .. "const "
         end

         --(3) variables
    10   if not sent.def then
     4     code = "({"
         else
     6     code = code .. "{"
         end

    25   for i, var in ipairs(sent.vars) do
    15     if sent.def then
    12       code = code .. (i == 1 and "" or ", ") .. string.format(
     6         "%s%s",
     6         var.name,
     6         var.value and (" = " .. trans:_trans(var.value)) or ""
    12       )
           else
    18       code = code .. (i == 1 and "" or ", ") .. string.format(
     9         "%s: %s%s",
     9         var.name,
     9         self:_transDataAccess(var),
     9         var.value and (" = " .. trans:_trans(var.value)) or ""
     7       )
           end
         end

    10   code = code .. "}"

         --(4) expression
    10   code = code .. " = " .. trans:_trans(sent.exp)

    10   if not sent.def then
     4     code = code .. ")"
         end

    10   code = code .. ";"

         --(5) return
    10   return code
       end

       --Transform {...} := Exp.
       --
       --@param sent:Unpack
       --@return string
     1 function UnpackTrans:_transReadOnlyFieldsMap(sent)
     1   local trans = self._.trans
         local code, valVar

         --(1) list value
     1   valVar = self:_getRandomName()
     1   code = string.format("const %s = %s;", valVar, trans:_trans(sent.exp))

         --(2) unpack
     4   for _, fld in ipairs(sent.vars) do
     3     local name = fld.name

     3     if fld.mod == "." then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "%s", {value: %s["%s"], enum: true});',
     1         name,
     1         valVar,
               name
     2       )
     2     elseif fld.mod == ":" then
     2       code = code .. string.format(
     1         'Object.defineProperty(this, "_%s", {value: %s["%s"]});',
     1         name,
     1         valVar,
               name
     2       )
           else
     1       code = code .. string.format('%s = %s["%s"];', name, valVar, name)
           end
         end

         --(3) return
     1   return code
       end

==============================================================================
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/util.lua
==============================================================================
       --imports
     1 local tablex = require("pl.tablex")

     1 package.loaded[...] = {
         transName = function(name)
   390     local KEYWORDS = {
   390       "abstract", "await",
   390       "break",
   390       "case", "char", "class", "const", "continue",
   390       "debugger", "default", "do",
   390       "else", "enum", "export", "extends",
   390       "final", "finally", "for", "function",
   390       "goto",
   390       "if", "implements", "import", "in", "instanceof", "interface",
   390       "let",
   390       "native", "new",
   390       "private", "protected", "public",
   390       "return",
   390       "static", "super", "switch",
   390       "this", "throw", "transient", "try", "typeof",
   390       "var", "volatile",
   390       "while", "with",
             "yield"
   390     }

   390     if tablex.find(KEYWORDS, name) then
     5       return name .. "_"
           else
   385       return name
           end
         end
     1 }

==============================================================================
Summary
==============================================================================

File                                                                 Hits Missed Coverage
-----------------------------------------------------------------------------------------
/home/me/.luarocks/share/lua/5.3/dogma/lex/Lexer.lua                 426  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/LiteralType.lua           4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/TokenType.lua             10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/AdvancedList.lua        21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Annotation.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Char.lua                9    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Comment.lua             10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Directive.lua           10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Eol.lua                 10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Id.lua                  7    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Keyword.lua             61   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Literal.lua             12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Name.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/ProcessedList.lua       21   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Reader.lua              51   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Symbol.lua              10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/lex/_/Token.lua               10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveParser.lua       43   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/DirectiveType.lua         4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/ExpParser.lua             338  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/NodeType.lua              4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/NonTerminalType.lua       4    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/Parser.lua                112  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/SentType.lua              6    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtParser.lua            587  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/StmtType.lua              22   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/TerminalType.lua          19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/UnpackParser.lua          74   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/AsyncStmt.lua           12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BinOp.lua               18   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BlockParser.lua         34   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/BreakStmt.lua           8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CallOp.lua              15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/CatchCl.lua             8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ConstStmt.lua           13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DataAccess.lua          5    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Directive.lua           10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/DoStmt.lua              13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/EnumStmt.lua            19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Exp.lua                 15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ExportStmt.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FinallyCl.lua           7    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FnStmt.lua              17   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForEachStmt.lua         15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ForStmt.lua             15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/FromStmt.lua            13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfDirective.lua         12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfStmt.lua              13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/IfSubExp.lua            19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralFn.lua           28   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralList.lua         14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/LiteralMap.lua          14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NaryOp.lua              22   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NativeFn.lua            12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NextStmt.lua            8    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Node.lua                9    0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/NonTerminal.lua         14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ObjectStmt.lua          10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Op.lua                  75   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PackOp.lua              16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Param.lua               13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Params.lua              12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PevalFn.lua             12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/PubStmt.lua             17   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ReturnStmt.lua          20   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/RunWithDirective.lua    10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Sent.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SliceOp.lua             15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Stmt.lua                10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubExp.lua              10   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SubParser.lua           17   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/SyntaxTree.lua          75   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Terminal.lua            16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/ThrowFn.lua             16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/TypeStmt.lua            16   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UnaryOp.lua             29   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/Unpack.lua              15   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/UseStmt.lua             29   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/VarStmt.lua             13   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WhileStmt.lua           14   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/syn/_/WithStmt.lua            12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/Trans.lua               12   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/Trans.lua            43   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/DirectiveTrans.lua 27   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/ExpTrans.lua       269  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/StmtTrans.lua      452  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/SubTrans.lua       19   0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/UnpackTrans.lua    137  0      100.00%
/home/me/.luarocks/share/lua/5.3/dogma/trans/js/_/util.lua           24   0      100.00%
-----------------------------------------------------------------------------------------
Total                                                                3782 0      100.00%
